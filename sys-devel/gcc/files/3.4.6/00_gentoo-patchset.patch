diff --git a/boehm-gc/configure b/boehm-gc/configure
index 3ff5861..930ca89 100755
--- a/boehm-gc/configure
+++ b/boehm-gc/configure
@@ -1937,14 +1937,7 @@ irix5* | irix6*)
 
 # This must be Linux ELF.
 linux-gnu*)
-  case $host_cpu in
-  alpha* | mips* | hppa* | i*86 | powerpc* | sparc* | ia64* | sh* )
-    lt_cv_deplibs_check_method=pass_all ;;
-  *)
-    # glibc up to 2.1.1 does not perform some relocations on ARM
-    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )' ;;
-  esac
-  lt_cv_file_magic_test_file=`echo /lib/libc.so* /lib/libc-*.so`
+  lt_cv_deplibs_check_method=pass_all
   ;;
 
 netbsd*)
diff --git a/boehm-gc/ia64_save_regs_in_stack.S b/boehm-gc/ia64_save_regs_in_stack.S
new file mode 100644
index 0000000..632913d
--- /dev/null
+++ b/boehm-gc/ia64_save_regs_in_stack.S
@@ -0,0 +1,15 @@
+        .text
+        .align 16
+        .global GC_save_regs_in_stack
+        .proc GC_save_regs_in_stack
+GC_save_regs_in_stack:
+        .body
+        flushrs
+        ;;
+        mov r8=ar.bsp
+        br.ret.sptk.few rp
+        .endp GC_save_regs_in_stack
+
+#ifdef __linux__
+	.section .note.GNU-stack,"",@progbits
+#endif
diff --git a/boehm-gc/ia64_save_regs_in_stack.s b/boehm-gc/ia64_save_regs_in_stack.s
index 3b18c08..e69de29 100644
--- a/boehm-gc/ia64_save_regs_in_stack.s
+++ b/boehm-gc/ia64_save_regs_in_stack.s
@@ -1,12 +0,0 @@
-        .text
-        .align 16
-        .global GC_save_regs_in_stack
-        .proc GC_save_regs_in_stack
-GC_save_regs_in_stack:
-        .body
-        flushrs
-        ;;
-        mov r8=ar.bsp
-        br.ret.sptk.few rp
-        .endp GC_save_regs_in_stack
-
diff --git a/contrib/gcc_update b/contrib/gcc_update
index b89a9af..3eaa3e4 100755
--- a/contrib/gcc_update
+++ b/contrib/gcc_update
@@ -123,7 +123,16 @@ touch_files () {
     chat '	echo Touching $@... 1>&2; \' >> Makefile.$$
     echo '	touch $@' >> Makefile.$$
     files_and_dependencies | sed 's,[^ ]* ,,;s,$, :,' >> Makefile.$$
-    while ${MAKE-make} -s -f Makefile.$$ all | grep . > /dev/null; do
+
+    # We would have to explicitly shut off the "Entering... Leaving..."
+    # messages through "--no-print-directory" to handle the case when
+    # we were called from a recursive invocation (i.e. "$(MAKE)" in a
+    # Makefile, not just make).  Passing only "-s" doesn't help then,
+    # because make has helpfully added "-w" to MAKEFLAGS automatically.
+    # Unfortunately we do not require GNU make other than for building
+    # and testing, so let's just grep known text explicitly echoed by
+    # the rule.
+    while ${MAKE-make} -s -f Makefile.$$ all | grep Touching > /dev/null; do
       sleep 1
     done 2>&1
     rm -f Makefile.$$
diff --git a/gcc/Makefile.in b/gcc/Makefile.in
index 30815af..7bd2600 100644
--- a/gcc/Makefile.in
+++ b/gcc/Makefile.in
@@ -1185,6 +1185,7 @@ libgcc.mk: config.status Makefile mklibgcc $(LIB2ADD) $(LIB2ADD_ST) $(LIB2ADD_SH
 	SHLIB_MAPFILES='$(SHLIB_MAPFILES)' \
 	SHLIB_NM_FLAGS='$(SHLIB_NM_FLAGS)' \
 	MULTILIB_OSDIRNAMES='$(MULTILIB_OSDIRNAMES)' \
+	GCC_FOR_TARGET='$(GCC_FOR_TARGET)' \
 	mkinstalldirs='$(SHELL) $(srcdir)/mkinstalldirs' \
 	  $(SHELL) mklibgcc > tmp-libgcc.mk
 	mv tmp-libgcc.mk libgcc.mk
@@ -2409,8 +2410,8 @@ protoize.o: protoize.c $(srcdir)/../include/getopt.h $(CONFIG_H) $(SYSTEM_H) \
 	  $(DRIVER_DEFINES) \
 	  $(srcdir)/protoize.c $(OUTPUT_OPTION))
 
-unprotoize.o: protoize.c $(srcdir)/../include/getopt.h \
-   $(CONFIG_H) $(SYSTEM_H) Makefile version.h
+unprotoize.o: protoize.c $(srcdir)/../include/getopt.h $(CONFIG_H) \
+    $(SYSTEM_H) coretypes.h $(TM_H) Makefile version.h cppdefault.h intl.h
 	(SHLIB_LINK='$(SHLIB_LINK)' \
 	SHLIB_MULTILIB='$(SHLIB_MULTILIB)'; \
 	$(CC) -c -DUNPROTOIZE $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
@@ -2504,6 +2505,9 @@ stmp-int-hdrs: $(STMP_FIXINC) $(USER_H) xlimits.h
 	rm -f include/limits.h
 	cp xlimits.h include/limits.h
 	chmod a+r include/limits.h
+	if [ x"$(STMP_FIXINC)" = x ]; then \
+	  cp $(srcdir)/gsyslimits.h include/syslimits.h; \
+	fi
 # Install the README
 	rm -f include/README
 	cp $(srcdir)/README-fixinc include/README
@@ -2532,6 +2536,7 @@ fixinc.sh: $(FIXINCSRCDIR)/mkfixinc.sh $(FIXINCSRCDIR)/fixincl.c \
 	(MAKE="$(MAKE)"; srcdir=`cd $(srcdir)/fixinc && ${PWD_COMMAND}` ; \
 	CC="$(CC_FOR_BUILD)"; CFLAGS="$(BUILD_CFLAGS)"; LDFLAGS="$(BUILD_LDFLAGS)"; \
 	WARN_CFLAGS="$(WARN_CFLAGS)"; LIBERTY=`${PWD_COMMAND}`/"$(BUILD_LIBIBERTY)"; \
+	SHELL="$(SHELL)"; export SHELL; \
 	export MAKE srcdir CC CFLAGS LDFLAGS WARN_CFLAGS LIBERTY; \
 	cd ./fixinc && \
 	$(SHELL) $${srcdir}/mkfixinc.sh $(build) $(target))
@@ -2916,7 +2921,7 @@ install-common: native $(EXTRA_PARTS) lang.install-common installdirs
 	  else true; fi; \
 	done
 # Don't mess with specs if it doesn't exist yet.
-	-if [ -f specs ] ; then \
+	-if [ -f specs ] && [ x"$(STMP_FIXINC)" != x ] ; then \
 	  rm -f $(DESTDIR)$(libsubdir)/specs; \
 	  $(INSTALL_DATA) $(SPECS) $(DESTDIR)$(libsubdir)/specs; \
 	  chmod a-x $(DESTDIR)$(libsubdir)/specs; \
diff --git a/gcc/c-common.c b/gcc/c-common.c
index 30f869a..edc3030 100644
--- a/gcc/c-common.c
+++ b/gcc/c-common.c
@@ -832,7 +832,7 @@ const struct attribute_spec c_common_attribute_table[] =
 			      handle_deprecated_attribute },
   { "vector_size",	      1, 1, false, true, false,
 			      handle_vector_size_attribute },
-  { "visibility",	      1, 1, true,  false, false,
+  { "visibility",	      1, 1, false, false, false,
 			      handle_visibility_attribute },
   { "tls_model",	      1, 1, true,  false, false,
 			      handle_tls_model_attribute },
@@ -4937,7 +4937,16 @@ handle_visibility_attribute (tree *node, tree name, tree args,
 
   *no_add_attrs = true;
 
-  if (decl_function_context (decl) != 0 || ! TREE_PUBLIC (decl))
+  if (TYPE_P (*node))
+    {
+      if (TREE_CODE (*node) != RECORD_TYPE && TREE_CODE (*node) != UNION_TYPE)
+       {
+         warning ("`%s' attribute ignored on non-class types",
+                  IDENTIFIER_POINTER (name));
+         return NULL_TREE;
+       }
+    }
+  else if (decl_function_context (decl) != 0 || ! TREE_PUBLIC (decl))
     {
       warning ("`%s' attribute ignored", IDENTIFIER_POINTER (name));
       return NULL_TREE;
@@ -4948,6 +4957,14 @@ handle_visibility_attribute (tree *node, tree name, tree args,
       error ("visibility arg not a string");
       return NULL_TREE;
     }
+  
+  /*  If this is a type, set the visibility on the type decl.  */
+  if (TYPE_P (decl))
+    {
+      decl = TYPE_NAME (decl);
+      if (! decl)
+        return NULL_TREE;
+    }
 
   if (strcmp (TREE_STRING_POINTER (id), "default") == 0)
     DECL_VISIBILITY (decl) = VISIBILITY_DEFAULT;
@@ -4959,6 +4976,14 @@ handle_visibility_attribute (tree *node, tree name, tree args,
     DECL_VISIBILITY (decl) = VISIBILITY_PROTECTED;
   else
     error ("visibility arg must be one of \"default\", \"hidden\", \"protected\" or \"internal\"");
+  DECL_VISIBILITY_SPECIFIED (decl) = 1;
+
+  /* For decls only, go ahead and attach the attribute to the node as well.
+     This is needed so we can determine whether we have VISIBILITY_DEFAULT
+     because the visibility was not specified, or because it was explicitly
+     overridden from the class visibility.  */
+  if (DECL_P (*node))
+    *no_add_attrs = false;
 
   return NULL_TREE;
 }
diff --git a/gcc/c-decl.c b/gcc/c-decl.c
index 66e0fd7..9737791 100644
--- a/gcc/c-decl.c
+++ b/gcc/c-decl.c
@@ -1173,9 +1173,8 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,
     }
 
   /* warnings */
-  /* All decls must agree on a non-default visibility.  */
-  if (DECL_VISIBILITY (newdecl) != VISIBILITY_DEFAULT
-      && DECL_VISIBILITY (olddecl) != VISIBILITY_DEFAULT
+  /* All decls must agree on a visibility.  */
+  if (DECL_VISIBILITY_SPECIFIED (newdecl) && DECL_VISIBILITY_SPECIFIED (olddecl)
       && DECL_VISIBILITY (newdecl) != DECL_VISIBILITY (olddecl))
     {
       warning ("%Jredeclaration of '%D' with different visibility "
@@ -1378,9 +1377,12 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)
      Currently, it can only be defined in the prototype.  */
   COPY_DECL_ASSEMBLER_NAME (olddecl, newdecl);
 
-  /* If either declaration has a nondefault visibility, use it.  */
-  if (DECL_VISIBILITY (olddecl) != VISIBILITY_DEFAULT)
-    DECL_VISIBILITY (newdecl) = DECL_VISIBILITY (olddecl);
+  /* Use visibility of whichever declaration had it specified */
+  if (DECL_VISIBILITY_SPECIFIED (olddecl))
+    {
+      DECL_VISIBILITY (newdecl) = DECL_VISIBILITY (olddecl);
+      DECL_VISIBILITY_SPECIFIED (newdecl) = 1;
+    }
 
   if (TREE_CODE (newdecl) == FUNCTION_DECL)
     {
@@ -2820,7 +2822,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)
 	{
 	  tree builtin = built_in_decls [DECL_FUNCTION_CODE (decl)];
 	  SET_DECL_RTL (builtin, NULL_RTX);
-	  SET_DECL_ASSEMBLER_NAME (builtin, get_identifier (starred));
+	  change_decl_assembler_name (builtin, get_identifier (starred));
 #ifdef TARGET_MEM_FUNCTIONS
 	  if (DECL_FUNCTION_CODE (decl) == BUILT_IN_MEMCPY)
 	    init_block_move_fn (starred);
diff --git a/gcc/c-opts.c b/gcc/c-opts.c
index 2a61744..acb55c5 100644
--- a/gcc/c-opts.c
+++ b/gcc/c-opts.c
@@ -920,6 +920,10 @@ c_common_handle_option (size_t scode, const char *arg, int value)
     case OPT_fuse_cxa_atexit:
       flag_use_cxa_atexit = value;
       break;
+      
+    case OPT_fvisibility_inlines_hidden:
+      visibility_options.inlines_hidden = value;
+      break;
 
     case OPT_fweak:
       flag_weak = value;
diff --git a/gcc/c-parse.in b/gcc/c-parse.in
index 66d27ac..8d35972 100644
--- a/gcc/c-parse.in
+++ b/gcc/c-parse.in
@@ -57,6 +57,11 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 /* Like YYERROR but do call yyerror.  */
 #define YYERROR1 { yyerror ("syntax error"); YYERROR; }
 
+/* Newer bison doesn't define YYLEX anymore.  */
+#ifndef YYLEX
+# define YYLEX yylex()
+#endif
+
 /* Like the default stack expander, except (1) use realloc when possible,
    (2) impose no hard maxiumum on stack size, (3) REALLY do not use alloca.
 
@@ -1730,7 +1735,7 @@ enum_head:
 
 structsp_attr:
 	  struct_head identifier '{'
-		{ $$ = start_struct (RECORD_TYPE, $2);
+		{ $<ttype>$ = start_struct (RECORD_TYPE, $2);
 		  /* Start scope of tag before parsing components.  */
 		}
 	  component_decl_list '}' maybe_attribute
@@ -1741,7 +1746,7 @@ structsp_attr:
 				      nreverse ($3), chainon ($1, $5));
 		}
 	| union_head identifier '{'
-		{ $$ = start_struct (UNION_TYPE, $2); }
+		{ $<ttype>$ = start_struct (UNION_TYPE, $2); }
 	  component_decl_list '}' maybe_attribute
 		{ $$ = finish_struct ($<ttype>4, nreverse ($5),
 				      chainon ($1, $7)); }
@@ -1750,12 +1755,12 @@ structsp_attr:
 				      nreverse ($3), chainon ($1, $5));
 		}
 	| enum_head identifier '{'
-		{ $$ = start_enum ($2); }
+		{ $<ttype>$ = start_enum ($2); }
 	  enumlist maybecomma_warn '}' maybe_attribute
 		{ $$ = finish_enum ($<ttype>4, nreverse ($5),
 				    chainon ($1, $8)); }
 	| enum_head '{'
-		{ $$ = start_enum (NULL_TREE); }
+		{ $<ttype>$ = start_enum (NULL_TREE); }
 	  enumlist maybecomma_warn '}' maybe_attribute
 		{ $$ = finish_enum ($<ttype>3, nreverse ($4),
 				    chainon ($1, $7)); }
diff --git a/gcc/c-pragma.c b/gcc/c-pragma.c
index 10c8cae..e68ebf2 100644
--- a/gcc/c-pragma.c
+++ b/gcc/c-pragma.c
@@ -481,6 +481,86 @@ maybe_apply_renaming_pragma (tree decl, tree asmname)
   return asmname;
 }
 
+
+#ifdef HANDLE_PRAGMA_VISIBILITY
+static void handle_pragma_visibility (cpp_reader *);
+
+/* Sets the default visibility for symbols to something other than that
+   specified on the command line.  */
+static void
+handle_pragma_visibility (cpp_reader *dummy ATTRIBUTE_UNUSED)
+{ /* Form is #pragma GCC visibility push(hidden)|pop */
+  static int visstack [16], visidx;
+  tree x;
+  enum cpp_ttype token;
+  enum { bad, push, pop } action = bad;
+ 
+  token = c_lex (&x);
+  if (token == CPP_NAME)
+    {
+      const char *op = IDENTIFIER_POINTER (x);
+      if (!strcmp (op, "push"))
+        action = push;
+      else if (!strcmp (op, "pop"))
+        action = pop;
+    }
+  if (bad == action)
+    GCC_BAD ("#pragma GCC visibility must be followed by push or pop");
+  else
+    {
+      if (pop == action)
+        {
+          if (!visidx)
+            {
+              GCC_BAD ("No matching push for '#pragma GCC visibility pop'");
+            }
+          else
+            {
+              default_visibility = visstack[--visidx];
+              visibility_options.inpragma = (visidx>0);
+            }
+        }
+      else
+        {
+          if (c_lex (&x) != CPP_OPEN_PAREN)
+            GCC_BAD ("missing '(' after '#pragma GCC visibility push' - ignored");
+          token = c_lex (&x);
+          if (token != CPP_NAME)
+            {
+              GCC_BAD ("malformed #pragma GCC visibility push");
+            }
+          else if (visidx >= 16)
+            {
+              GCC_BAD ("No more than sixteen #pragma GCC visibility pushes allowed at once");
+            }
+          else
+            {
+              const char *str = IDENTIFIER_POINTER (x);
+              visstack[visidx++] = default_visibility;
+              if (!strcmp (str, "default"))
+                default_visibility = VISIBILITY_DEFAULT;
+              else if (!strcmp (str, "internal"))
+                default_visibility = VISIBILITY_INTERNAL;
+              else if (!strcmp (str, "hidden"))
+                default_visibility = VISIBILITY_HIDDEN;  
+              else if (!strcmp (str, "protected"))
+                default_visibility = VISIBILITY_PROTECTED;
+              else
+                {
+                  GCC_BAD ("#pragma GCC visibility push() must specify default, internal, hidden or protected");
+                }
+              visibility_options.inpragma = 1;
+            }
+          if (c_lex (&x) != CPP_CLOSE_PAREN)
+            GCC_BAD ("missing '(' after '#pragma GCC visibility push' - ignored");
+        }
+    }
+  if (c_lex (&x) != CPP_EOF)
+    warning ("junk at end of '#pragma GCC visibility'");
+}
+
+#endif
+
 /* Front-end wrapper for pragma registration to avoid dragging
    cpplib.h in almost everywhere.  */
 void
@@ -506,6 +586,9 @@ init_pragma (void)
 #ifdef HANDLE_PRAGMA_EXTERN_PREFIX
   c_register_pragma (0, "extern_prefix", handle_pragma_extern_prefix);
 #endif
+#ifdef HANDLE_PRAGMA_VISIBILITY
+  c_register_pragma ("GCC", "visibility", handle_pragma_visibility);
+#endif
 
 #ifdef REGISTER_TARGET_PRAGMAS
   REGISTER_TARGET_PRAGMAS ();
diff --git a/gcc/c-pragma.h b/gcc/c-pragma.h
index a1469db..240a59d 100644
--- a/gcc/c-pragma.h
+++ b/gcc/c-pragma.h
@@ -44,6 +44,11 @@ extern struct cpp_reader* parse_in;
 #define HANDLE_PRAGMA_PACK 1
 #endif /* HANDLE_PRAGMA_PACK_PUSH_POP */
 
+/* It's safe to always leave visibility pragma enabled as if
+   visibility is not supported on the host OS platform the
+   statements are ignored.  */
+#define HANDLE_PRAGMA_VISIBILITY 1
+
 extern void init_pragma (void);
 
 /* Front-end wrapper for pragma registration to avoid dragging
diff --git a/gcc/c.opt b/gcc/c.opt
index 7160dab..36a4056 100644
--- a/gcc/c.opt
+++ b/gcc/c.opt
@@ -656,6 +656,10 @@ fuse-cxa-atexit
 C++ ObjC++
 Use __cxa_atexit to register destructors
 
+fvisibility-inlines-hidden
+C++
+Marks all inlined methods as having hidden visibility
+
 fvtable-gc
 C++ ObjC++
 Discard unused virtual functions
diff --git a/gcc/collect2.c b/gcc/collect2.c
index 33206f5..2d2d34e 100644
--- a/gcc/collect2.c
+++ b/gcc/collect2.c
@@ -34,6 +34,12 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 #if ! defined( SIGCHLD ) && defined( SIGCLD )
 #  define SIGCHLD SIGCLD
 #endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#if HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
 
 #ifdef vfork /* Autoconf may define this to fork for us.  */
 # define VFORK_STRING "fork"
@@ -1534,7 +1540,7 @@ collect_execute (const char *prog, char **argv, const char *redir)
   if (redir)
     {
       /* Open response file.  */
-      redir_handle = open (redir, O_WRONLY | O_TRUNC | O_CREAT);
+      redir_handle = open (redir, O_WRONLY | O_TRUNC | O_CREAT, S_IRUSR | S_IWUSR);
 
       /* Duplicate the stdout and stderr file handles
 	 so they can be restored later.  */
@@ -1574,14 +1580,24 @@ fork_execute (const char *prog, char **argv)
   do_wait (prog);
 }
 
-/* Unlink a file unless we are debugging.  */
-
+/* Unlink a file unless we are debugging or file is not normal.  */
+#ifndef S_ISLNK
+#ifdef S_IFLNK
+#define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
+#else
+#define S_ISLNK(m) 0
+#define lstat stat
+#endif
+#endif
 static void
 maybe_unlink (const char *file)
 {
-  if (!debug)
-    unlink (file);
-  else
+  if (!debug) {
+    struct stat st;
+    if (lstat (file, &st) == 0
+        && (S_ISREG (st.st_mode) || S_ISLNK (st.st_mode)))
+      unlink (file);
+  } else
     notice ("[Leaving %s]\n", file);
 }
 
diff --git a/gcc/common.opt b/gcc/common.opt
index 20d1b75..56ac1ef 100644
--- a/gcc/common.opt
+++ b/gcc/common.opt
@@ -718,6 +718,11 @@ fverbose-asm
 Common
 Add extra commentary to assembler output
 
+fvisibility=
+Common Joined RejectNegative
+-fvisibility=[default|internal|hidden|protected]	Set the default symbol visibility
+
+
 fvpt
 Common
 Use expression value profiles in optimizations
diff --git a/gcc/config.gcc b/gcc/config.gcc
index d22f34b..a14e18c 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -321,7 +321,7 @@ s390*-*-*)
 	need_64bit_hwint=yes
 	;;
 # Note the 'l'; we need to be able to match e.g. "shle" or "shl".
-sh[123456789l]*-*-*)
+sh[123456789lbe]*-*-*)
 	cpu_type=sh
 	need_64bit_hwint=yes
 	;;
@@ -678,6 +678,11 @@ arm*-*-netbsd*)
 	;;
 arm*-*-linux*)			# ARM GNU/Linux with ELF
 	tm_file="dbxelf.h elfos.h linux.h arm/elf.h  arm/linux-gas.h arm/linux-elf.h arm/aout.h arm/arm.h"
+	case $target in
+	arm*b-*)
+		tm_defines="TARGET_BIG_ENDIAN_DEFAULT=1 $tm_defines"
+		;;
+	esac
 	tmake_file="t-slibgcc-elf-ver t-linux arm/t-linux"
 	extra_parts="crtbegin.o crtbeginS.o crtend.o crtendS.o"
 	gnu_ld=yes
@@ -977,11 +982,11 @@ x86_64-*-netbsd*)
 	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h netbsd.h netbsd-elf.h i386/x86-64.h i386/netbsd64.h"
 	;;
 i[34567]86-*-openbsd*)
-	tm_file="i386/i386.h i386/unix.h i386/bsd.h i386/gas.h i386/gstabs.h openbsd-oldgas.h openbsd.h i386/openbsd.h"
-	# needed to unconfuse gdb
-	tmake_file="t-libc-ok t-openbsd i386/t-openbsd"
-	# we need collect2 until our bug is fixed...
-	use_collect2=yes
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h i386/i386elf.h"
+	tm_file="${tm_file} openbsd.h i386/openbsdelf.h"
+	gas=yes
+	gnu_ld=yes
+	stabs=yes
 	;;
 i[34567]86-*-coff*)
 	tm_file="${tm_file} i386/unix.h i386/bsd.h i386/gas.h dbxcoff.h i386/i386-coff.h"
@@ -1273,9 +1278,16 @@ ia64*-*-freebsd*)
 	;;
 ia64*-*-linux*)
 	tm_file="${tm_file} dbxelf.h elfos.h svr4.h linux.h ia64/sysv4.h ia64/linux.h"
-	tmake_file="t-slibgcc-elf-ver t-linux ia64/t-ia64 t-libunwind ia64/t-glibc"
-	if test x$with_system_libunwind != xyes ; then
-		tmake_file="${tmake_file} t-libunwind-elf ia64/t-glibc-libunwind"
+	tmake_file="t-slibgcc-elf-ver t-linux ia64/t-ia64"
+	if test x${target} = x${host} && test x${target} = x${build} \
+	   && grep gelf_getverdef /usr/include/gelf.h > /dev/null 2>&1 \
+	   && test -f /usr/lib/libelf.so; then
+		tmake_file="${tmake_file} ia64/t-glibc-no-libunwind"
+	else
+		tmake_file="${tmake_file} t-libunwind ia64/t-glibc"
+		if test x$with_system_libunwind != xyes ; then
+			tmake_file="${tmake_file} t-libunwind-elf ia64/t-glibc-libunwind"
+		fi
 	fi
 	target_cpu_default="MASK_GNU_AS|MASK_GNU_LD"
 	extra_parts="crtbegin.o crtend.o crtbeginS.o crtendS.o crtfastmath.o"
@@ -2019,7 +2031,8 @@ sparc-*-netbsdelf*)
 	;;
 sparc-*-openbsd*)
 	tm_defines=OBSD_OLD_GAS
-	tm_file="sparc/sparc.h openbsd.h sparc/openbsd.h"
+	tm_file="sparc/sparc.h elfos.h svr4.h sparc/sysv4.h ${tm_file}"
+	tm_file="${tm_file} exec-stack.h"
 	# needed to unconfuse gdb
 	tmake_file="t-libc-ok t-openbsd sparc/t-openbsd"
 	# we need collect2 until our bug is fixed...
diff --git a/gcc/config/alpha/alpha.h b/gcc/config/alpha/alpha.h
index ae3a349..bcaeda6 100644
--- a/gcc/config/alpha/alpha.h
+++ b/gcc/config/alpha/alpha.h
@@ -96,7 +96,7 @@ Boston, MA 02111-1307, USA.  */
   while (0)
 #endif
 
-#define CPP_SPEC "%(cpp_subtarget)"
+#define CPP_SPEC "%(cpp_subtarget) %{!no-ieee:-mieee}"
 
 #ifndef CPP_SUBTARGET_SPEC
 #define CPP_SUBTARGET_SPEC ""
@@ -301,6 +301,8 @@ extern int alpha_tls_size;
      N_("Request IEEE-conformant math library routines (OSF/1)")},	\
     {"ieee", MASK_IEEE|MASK_IEEE_CONFORMANT,				\
      N_("Emit IEEE-conformant code, without inexact exceptions")},	\
+    {"no-ieee", - (MASK_IEEE|MASK_IEEE_CONFORMANT),				\
+     N_("Do not emit IEEE-conformant code, without inexact exceptions")},	\
     {"ieee-with-inexact", MASK_IEEE_WITH_INEXACT|MASK_IEEE_CONFORMANT,	\
      N_("Emit IEEE-conformant code, with inexact exceptions")},		\
     {"build-constants", MASK_BUILD_CONSTANTS,				\
diff --git a/gcc/config/alpha/linux.h b/gcc/config/alpha/linux.h
index a4bc3d3..9e99114 100644
--- a/gcc/config/alpha/linux.h
+++ b/gcc/config/alpha/linux.h
@@ -73,6 +73,7 @@ Boston, MA 02111-1307, USA.  */
 /* Do code reading to identify a signal frame, and set the frame
    state data appropriately.  See unwind-dw2.c for the structs.  */
 
+#ifndef inhibit_libc
 #ifdef IN_LIBGCC2
 #include <signal.h>
 #include <sys/ucontext.h>
@@ -94,8 +95,8 @@ Boston, MA 02111-1307, USA.  */
     else if (pc_[1] == 0x201f015f)	/* lda $0,NR_rt_sigreturn */	\
       {									\
 	struct rt_sigframe {						\
-	  struct siginfo info;						\
-	  struct ucontext uc;						\
+	  siginfo_t info;						\
+	  ucontext_t uc;						\
 	} *rt_ = (CONTEXT)->cfa;					\
 	sc_ = &rt_->uc.uc_mcontext;					\
       }									\
@@ -122,3 +123,4 @@ Boston, MA 02111-1307, USA.  */
     (FS)->retaddr_column = 64;						\
     goto SUCCESS;							\
   } while (0)
+#endif /* inhibit_libc */
diff --git a/gcc/config/arm/arm.c b/gcc/config/arm/arm.c
index 2f0eaed..9a2c479 100644
--- a/gcc/config/arm/arm.c
+++ b/gcc/config/arm/arm.c
@@ -4572,6 +4572,10 @@ minmax_code (rtx x)
 int
 adjacent_mem_locations (rtx a, rtx b)
 {
+  /* We don't guarantee to preserve the order of these memory refs.  */
+  if (volatile_refs_p (a) || volatile_refs_p (b))
+    return 0;
+
   if ((GET_CODE (XEXP (a, 0)) == REG
        || (GET_CODE (XEXP (a, 0)) == PLUS
 	   && GET_CODE (XEXP (XEXP (a, 0), 1)) == CONST_INT))
@@ -4611,6 +4615,17 @@ adjacent_mem_locations (rtx a, rtx b)
 	return 0;
 
       val_diff = val1 - val0;
+
+      if (arm_ld_sched)
+	{
+	  /* If the target has load delay slots, then there's no benefit
+	     to using an ldm instruction unless the offset is zero and
+	     we are optimizing for size.  */
+	  return (optimize_size && (REGNO (reg0) == REGNO (reg1))
+		  && (val0 == 0 || val1 == 0 || val0 == 4 || val1 == 4)
+		  && (val_diff == 4 || val_diff == -4));
+	}
+
       return ((REGNO (reg0) == REGNO (reg1))
 	      && (val_diff == 4 || val_diff == -4));
     }
@@ -4857,6 +4872,11 @@ load_multiple_sequence (rtx *operands, int nops, int *regs, int *base,
       *load_offset = unsorted_offsets[order[0]];
     }
 
+  /* For XScale a two-word LDM is a performance loss, so only do this if
+     size is more important.  See comments in arm_gen_load_multiple.  */
+  if (nops == 2 && arm_tune_xscale && !optimize_size)
+    return 0;
+
   if (unsorted_offsets[order[0]] == 0)
     return 1; /* ldmia */
 
@@ -5083,6 +5103,11 @@ store_multiple_sequence (rtx *operands, int nops, int *regs, int *base,
       *load_offset = unsorted_offsets[order[0]];
     }
 
+  /* For XScale a two-word LDM is a performance loss, so only do this if
+     size is more important.  See comments in arm_gen_load_multiple.  */
+  if (nops == 2 && arm_tune_xscale && !optimize_size)
+    return 0;
+
   if (unsorted_offsets[order[0]] == 0)
     return 1; /* stmia */
 
@@ -8514,6 +8539,26 @@ arm_output_function_prologue (FILE *f, HOST_WIDE_INT frame_size)
   return_used_this_function = 0;  
 }
 
+/* Return the number (counting from 0) of
+   the least significant set bit in MASK.  */
+
+#ifdef __GNUC__
+inline
+#endif
+static int
+number_of_first_bit_set (mask)
+     int mask;
+{
+  int bit;
+
+  for (bit = 0;
+       (mask & (1 << bit)) == 0;
+       ++bit)
+    continue;
+
+  return bit;
+}
+
 const char *
 arm_output_epilogue (rtx sibling)
 {
@@ -8747,27 +8792,47 @@ arm_output_epilogue (rtx sibling)
 	  saved_regs_mask |=   (1 << PC_REGNUM);
 	}
 
-      /* Load the registers off the stack.  If we only have one register
-	 to load use the LDR instruction - it is faster.  */
-      if (saved_regs_mask == (1 << LR_REGNUM))
-	{
-	  /* The exception handler ignores the LR, so we do
-	     not really need to load it off the stack.  */
-	  if (eh_ofs)
-	    asm_fprintf (f, "\tadd\t%r, %r, #4\n", SP_REGNUM, SP_REGNUM);
-	  else
-	    asm_fprintf (f, "\tldr\t%r, [%r], #4\n", LR_REGNUM, SP_REGNUM);
-	}
-      else if (saved_regs_mask)
+      if (saved_regs_mask)
 	{
-	  if (saved_regs_mask & (1 << SP_REGNUM))
-	    /* Note - write back to the stack register is not enabled
-	       (ie "ldmfd sp!...").  We know that the stack pointer is
-	       in the list of registers and if we add writeback the
-	       instruction becomes UNPREDICTABLE.  */
-	    print_multi_reg (f, "ldmfd\t%r", SP_REGNUM, saved_regs_mask);
+	  /* Load the registers off the stack.  If we only have one register
+	     to load use the LDR instruction - it is faster.  */
+	  if (bit_count (saved_regs_mask) == 1)
+	    {
+	      int reg = number_of_first_bit_set (saved_regs_mask);
+
+	      switch (reg)
+		{
+		case SP_REGNUM:
+		  /* Mustn't use base writeback when loading SP.  */
+		  asm_fprintf (f, "\tldr\t%r, [%r]\n", SP_REGNUM, SP_REGNUM);
+		  break;
+		  
+		case LR_REGNUM:
+		  if (eh_ofs)
+		    {
+		      /* The exception handler ignores the LR, so we do
+			 not really need to load it off the stack.  */
+		      asm_fprintf (f, "\tadd\t%r, %r, #4\n", SP_REGNUM, SP_REGNUM);
+		      break;
+		    }
+		  /* else fall through */
+		  
+		default:
+		  asm_fprintf (f, "\tldr\t%r, [%r], #4\n", reg, SP_REGNUM);
+		  break;
+		}
+	    }
 	  else
-	    print_multi_reg (f, "ldmfd\t%r!", SP_REGNUM, saved_regs_mask);
+	    {
+	      if (saved_regs_mask & (1 << SP_REGNUM))
+		/* Note - write back to the stack register is not enabled
+		   (ie "ldmfd sp!...").  We know that the stack pointer is
+		   in the list of registers and if we add writeback the
+		   instruction becomes UNPREDICTABLE.  */
+		print_multi_reg (f, "ldmfd\t%r", SP_REGNUM, saved_regs_mask);
+	      else
+		print_multi_reg (f, "ldmfd\t%r!", SP_REGNUM, saved_regs_mask);
+	    }
 	}
 
       if (current_function_pretend_args_size)
@@ -11395,22 +11460,6 @@ replace_symbols_in_block (tree block, rtx orig, rtx new)
     }
 }
 
-/* Return the number (counting from 0) of
-   the least significant set bit in MASK.  */
-
-inline static int
-number_of_first_bit_set (int mask)
-{
-  int bit;
-
-  for (bit = 0;
-       (mask & (1 << bit)) == 0;
-       ++bit)
-    continue;
-
-  return bit;
-}
-
 /* Generate code to return from a thumb function.
    If 'reg_containing_return_addr' is -1, then the return address is
    actually on the stack, at the stack pointer.  */
diff --git a/gcc/config/arm/arm.md b/gcc/config/arm/arm.md
index 0a5e647..730248d 100644
--- a/gcc/config/arm/arm.md
+++ b/gcc/config/arm/arm.md
@@ -8811,13 +8811,16 @@
    (set_attr "length" "4,8,8")]
 )
 
+; Try to convert LDR+LDR+arith into [add+]LDM+arith
+; On XScale, LDM is always slower than two LDRs, so only do this if
+; optimising for size.
 (define_insn "*arith_adjacentmem"
   [(set (match_operand:SI 0 "s_register_operand" "=r")
 	(match_operator:SI 1 "shiftable_operator"
 	 [(match_operand:SI 2 "memory_operand" "m")
 	  (match_operand:SI 3 "memory_operand" "m")]))
    (clobber (match_scratch:SI 4 "=r"))]
-  "TARGET_ARM && adjacent_mem_locations (operands[2], operands[3])"
+  "TARGET_ARM && (!arm_tune_xscale || optimize_size) && adjacent_mem_locations (operands[2], operands[3])"
   "*
   {
     rtx ldm[3];
@@ -8852,6 +8855,8 @@
       }
    if (val1 && val2)
       {
+	/* This would be a loss on a Harvard core, but adjacent_mem_locations()
+	   will prevent it from happening.  */
 	rtx ops[3];
 	ldm[0] = ops[0] = operands[4];
 	ops[1] = XEXP (XEXP (operands[2], 0), 0);
diff --git a/gcc/config/arm/linux-elf.h b/gcc/config/arm/linux-elf.h
index 9f291c0..9958d40 100644
--- a/gcc/config/arm/linux-elf.h
+++ b/gcc/config/arm/linux-elf.h
@@ -30,17 +30,34 @@
 /* Do not assume anything about header files.  */
 #define NO_IMPLICIT_EXTERN_C
 
+/*
+ * 'config.gcc' defines TARGET_BIG_ENDIAN_DEFAULT as 1 for arm*b-*
+ * (big endian) configurations.
+ */
+#if TARGET_BIG_ENDIAN_DEFAULT
+#define TARGET_ENDIAN_DEFAULT ARM_FLAG_BIG_END
+#define TARGET_ENDIAN_OPTION "mbig-endian"
+#define TARGET_LINKER_EMULATION "armelfb_linux"
+#else
+#define TARGET_ENDIAN_DEFAULT 0
+#define TARGET_ENDIAN_OPTION "mlittle-endian"
+#define TARGET_LINKER_EMULATION "armelf_linux"
+#endif
+
 /* Default is to use APCS-32 mode.  */
 #undef  TARGET_DEFAULT
-#define TARGET_DEFAULT (ARM_FLAG_APCS_32 | ARM_FLAG_MMU_TRAPS)
+#define TARGET_DEFAULT \
+		( ARM_FLAG_APCS_32 | \
+		  ARM_FLAG_MMU_TRAPS | \
+		  TARGET_ENDIAN_DEFAULT )
 
 #define SUBTARGET_CPU_DEFAULT TARGET_CPU_arm6
 
-#define SUBTARGET_EXTRA_LINK_SPEC " -m armelf_linux -p"
+#define SUBTARGET_EXTRA_LINK_SPEC " -m " TARGET_LINKER_EMULATION " -p"
 
 #undef  MULTILIB_DEFAULTS
 #define MULTILIB_DEFAULTS \
-	{ "marm", "mlittle-endian", "mhard-float", "mapcs-32", "mno-thumb-interwork" }
+	{ "marm", TARGET_ENDIAN_OPTION, "mhard-float", "mapcs-32", "mno-thumb-interwork" }
 
 #define CPP_APCS_PC_DEFAULT_SPEC "-D__APCS_32__"
 
@@ -89,7 +106,7 @@
    %{rdynamic:-export-dynamic} \
    %{!dynamic-linker:-dynamic-linker /lib/ld-linux.so.2} \
    -X \
-   %{mbig-endian:-EB}" \
+   %{mbig-endian:-EB} %{mlittle-endian:-EL}" \
    SUBTARGET_EXTRA_LINK_SPEC
 
 #define TARGET_OS_CPP_BUILTINS() LINUX_TARGET_OS_CPP_BUILTINS()
diff --git a/gcc/config/avr/avr.c b/gcc/config/avr/avr.c
index e65a98b..e29a487 100644
--- a/gcc/config/avr/avr.c
+++ b/gcc/config/avr/avr.c
@@ -175,6 +175,18 @@ static const struct mcu_type_s avr_mcu_types[] = {
   { "at90c8534", 2, "__AVR_AT90C8534__" },
   { "at90s8535", 2, "__AVR_AT90S8535__" },
   { "at86rf401", 2, "__AVR_AT86RF401__" },
+    /* Classic + MOVW, <= 8K.  */
+  { "attiny13",   2, "__AVR_ATtiny13__" },
+  { "attiny2313", 2, "__AVR_ATtiny2313__" },  
+  { "attiny24", 2, "__AVR_ATtiny24__" },
+  { "attiny25", 2, "__AVR_ATtiny25__" },
+  { "attiny261", 2, "__AVR_ATtiny261__" },
+  { "attiny44", 2, "__AVR_ATtiny44__" },
+  { "attiny45", 2, "__AVR_ATtiny45__" },
+  { "attiny461", 2, "__AVR_ATtiny461__" },
+  { "attiny84", 2, "__AVR_ATtiny84__" },
+  { "attiny85", 2, "__AVR_ATtiny85__" },
+  { "attiny861", 2, "__AVR_ATtiny861__" },
     /* Classic, > 8K.  */
   { "avr3",      3, NULL },
   { "atmega103", 3, "__AVR_ATmega103__" },
@@ -185,6 +197,8 @@ static const struct mcu_type_s avr_mcu_types[] = {
     /* Enhanced, <= 8K.  */
   { "avr4",      4, NULL },
   { "atmega8",   4, "__AVR_ATmega8__" },
+  { "atmega48",   4, "__AVR_ATmega48__" },
+  { "atmega88",   4, "__AVR_ATmega88__" },
   { "atmega8515", 4, "__AVR_ATmega8515__" },
   { "atmega8535", 4, "__AVR_ATmega8535__" },
     /* Enhanced, > 8K.  */
@@ -193,11 +207,35 @@ static const struct mcu_type_s avr_mcu_types[] = {
   { "atmega161", 5, "__AVR_ATmega161__" },
   { "atmega162", 5, "__AVR_ATmega162__" },
   { "atmega163", 5, "__AVR_ATmega163__" },
+  { "atmega164", 5, "__AVR_ATmega164__" },
+  { "atmega165", 5, "__AVR_ATmega165__" },
+  { "atmega168", 5, "__AVR_ATmega168__" },
   { "atmega169", 5, "__AVR_ATmega169__" },
   { "atmega32",  5, "__AVR_ATmega32__" },
   { "atmega323", 5, "__AVR_ATmega323__" },
+  { "atmega324", 5, "__AVR_ATmega324__" },
+  { "atmega325", 5, "__AVR_ATmega325__" },
+  { "atmega3250", 5, "__AVR_ATmega3250__" },
+  { "atmega329", 5, "__AVR_ATmega329__" },
+  { "atmega3290", 5, "__AVR_ATmega3290__" },
+  { "atmega406", 5, "__AVR_ATmega406__" },
   { "atmega64",  5, "__AVR_ATmega64__" },
+  { "atmega640", 5, "__AVR_ATmega640__" },
+  { "atmega644", 5, "__AVR_ATmega644__" },
+  { "atmega645", 5, "__AVR_ATmega645__" },
+  { "atmega6450", 5, "__AVR_ATmega6450__" },
+  { "atmega649", 5, "__AVR_ATmega649__" },
+  { "atmega6490", 5, "__AVR_ATmega6490__" },
   { "atmega128", 5, "__AVR_ATmega128__" },
+  { "atmega1280",5, "__AVR_ATmega1280__" },
+  { "atmega1281",5, "__AVR_ATmega1281__" },
+  { "at90usb646", 5, "__AVR_AT90USB646__" },
+  { "at90usb647", 5, "__AVR_AT90USB647__" },
+  { "at90usb1286", 5, "__AVR_AT90USB1286__" },
+  { "at90usb1287", 5, "__AVR_AT90USB1287__" },
+  { "at90can32", 5, "__AVR_AT90CAN32__" },
+  { "at90can64", 5, "__AVR_AT90CAN64__" },
+  { "at90can128", 5, "__AVR_AT90CAN128__" },
   { "at94k",     5, "__AVR_AT94K__" },
     /* Assembler only.  */
   { "avr1",      1, NULL },
diff --git a/gcc/config/avr/avr.h b/gcc/config/avr/avr.h
index 4a2db2c..8ba77c5 100644
--- a/gcc/config/avr/avr.h
+++ b/gcc/config/avr/avr.h
@@ -2351,12 +2351,12 @@ extern int avr_case_values_threshold;
    Do not define this macro if it does not need to do anything.  */
 
 #define LINK_SPEC " %{!mmcu*:-m avr2}\
-%{mmcu=at90s1200|mmcu=attiny1*|mmcu=attiny28:-m avr1} \
-%{mmcu=attiny22|mmcu=attiny26|mmcu=at90s2*|mmcu=at90s4*|mmcu=at90s8*|mmcu=at90c8*|mmcu=at86rf401:-m avr2}\
+%{mmcu=at90s1200|mmcu=attiny11|mmcu=attiny12|mmcu=attiny15|mmcu=attiny28:-m avr1} \
+%{mmcu=attiny22|mmcu=attiny26|mmcu=at90s2*|mmcu=at90s4*|mmcu=at90s8*|mmcu=at90c8*|mmcu=at86rf401|mmcu=attiny13|mmcu=attiny2313|mmcu=attiny25|mmcu=attiny45|mmcu=attiny85|mmcu=attiny24|mmcu=attiny44|mmcu=attiny84|mmcu=attiny261|mmcu=attiny461|mmcu=attiny861:-m avr2}\
 %{mmcu=atmega103|mmcu=atmega603|mmcu=at43*|mmcu=at76*:-m avr3}\
-%{mmcu=atmega8*:-m avr4}\
-%{mmcu=atmega16*|mmcu=atmega32*|mmcu=atmega64|mmcu=atmega128|mmcu=at94k:-m avr5}\
-%{mmcu=atmega64|mmcu=atmega128|mmcu=atmega162|mmcu=atmega169: -Tdata 0x800100} "
+%{mmcu=atmega8*|mmcu=atmega48:-m avr4}\
+%{mmcu=atmega16*|mmcu=atmega32*|mmcu=atmega406|mmcu=atmega64*|mmcu=atmega128*|mmcu=at90can*|mmcu=at90usb*|mmcu=at94k:-m avr5}\
+%{mmcu=atmega48|mmcu=atmega88|mmcu=atmega128*|mmcu=at90can*|mmcu=at90usb*|mmcu=atmega16*|mmcu=atmega32*|mmcu=atmega406|mmcu=atmega64*: -Tdata 0x800100} "
 
 /* A C string constant that tells the GCC driver program options to
    pass to the linker.  It can also specify how to translate options
@@ -2365,7 +2365,7 @@ extern int avr_case_values_threshold;
    Do not define this macro if it does not need to do anything.  */
 
 #define LIB_SPEC \
-  "%{!mmcu=at90s1*:%{!mmcu=attiny1*:%{!mmcu=attiny28: -lc }}}"
+  "%{!mmcu=at90s1*:%{!mmcu=attiny11:%{!mmcu=attiny12:%{!mmcu=attiny15:%{!mmcu=attiny28: -lc }}}}}"
 /* Another C string constant used much like `LINK_SPEC'.  The
    difference between the two is that `LIB_SPEC' is used at the end
    of the command given to the linker.
@@ -2377,7 +2377,7 @@ extern int avr_case_values_threshold;
 /* No libstdc++ for now.  Empty string doesn't work.  */
 
 #define LIBGCC_SPEC \
-  "%{!mmcu=at90s1*:%{!mmcu=attiny1*:%{!mmcu=attiny28: -lgcc }}}"
+  "%{!mmcu=at90s1*:%{!mmcu=attiny11:%{!mmcu=attiny12:%{!mmcu=attiny15:%{!mmcu=attiny28: -lgcc }}}}}"
 /* Another C string constant that tells the GCC driver program how
    and when to place a reference to `libgcc.a' into the linker
    command line.  This constant is placed both before and after the
@@ -2421,23 +2421,60 @@ extern int avr_case_values_threshold;
 %{mmcu=at90c8534:crtc8534.o%s} \
 %{mmcu=at90s8535:crts8535.o%s} \
 %{mmcu=at86rf401:crt86401.o%s} \
+%{mmcu=attiny13:crttn13.o%s} \
+%{mmcu=attiny2313:crttn2313.o%s} \
+%{mmcu=attiny24:crttn24.o%s} \
+%{mmcu=attiny44:crttn44.o%s} \
+%{mmcu=attiny85:crttn84.o%s} \
+%{mmcu=attiny25:crttn25.o%s} \
+%{mmcu=attiny45:crttn45.o%s} \
+%{mmcu=attiny85:crttn85.o%s} \
+%{mmcu=attiny261:crttn261.o%s} \
+%{mmcu=attiny461:crttn461.o%s} \
+%{mmcu=attiny861:crttn861.o%s} \
 %{mmcu=atmega103|mmcu=avr3:crtm103.o%s} \
 %{mmcu=atmega603:crtm603.o%s} \
 %{mmcu=at43usb320:crt43320.o%s} \
 %{mmcu=at43usb355:crt43355.o%s} \
 %{mmcu=at76c711:crt76711.o%s} \
 %{mmcu=atmega8|mmcu=avr4:crtm8.o%s} \
+%{mmcu=atmega48:crtm48.o%s} \
+%{mmcu=atmega88:crtm88.o%s} \
 %{mmcu=atmega8515:crtm8515.o%s} \
 %{mmcu=atmega8535:crtm8535.o%s} \
 %{mmcu=atmega16:crtm16.o%s} \
 %{mmcu=atmega161|mmcu=avr5:crtm161.o%s} \
 %{mmcu=atmega162:crtm162.o%s} \
 %{mmcu=atmega163:crtm163.o%s} \
+%{mmcu=atmega164:crtm164.o%s} \
+%{mmcu=atmega165:crtm165.o%s} \
+%{mmcu=atmega168:crtm168.o%s} \
 %{mmcu=atmega169:crtm169.o%s} \
 %{mmcu=atmega32:crtm32.o%s} \
 %{mmcu=atmega323:crtm323.o%s} \
+%{mmcu=atmega324:crtm324.o%s} \
+%{mmcu=atmega325:crtm325.o%s} \
+%{mmcu=atmega3250:crtm3250.o%s} \
+%{mmcu=atmega329:crtm329.o%s} \
+%{mmcu=atmega3290:crtm3290.o%s} \
+%{mmcu=atmega406:crtm406.o%s} \
 %{mmcu=atmega64:crtm64.o%s} \
+%{mmcu=atmega640:crtm640.o%s} \
+%{mmcu=atmega644:crtm644.o%s} \
+%{mmcu=atmega645:crtm645.o%s} \
+%{mmcu=atmega6450:crtm6450.o%s} \
+%{mmcu=atmega649:crtm649.o%s} \
+%{mmcu=atmega6490:crtm6490.o%s} \
 %{mmcu=atmega128:crtm128.o%s} \
+%{mmcu=atmega1280:crtm1280.o%s} \
+%{mmcu=atmega1281:crtm1281.o%s} \
+%{mmcu=at90usb646:crtusb646.o%s} \
+%{mmcu=at90usb647:crtusb647.o%s} \
+%{mmcu=at90usb1286:crtusb1286.o%s} \
+%{mmcu=at90usb1287:crtusb1287.o%s} \
+%{mmcu=at90can32:crtcan32.o%s} \
+%{mmcu=at90can64:crtcan64.o%s} \
+%{mmcu=at90can128:crtcan128.o%s} \
 %{mmcu=at94k:crtat94k.o%s}"
 
 #define EXTRA_SPECS {"crt_binutils", CRT_BINUTILS_SPECS},
diff --git a/gcc/config/avr/t-avr b/gcc/config/avr/t-avr
index bb2733e..9d308cf 100644
--- a/gcc/config/avr/t-avr
+++ b/gcc/config/avr/t-avr
@@ -46,13 +46,25 @@ MULTILIB_MATCHES = \
 	mmcu?avr3=mmcu?at43usb320 mmcu?avr3=mmcu?at43usb355 \
 	mmcu?avr3=mmcu?at76c711 \
 	mmcu?avr4=mmcu?atmega8515 mmcu?avr4=mmcu?atmega8535 \
-	mmcu?avr4=mmcu?atmega8 \
+	mmcu?avr4=mmcu?atmega8 mmcu?avr4=mmcu?atmega48 \
+	mmcu?avr4=mmcu?atmega88 \
 	mmcu?avr5=mmcu?atmega161 mmcu?avr5=mmcu?atmega162 \
-	mmcu?avr5=mmcu?atmega163 mmcu?avr5=mmcu?atmega169 \
-	mmcu?avr5=mmcu?atmega16 \
+	mmcu?avr5=mmcu?atmega163 mmcu?avr5=mmcu?atmega164 \
+	mmcu?avr=mmcu?atmega165 mmcu?avr5=mmcu?atmega168 \
+	mmcu?avr5=mmcu?atmega169 mmcu?avr5=mmcu?atmega16 \
 	mmcu?avr5=mmcu?atmega323 mmcu?avr5=mmcu?atmega32 \
+	mmcu?avr=mmcu?atmega329 mmcu?avr5=mmcu?atmega3290 \
+	mmcu?avr5=mmcu?atmega324 mmcu?avr5=mmcu?atmega644 \
+	mmcu?avr5=mmcu?atmega406 mmcu?avr5=mmcu?atmega640 \
+	mmcu?avr5=mmcu?atmega649 mmcu?avr5=mmcu?atmega6490 \
 	mmcu?avr5=mmcu?atmega64  mmcu?avr5=mmcu?atmega128 \
-	mmcu?avr5=mmcu?at94k
+	mmcu?avr5=mmcu?atmega1280 mmcu?avr5=mmcu?atmega1281 \
+	mmcu?avr5=mmcu?atmega325 mmcu?avr5=mmcu?atmega3250 \
+	mmcu?avr5=mmcu?atmega645 mmcu?avr5=mmcu?atmega6450 \
+	mmcu?avr5=mmcu?at90can32 mmcu?avr5=mmcu?at90can64 \
+	mmcu?avr5=mmcu?at90usb646 mmcu?avr5=mmcu?at90usb647 \
+	mmcu?avr5=mmcu?at90usb1286 mmcu?avr5=mmcu?at90usb1287 \
+	mmcu?avr5=mmcu?at94k mmcu?avr5=mmcu?at90can128
 
 MULTILIB_EXCEPTIONS =
 
diff --git a/gcc/config/freebsd-spec.h b/gcc/config/freebsd-spec.h
index 8acf0ca..2012815 100644
--- a/gcc/config/freebsd-spec.h
+++ b/gcc/config/freebsd-spec.h
@@ -154,8 +154,4 @@ is built with the --enable-threads configure-time option.}		\
 #endif
 #endif
 
-#if FBSD_MAJOR < 6
-#define FBSD_DYNAMIC_LINKER "/usr/libexec/ld-elf.so.1"
-#else
 #define FBSD_DYNAMIC_LINKER "/libexec/ld-elf.so.1"
-#endif
diff --git a/gcc/config/i386/i386.c b/gcc/config/i386/i386.c
index e6f71b4..a5339cf 100644
--- a/gcc/config/i386/i386.c
+++ b/gcc/config/i386/i386.c
@@ -2026,11 +2026,11 @@ classify_argument (enum machine_mode mode, tree type,
 	    {
 	      tree bases = TYPE_BINFO_BASETYPES (type);
 	      int n_bases = TREE_VEC_LENGTH (bases);
-	      int i;
+	      int basenum;
 
-	      for (i = 0; i < n_bases; ++i)
+	      for (basenum = 0; basenum < n_bases; ++basenum)
 		{
-		   tree binfo = TREE_VEC_ELT (bases, i);
+		   tree binfo = TREE_VEC_ELT (bases, basenum);
 		   int num;
 		   int offset = tree_low_cst (BINFO_OFFSET (binfo), 0) * 8;
 		   tree type = BINFO_TYPE (binfo);
@@ -2114,11 +2114,11 @@ classify_argument (enum machine_mode mode, tree type,
 	    {
 	      tree bases = TYPE_BINFO_BASETYPES (type);
 	      int n_bases = TREE_VEC_LENGTH (bases);
-	      int i;
+	      int basenum;
 
-	      for (i = 0; i < n_bases; ++i)
+	      for (basenum = 0; basenum < n_bases; ++basenum)
 		{
-		   tree binfo = TREE_VEC_ELT (bases, i);
+		   tree binfo = TREE_VEC_ELT (bases, basenum);
 		   int num;
 		   int offset = tree_low_cst (BINFO_OFFSET (binfo), 0) * 8;
 		   tree type = BINFO_TYPE (binfo);
@@ -3820,6 +3820,21 @@ const_0_to_255_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)
   return (GET_CODE (op) == CONST_INT && INTVAL (op) >= 0 && INTVAL (op) < 256);
 }
 
+/* Match exactly one bit in 4-bit mask. */
+int
+const_pow2_1_to_8_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)
+{
+  unsigned int log = exact_log2 (INTVAL (op));
+  return log <= 3;
+}
+
+/* Match exactly one bit in 8-bit mask. */
+int
+const_pow2_1_to_128_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)
+{
+  unsigned int log = exact_log2 (INTVAL (op));
+  return log <= 7;
+}
 
 /* True if this is a constant appropriate for an increment or decrement.  */
 
@@ -14199,7 +14214,7 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,
       if (! (*insn_data[icode].operand[3].predicate) (op2, mode2))
 	{
 	  error ("selector must be an integer constant in the range 0..%i",
-		  fcode == IX86_BUILTIN_PINSRW ? 15:255);
+		  fcode == IX86_BUILTIN_PINSRW ? 3:7);
 	  return const0_rtx;
 	}
       if (target == 0
diff --git a/gcc/config/i386/i386.h b/gcc/config/i386/i386.h
index 8a912d5..35a881a 100644
--- a/gcc/config/i386/i386.h
+++ b/gcc/config/i386/i386.h
@@ -2944,6 +2944,8 @@ do {						\
   {"const_0_to_7_operand", {CONST_INT}},				\
   {"const_0_to_15_operand", {CONST_INT}},				\
   {"const_0_to_255_operand", {CONST_INT}},				\
+  {"const_pow2_1_to_8_operand", {CONST_INT}}, \
+  {"const_pow2_1_to_128_operand", {CONST_INT}}, \
   {"incdec_operand", {CONST_INT}},					\
   {"mmx_reg_operand", {REG}},						\
   {"reg_no_sp_operand", {SUBREG, REG}},					\
diff --git a/gcc/config/i386/i386.md b/gcc/config/i386/i386.md
index 0fbe00b..ee93326 100644
--- a/gcc/config/i386/i386.md
+++ b/gcc/config/i386/i386.md
@@ -20440,14 +20440,31 @@
 
 ;; MMX insert/extract/shuffle
 
-(define_insn "mmx_pinsrw"
+(define_expand "mmx_pinsrw"
+  [(set (match_operand:V4HI 0 "register_operand" "")
+        (vec_merge:V4HI
+	  (match_operand:V4HI 1 "register_operand" "")
+          (vec_duplicate:V4HI
+            (match_operand:SI 2 "nonimmediate_operand" ""))
+          (match_operand:SI 3 "const_0_to_3_operand" "")))]
+  "TARGET_SSE || TARGET_3DNOW_A"
+{
+  operands[2] = gen_lowpart (HImode, operands[2]);
+  operands[3] = GEN_INT (1 << INTVAL (operands[3]));
+})
+
+(define_insn "*mmx_pinsrw"
   [(set (match_operand:V4HI 0 "register_operand" "=y")
-        (vec_merge:V4HI (match_operand:V4HI 1 "register_operand" "0")
-			(vec_duplicate:V4HI
-			 (truncate:HI (match_operand:SI 2 "nonimmediate_operand" "rm")))
-			(match_operand:SI 3 "const_0_to_15_operand" "N")))]
+        (vec_merge:V4HI
+	  (match_operand:V4HI 1 "register_operand" "0")
+          (vec_duplicate:V4HI
+            (match_operand:HI 2 "nonimmediate_operand" "rm"))
+          (match_operand:SI 3 "const_pow2_1_to_8_operand" "N")))]
   "TARGET_SSE || TARGET_3DNOW_A"
-  "pinsrw\t{%3, %2, %0|%0, %2, %3}"
+{
+  operands[3] = GEN_INT (exact_log2 (INTVAL (operands[3])));
+  return "pinsrw\t{%3, %k2, %0|%0, %k2, %3}";
+}
   [(set_attr "type" "mmxcvt")
    (set_attr "mode" "DI")])
 
@@ -22135,15 +22152,31 @@
 
 ;; MMX insert/extract/shuffle
 
-(define_insn "sse2_pinsrw"
+(define_expand "sse2_pinsrw"
+  [(set (match_operand:V8HI 0 "register_operand" "")
+        (vec_merge:V8HI
+	  (match_operand:V8HI 1 "register_operand" "")
+          (vec_duplicate:V8HI
+            (match_operand:SI 2 "nonimmediate_operand" ""))
+          (match_operand:SI 3 "const_0_to_7_operand" "")))]
+  "TARGET_SSE2"
+{
+  operands[2] = gen_lowpart (HImode, operands[2]);
+  operands[3] = GEN_INT (1 << INTVAL (operands[3]));
+})
+
+(define_insn "*sse2_pinsrw"
   [(set (match_operand:V8HI 0 "register_operand" "=x")
-        (vec_merge:V8HI (match_operand:V8HI 1 "register_operand" "0")
-			(vec_duplicate:V8HI
-			 (truncate:HI
-			   (match_operand:SI 2 "nonimmediate_operand" "rm")))
-			(match_operand:SI 3 "const_0_to_255_operand" "N")))]
+        (vec_merge:V8HI
+	  (match_operand:V8HI 1 "register_operand" "0")
+          (vec_duplicate:V8HI
+            (match_operand:HI 2 "nonimmediate_operand" "rm"))
+          (match_operand:SI 3 "const_pow2_1_to_128_operand" "N")))]
   "TARGET_SSE2"
-  "pinsrw\t{%3, %2, %0|%0, %2, %3}"
+{
+  operands[3] = GEN_INT (exact_log2 (INTVAL (operands[3])));
+  return "pinsrw\t{%3, %k2, %0|%0, %k2, %3}";
+}
   [(set_attr "type" "ssecvt")
    (set_attr "mode" "TI")])
 
diff --git a/gcc/config/i386/linux.h b/gcc/config/i386/linux.h
index e7d19ec..d5bdb1e 100644
--- a/gcc/config/i386/linux.h
+++ b/gcc/config/i386/linux.h
@@ -208,6 +208,7 @@ Boston, MA 02111-1307, USA.  */
 /* Do code reading to identify a signal frame, and set the frame
    state data appropriately.  See unwind-dw2.c for the structs.  */
 
+#ifndef inhibit_libc
 #ifdef IN_LIBGCC2
 /* There's no sys/ucontext.h for some (all?) libc1, so no
    signal-turned-exceptions for them.  There's also no configure-run for
@@ -235,10 +236,10 @@ Boston, MA 02111-1307, USA.  */
       {									\
 	struct rt_sigframe {						\
 	  int sig;							\
-	  struct siginfo *pinfo;					\
+	  siginfo_t *pinfo;						\
 	  void *puc;							\
-	  struct siginfo info;						\
-	  struct ucontext uc;						\
+	  siginfo_t info;						\
+	  ucontext_t uc;						\
 	} *rt_ = (CONTEXT)->cfa;					\
 	sc_ = (struct sigcontext *) &rt_->uc.uc_mcontext;		\
       }									\
@@ -272,3 +273,4 @@ Boston, MA 02111-1307, USA.  */
   } while (0)
 #endif /* not USE_GNULIBC_1 */
 #endif /* IN_LIBGCC2 */
+#endif /* inhibit_libc */
diff --git a/gcc/config/i386/linux64.h b/gcc/config/i386/linux64.h
index 98536c1..59d9ffa 100644
--- a/gcc/config/i386/linux64.h
+++ b/gcc/config/i386/linux64.h
@@ -90,7 +90,7 @@ Boston, MA 02111-1307, USA.  */
     if (*(unsigned char *)(pc_+0) == 0x48				\
 	&& *(unsigned long *)(pc_+1) == 0x050f0000000fc0c7)		\
       {									\
-	struct ucontext *uc_ = (CONTEXT)->cfa;				\
+	ucontext_t *uc_ = (CONTEXT)->cfa;				\
 	sc_ = (struct sigcontext *) &uc_->uc_mcontext;			\
       }									\
     else								\
@@ -157,10 +157,10 @@ Boston, MA 02111-1307, USA.  */
       {									\
 	struct rt_sigframe {						\
 	  int sig;							\
-	  struct siginfo *pinfo;					\
+	  siginfo_t *pinfo;						\
 	  void *puc;							\
-	  struct siginfo info;						\
-	  struct ucontext uc;						\
+	  siginfo_t info;						\
+	  ucontext_t uc;						\
 	} *rt_ = (CONTEXT)->cfa;					\
 	sc_ = (struct sigcontext *) &rt_->uc.uc_mcontext;		\
       }									\
diff --git a/gcc/config/i386/openbsdelf.h b/gcc/config/i386/openbsdelf.h
new file mode 100644
index 0000000..25d6a3e
--- /dev/null
+++ b/gcc/config/i386/openbsdelf.h
@@ -0,0 +1,135 @@
+
+/* Configuration for an OpenBSD i386 target.
+   
+   Copyright (C) 1999 Free Software Foundation, Inc.
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* This gets defined in tm.h->linux.h->svr4.h, and keeps us from using
+   libraries compiled with the native cc, so undef it. */
+#undef NO_DOLLAR_IN_LABEL
+
+/* Override the default comment-starter of "/".  */
+#undef ASM_COMMENT_START
+#define ASM_COMMENT_START "#"
+
+
+/* This goes away when the math-emulator is fixed */
+#undef TARGET_DEFAULT
+#define TARGET_DEFAULT \
+  (MASK_80387 | MASK_IEEE_FP | MASK_FLOAT_RETURNS | MASK_NO_FANCY_MATH_387)
+
+/* Run-time target specifications */
+
+#define TARGET_OS_CPP_BUILTINS()		\
+  do						\
+    {						\
+    	OPENBSD_OS_CPP_BUILTINS_ELF();		\
+    }						\
+  while (0)
+
+/* As an elf system, we need crtbegin/crtend stuff.  */
+#undef STARTFILE_SPEC
+#define STARTFILE_SPEC "\
+	%{!shared: %{pg:gcrt0%O%s} %{!pg:%{p:gcrt0%O%s} %{!p:crt0%O%s}} \
+	crtbegin%O%s} %{shared:crtbeginS%O%s}"
+#undef ENDFILE_SPEC
+#define ENDFILE_SPEC "%{!shared:crtend%O%s} %{shared:crtendS%O%s}"
+
+/* Layout of source language data types.  */
+
+/* This must agree with <machine/ansi.h> */
+#undef SIZE_TYPE
+#define SIZE_TYPE "unsigned int"
+
+#undef PTRDIFF_TYPE
+#define PTRDIFF_TYPE "int"
+
+#undef WCHAR_TYPE
+#define WCHAR_TYPE "int"
+
+#undef WCHAR_TYPE_SIZE
+#define WCHAR_TYPE_SIZE BITS_PER_WORD
+
+/* Assembler format: overall framework.  */
+
+#undef ASM_APP_ON
+#define ASM_APP_ON "#APP\n"
+
+#undef ASM_APP_OFF
+#define ASM_APP_OFF "#NO_APP\n"
+
+#undef SET_ASM_OP
+#define SET_ASM_OP	"\t.set\t"
+
+/* The following macros were originally stolen from i386v4.h.
+   These have to be defined to get PIC code correct.  */
+
+/* Assembler format: dispatch tables.  */
+
+/* Assembler format: sections.  */
+
+/* Stack & calling: aggregate returns.  */
+
+/* Don't default to pcc-struct-return, because gcc is the only compiler, and
+   we want to retain compatibility with older gcc versions.  */
+#define DEFAULT_PCC_STRUCT_RETURN 0
+
+/* Assembler format: alignment output.  */
+
+#ifdef HAVE_GAS_MAX_SKIP_P2ALIGN
+#define ASM_OUTPUT_MAX_SKIP_ALIGN(FILE,LOG,MAX_SKIP) \
+  if ((LOG) != 0) {\
+    if ((MAX_SKIP) == 0) fprintf ((FILE), "\t.p2align %d\n", (LOG)); \
+    else fprintf ((FILE), "\t.p2align %d,,%d\n", (LOG), (MAX_SKIP)); \
+  }
+#endif
+
+/* Stack & calling: profiling.  */
+
+/* OpenBSD's profiler recovers all information from the stack pointer.
+   The icky part is not here, but in machine/profile.h.  */
+#undef FUNCTION_PROFILER
+#define FUNCTION_PROFILER(FILE, LABELNO)  \
+  fputs (flag_pic ? "\tcall __mcount@PLT\n": "\tcall __mcount\n", FILE);
+
+/* Assembler format: exception region output.  */
+
+/* our configuration still doesn't handle dwarf2 correctly */
+#define DWARF2_UNWIND_INFO 0
+
+/* Assembler format: alignment output.  */
+
+/* Note that we pick up ASM_OUTPUT_MAX_SKIP_ALIGN from i386/gas.h */
+
+/* Note that we pick up ASM_OUTPUT_MI_THUNK from unix.h.  */
+
+#undef LINK_SPEC
+#define LINK_SPEC \
+  "%{!shared:%{!nostdlib:%{!r*:%{!e*:-e __start}}}} \
+   %{shared:-shared} %{R*} \
+   %{static:-Bstatic} \
+   %{!static:-Bdynamic} \
+   %{assert*} \
+   %{!dynamic-linker:-dynamic-linker /usr/libexec/ld.so}"
+
+#define OBSD_HAS_CORRECT_SPECS
+
+/* pick up defines for mprotect (used in TRANSFER_FROM_TRANPOLINE) */
+#include <sys/types.h>
+#include <sys/mman.h>
diff --git a/gcc/config/ia64/change-symver.c b/gcc/config/ia64/change-symver.c
new file mode 100644
index 0000000..fc19595
--- /dev/null
+++ b/gcc/config/ia64/change-symver.c
@@ -0,0 +1,211 @@
+#define _GNU_SOURCE 1
+#define _FILE_OFFSET_BITS 64
+#include <endian.h>
+#include <errno.h>
+#include <error.h>
+#include <fcntl.h>
+#include <fnmatch.h>
+#include <gelf.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+int
+compute_veridx (const char *name, Elf *elf, Elf_Data *verd, GElf_Shdr *verd_shdr)
+{
+  if (strcmp (name, "_GLOBAL_") == 0)
+    return 1;
+
+  int cnt;
+  size_t offset = 0;
+  for (cnt = verd_shdr->sh_info; --cnt >= 0; )
+    {
+      GElf_Verdef defmem;
+      GElf_Verdef *def;
+      GElf_Verdaux auxmem;
+      GElf_Verdaux *aux;
+      unsigned int auxoffset;
+
+      /* Get the data at the next offset.  */
+      def = gelf_getverdef (verd, offset, &defmem);
+      if (def == NULL)
+	break;
+
+      auxoffset = offset + def->vd_aux;
+      aux = gelf_getverdaux (verd, auxoffset, &auxmem);
+      if (aux == NULL)
+	break;
+
+      if (strcmp (name, elf_strptr (elf, verd_shdr->sh_link,
+		  aux->vda_name)) == 0)
+	return def->vd_ndx;
+
+      /* Find the next offset.  */
+      offset += def->vd_next;
+    }
+
+  return -1;
+}
+
+int
+main (int argc, char **argv)
+{
+  if (argc < 4)
+    error (1, 0, "Usage: change_symver library from_symver to_symver symbol...\nExample: change_symver libfoo.so FOO_1.0 *global* bar baz");
+
+  const char *fname = argv[1];
+
+  /* Open the file.  */
+  int fd;
+  fd = open (fname, O_RDWR);
+  if (fd == -1)
+    error (1, errno, fname);
+
+  elf_version (EV_CURRENT);
+
+  /* Now get the ELF descriptor.  */
+  Elf *elf = elf_begin (fd, ELF_C_READ_MMAP, NULL);
+  if (elf == NULL || elf_kind (elf) != ELF_K_ELF)
+    error (1, 0, "Couldn't open %s: %s", fname, elf_errmsg (-1));
+
+  size_t shstrndx;
+  /* Get the section header string table index.  */
+  if (elf_getshstrndx (elf, &shstrndx) < 0)
+    error (1, 0, "cannot get shstrndx from %s", fname);
+
+  GElf_Ehdr ehdr_mem;
+  GElf_Ehdr *ehdr;
+
+  /* We need the ELF header in a few places.  */
+  ehdr = gelf_getehdr (elf, &ehdr_mem);
+  if (ehdr == NULL)
+    error (1, 0, "couldn't get ELF headers %s: %s", fname, elf_errmsg (-1));
+
+  Elf_Scn *scn = NULL;
+  GElf_Shdr shdr_mem, verd_shdr, ver_shdr, dynsym_shdr;
+  Elf_Data *ver = NULL, *verd = NULL, *dynsym = NULL;
+
+  while ((scn = elf_nextscn (elf, scn)) != NULL)
+    {
+      GElf_Shdr *shdr = gelf_getshdr (scn, &shdr_mem);
+
+      if (shdr == NULL)
+	error (1, 0, "couldn't get shdr from %s", fname);
+
+      if ((shdr->sh_flags & SHF_ALLOC) != 0)
+	{
+	  const char *name = elf_strptr (elf, shstrndx, shdr->sh_name);
+	  Elf_Data **p;
+
+	  if (strcmp (name, ".gnu.version") == 0)
+	    {
+	      p = &ver;
+	      ver_shdr = *shdr;
+	    }
+	  else if (strcmp (name, ".gnu.version_d") == 0)
+	    {
+	      p = &verd;
+	      verd_shdr = *shdr;
+	    }
+	  else if (strcmp (name, ".dynsym") == 0)
+	    {
+	      p = &dynsym;
+	      dynsym_shdr = *shdr;
+	    }
+	  else
+	    continue;
+
+	  if (*p != NULL)
+	    error (1, 0, "Two %s sections in %s", name, fname);
+	  *p = elf_getdata (scn, NULL);
+	  if (*p == NULL || elf_getdata (scn, *p) != NULL)
+	    error (1, 0, "No data or non-contiguous data in %s section in %s",
+		   name, fname);
+	}
+    }
+
+  if (ver == NULL || verd == NULL || dynsym == NULL)
+    error (1, 0, "Couldn't find one of the needed sections in %s", fname);
+
+  int from_idx = compute_veridx (argv[2], elf, verd, &verd_shdr);
+  if (from_idx == -1)
+    error (1, 0, "Could not find symbol version %s in %s", argv[2], fname);
+
+  int to_idx = compute_veridx (argv[3], elf, verd, &verd_shdr);
+  if (to_idx == -1)
+    error (1, 0, "Could not find symbol version %s in %s", argv[3], fname);
+
+  if (dynsym_shdr.sh_entsize != gelf_fsize (elf, ELF_T_SYM, 1, ehdr->e_version)
+      || dynsym_shdr.sh_size % dynsym_shdr.sh_entsize
+      || ver_shdr.sh_entsize != 2
+      || (ver_shdr.sh_size & 1)
+      || dynsym_shdr.sh_size / dynsym_shdr.sh_entsize != ver_shdr.sh_size / 2)
+    error (1, 0, "Unexpected sh_size or sh_entsize in %s", fname);
+
+  size_t nentries = ver_shdr.sh_size / 2;
+  size_t cnt;
+  GElf_Versym array[nentries];
+  for (cnt = 0; cnt < nentries; ++cnt)
+    {
+      GElf_Versym vsymmem;
+      GElf_Versym *vsym;
+
+      vsym = gelf_getversym (ver, cnt, &vsymmem);
+      if (vsym == NULL)
+	error (1, 0, "gelt_getversym failed in %s: %s", fname, elf_errmsg (-1));
+
+      array[cnt] = *vsym;
+      if (*vsym != from_idx)
+	continue;
+
+      GElf_Sym sym_mem;
+      GElf_Sym *sym;
+      sym = gelf_getsym (dynsym, cnt, &sym_mem);
+      if (sym == NULL)
+	error (1, 0, "gelt_getsym failed in %s: %s", fname, elf_errmsg (-1));
+
+      const char *name = elf_strptr (elf, dynsym_shdr.sh_link, sym->st_name);
+
+      int argn;
+      for (argn = 4; argn < argc; ++argn)
+	if (fnmatch (argv[argn], name, 0) == 0)
+	  {
+	    array[cnt] = to_idx;
+	    break;
+	  }
+    }
+
+  if (sizeof (array[0]) != 2)
+    abort ();
+
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+  if (ehdr->e_ident[EI_DATA] == ELFDATA2LSB)
+    ;
+  else if (ehdr->e_ident[EI_DATA] == ELFDATA2MSB)
+#elif __BYTE_ORDER == __BIG_ENDIAN
+  if (ehdr->e_ident[EI_DATA] == ELFDATA2MSB)
+    ;
+  else if (ehdr->e_ident[EI_DATA] == ELFDATA2LSB)
+#else
+# error Unsupported endianity
+#endif
+    {
+      for (cnt = 0; cnt < nentries; ++cnt)
+	array[cnt] = ((array[cnt] & 0xff) << 8) | ((array[cnt] & 0xff00) >> 8);
+    }
+  else
+    error (1, 0, "Unknown EI_DATA %d in %s", ehdr->e_ident[EI_DATA], fname);
+
+  if (elf_end (elf) != 0)
+    error (1, 0, "couldn't close %s: %s", fname, elf_errmsg (-1));
+
+  if (lseek (fd, ver_shdr.sh_offset, SEEK_SET) != (off_t) ver_shdr.sh_offset)
+    error (1, 0, "failed to seek to %zd in %s", (size_t) ver_shdr.sh_offset,
+	   fname);
+
+  if (write (fd, array, 2 * nentries) != (ssize_t) (2 * nentries))
+    error (1, 0, "failed to write .gnu.version section into %s", fname);
+
+  close (fd);
+  return 0;
+}
diff --git a/gcc/config/ia64/crtbegin.asm b/gcc/config/ia64/crtbegin.asm
index 494def7..1878b19 100644
--- a/gcc/config/ia64/crtbegin.asm
+++ b/gcc/config/ia64/crtbegin.asm
@@ -246,3 +246,7 @@ __do_jv_register_classes:
 .weak __cxa_finalize
 #endif
 .weak _Jv_RegisterClasses
+
+#ifdef __linux__
+.section .note.GNU-stack; .previous
+#endif
diff --git a/gcc/config/ia64/crtend.asm b/gcc/config/ia64/crtend.asm
index 8984d88..b6cdd7b 100644
--- a/gcc/config/ia64/crtend.asm
+++ b/gcc/config/ia64/crtend.asm
@@ -113,3 +113,7 @@ __do_global_ctors_aux:
 
 	br.ret.sptk.many rp
 	.endp __do_global_ctors_aux
+
+#ifdef __linux__
+.section .note.GNU-stack; .previous
+#endif
diff --git a/gcc/config/ia64/crti.asm b/gcc/config/ia64/crti.asm
index 4b48e3d..b0f1ca7 100644
--- a/gcc/config/ia64/crti.asm
+++ b/gcc/config/ia64/crti.asm
@@ -64,3 +64,7 @@ _fini:
 	.body
 
 # end of crti.asm
+
+#ifdef __linux__
+.section .note.GNU-stack; .previous
+#endif
diff --git a/gcc/config/ia64/crtn.asm b/gcc/config/ia64/crtn.asm
index 48a9a03..9edda91 100644
--- a/gcc/config/ia64/crtn.asm
+++ b/gcc/config/ia64/crtn.asm
@@ -54,3 +54,7 @@
 	br.ret.sptk.many b0
 
 # end of crtn.asm
+
+#ifdef __linux__
+.section .note.GNU-stack; .previous
+#endif
diff --git a/gcc/config/ia64/ia64.h b/gcc/config/ia64/ia64.h
index 9f7dd05..886ff72 100644
--- a/gcc/config/ia64/ia64.h
+++ b/gcc/config/ia64/ia64.h
@@ -173,6 +173,8 @@ extern int ia64_tls_size;
 
 #define TARGET_SWITCHES							\
 {									\
+  { "64",		0,						\
+      N_("Generate 64-bit code") },					\
   { "big-endian",	MASK_BIG_ENDIAN,				\
       N_("Generate big endian code") },					\
   { "little-endian",	-MASK_BIG_ENDIAN,				\
diff --git a/gcc/config/ia64/lib1funcs.asm b/gcc/config/ia64/lib1funcs.asm
index e3d348b..fdd66b9 100644
--- a/gcc/config/ia64/lib1funcs.asm
+++ b/gcc/config/ia64/lib1funcs.asm
@@ -741,3 +741,7 @@ __floattitf:
 	.endp __floattitf
 
 #endif
+
+#ifdef __linux__
+.section .note.GNU-stack; .previous
+#endif
diff --git a/gcc/config/ia64/libgcc-ia64-no-libunwind.ver b/gcc/config/ia64/libgcc-ia64-no-libunwind.ver
new file mode 100644
index 0000000..750b08f
--- /dev/null
+++ b/gcc/config/ia64/libgcc-ia64-no-libunwind.ver
@@ -0,0 +1,17 @@
+GCC_3.4.2 {
+  _Unwind_GetGR
+  _Unwind_RaiseException
+  _Unwind_GetRegionStart
+  _Unwind_SetIP
+  _Unwind_GetIP
+  _Unwind_GetLanguageSpecificData
+  _Unwind_Resume
+  _Unwind_DeleteException
+  _Unwind_SetGR
+  _Unwind_ForcedUnwind
+  _Unwind_Backtrace
+  _Unwind_FindEnclosingFunction
+  _Unwind_GetCFA
+  _Unwind_Resume_or_Rethrow
+  _Unwind_GetBSP
+}
diff --git a/gcc/config/ia64/linux.h b/gcc/config/ia64/linux.h
index 5c73b0c..0e6190d 100644
--- a/gcc/config/ia64/linux.h
+++ b/gcc/config/ia64/linux.h
@@ -5,6 +5,8 @@
 
 #define TARGET_VERSION fprintf (stderr, " (IA-64) Linux");
 
+#define TARGET_ASM_FILE_END file_end_indicate_exec_stack
+
 /* This is for -profile to use -lc_p instead of -lc.  */
 #undef CC1_SPEC
 #define CC1_SPEC "%{profile:-p} %{G*}"
@@ -55,6 +57,8 @@ do {						\
 #undef LINK_EH_SPEC
 #define LINK_EH_SPEC ""
 
+#define MULTILIB_DEFAULTS { "m64" }
+
 /* Do code reading to identify a signal frame, and set the frame
    state data appropriately.  See unwind-dw2.c for the structs.  */
 
@@ -77,7 +81,7 @@ do {						\
       struct sigframe {							\
 	char scratch[16];						\
 	unsigned long sig_number;					\
-	struct siginfo *info;						\
+	siginfo_t *info;						\
 	struct sigcontext *sc;						\
       } *frame_ = (struct sigframe *)(CONTEXT)->psp;			\
       struct sigcontext *sc_ = frame_->sc;				\
@@ -150,7 +154,7 @@ do {						\
       struct sigframe {							\
 	char scratch[16];						\
 	unsigned long sig_number;					\
-	struct siginfo *info;						\
+	siginfo_t *info;						\
 	struct sigcontext *sc;						\
       } *frame_ = (struct sigframe *)(CONTEXT)->psp;			\
       struct sigcontext *sc_ = frame_->sc;				\
diff --git a/gcc/config/ia64/mkmap-symver-multi.awk b/gcc/config/ia64/mkmap-symver-multi.awk
new file mode 100644
index 0000000..5ee18e0
--- /dev/null
+++ b/gcc/config/ia64/mkmap-symver-multi.awk
@@ -0,0 +1,133 @@
+# Generate an ELF symbol version map a-la Solaris and GNU ld.
+#	Contributed by Richard Henderson <rth@cygnus.com>
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify it under
+# the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2, or (at your option) any later
+# version.
+#
+# GCC is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+# License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING.  If not, write to the Free
+# Software Foundation, 59 Temple Place - Suite 330, Boston MA
+# 02111-1307, USA.
+
+BEGIN {
+  state = "nm";
+  sawsymbol = 0;
+}
+
+# Remove comment and blank lines.
+/^ *#/ || /^ *$/ {
+  next;
+}
+
+# We begin with nm input.  Collect the set of symbols that are present
+# so that we can not emit them into the final version script -- Solaris
+# complains at us if we do.
+
+state == "nm" && /^%%/ {
+  state = "ver";
+  next;
+}
+
+state == "nm" && ($1 == "U" || $2 == "U") {
+  next;
+}
+
+state == "nm" && NF == 3 {
+  if ($3 ~ /^[^@]*@GCC_[0-9.]*$/) {
+    def[$3] = 1
+    tl=$3
+    sub(/^.*@/,"",tl)
+    ver[$3] = tl
+  } else {
+    sub(/@@?GCC_[0-9.]*$/,"",$3)
+    def[$3] = 1;
+  }
+  sawsymbol = 1;
+  next;
+}
+
+state == "nm" {
+  next;
+}
+
+# Now we process a simplified variant of the Solaris symbol version
+# script.  We have one symbol per line, no semicolons, simple markers
+# for beginning and ending each section, and %inherit markers for
+# describing version inheritence.  A symbol may appear in more than
+# one symbol version, and the last seen takes effect.
+
+NF == 3 && $1 == "%inherit" {
+  inherit[$2] = $3;
+  next;
+}
+
+NF == 2 && $2 == "{" {
+  libs[$1] = 1;
+  thislib = $1;
+  next;
+}
+
+$1 == "}" {
+  thislib = "";
+  next;
+}
+
+{
+  ver[$1] = thislib;
+  next;
+}
+
+END {
+  if (!sawsymbol)
+    {
+      print "No symbols seen -- broken or mis-installed nm?" | "cat 1>&2";
+      exit 1;
+    }
+  for (l in libs)
+    output(l);
+}
+
+function output(lib) {
+  if (done[lib])
+    return;
+  done[lib] = 1;
+  if (inherit[lib])
+    output(inherit[lib]);
+
+  empty=1
+  for (sym in ver)
+    if ((ver[sym] == lib) && (sym in def))
+      {
+	if (empty)
+	  {
+	    printf("%s {\n", lib);
+	    printf("  global:\n");
+	    empty = 0;
+	  }
+	symp = sym;
+	sub(/@GCC_[0-9.]*$/,"",symp);
+	printf("\t%s;\n", symp);
+	if (dotsyms)
+	  printf("\t.%s;\n", symp);
+      }
+
+  if (empty)
+    {
+      for (l in libs)
+	if (inherit[l] == lib)
+	  inherit[l] = inherit[lib];
+    }
+  else if (inherit[lib])
+    printf("} %s;\n", inherit[lib]);
+  else
+    printf ("\n  local:\n\t*;\n};\n");
+}
diff --git a/gcc/config/ia64/t-glibc b/gcc/config/ia64/t-glibc
index df4fe9c..b224282 100644
--- a/gcc/config/ia64/t-glibc
+++ b/gcc/config/ia64/t-glibc
@@ -1,3 +1,8 @@
 # Use system libunwind library on IA-64 GLIBC based system.
+
+MULTILIB_OPTIONS = m64/m32
+MULTILIB_DIRNAMES = 64 32
+MULTILIB_EXCEPTIONS = m32
+MULTILIB_OSDIRNAMES = ../lib64 ../lib
 LIB2ADDEH = $(srcdir)/unwind-sjlj.c $(srcdir)/unwind-c.c \
   $(srcdir)/unwind-compat.c
diff --git a/gcc/config/ia64/t-glibc-no-libunwind b/gcc/config/ia64/t-glibc-no-libunwind
new file mode 100644
index 0000000..c965877
--- /dev/null
+++ b/gcc/config/ia64/t-glibc-no-libunwind
@@ -0,0 +1,32 @@
+# Don't use system libunwind library on IA-64 GLIBC based system,
+# but make _Unwind_* symbols unversioned, so that created programs
+# are usable even when libgcc_s uses libunwind.
+LIB2ADDEH += $(srcdir)/config/ia64/fde-glibc.c
+LIB2ADDEH += $(srcdir)/config/ia64/unwind-shared-ia64.c
+LIB2ADDEHSTATIC = $(srcdir)/config/ia64/unwind-ia64.c $(srcdir)/unwind-sjlj.c \
+  $(srcdir)/unwind-c.c $(srcdir)/gthr-gnat.c $(srcdir)/config/ia64/fde-glibc.c
+LIB2ADDEHSHARED = $(srcdir)/config/ia64/unwind-shared-ia64.c $(srcdir)/unwind-sjlj.c \
+  $(srcdir)/unwind-c.c $(srcdir)/gthr-gnat.c $(srcdir)/config/ia64/fde-glibc.c
+SHLIB_MAPFILES += $(srcdir)/config/ia64/libgcc-ia64-no-libunwind.ver
+SHLIB_MKMAP = $(srcdir)/config/ia64/mkmap-symver-multi.awk
+
+SHLIB_LINK = $(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) -shared -nodefaultlibs \
+	-Wl,--soname=$(SHLIB_SONAME) \
+	-Wl,--version-script=$(SHLIB_MAP) \
+	-o $(SHLIB_NAME).tmp @multilib_flags@ $(SHLIB_OBJS) -lc && \
+	rm -f $(SHLIB_SOLINK) && \
+	if [ -f $(SHLIB_NAME) ]; then \
+	  mv -f $(SHLIB_NAME) $(SHLIB_NAME).`basename $(STAGE_PREFIX)`; \
+	else true; fi && \
+	gcc -O2 -o $(SHLIB_NAME).tweak $(srcdir)/config/ia64/change-symver.c -lelf && \
+	./$(SHLIB_NAME).tweak $(SHLIB_NAME).tmp GCC_3.4.2 _GLOBAL_ \
+	_Unwind_GetGR _Unwind_RaiseException _Unwind_GetRegionStart _Unwind_SetIP \
+	_Unwind_GetIP _Unwind_GetLanguageSpecificData _Unwind_Resume \
+	_Unwind_DeleteException _Unwind_SetGR _Unwind_ForcedUnwind \
+	_Unwind_Backtrace _Unwind_FindEnclosingFunction _Unwind_GetCFA \
+	_Unwind_Resume_or_Rethrow _Unwind_GetBSP && \
+	rm -f $(SHLIB_NAME).tweak && \
+	mv $(SHLIB_NAME).tmp $(SHLIB_NAME) && \
+	$(LN_S) $(SHLIB_NAME) $(SHLIB_SOLINK)
+
+TARGET_LIBGCC2_CFLAGS += -DUSE_SYMVER_GLOBAL
diff --git a/gcc/config/ia64/unwind-ia64.c b/gcc/config/ia64/unwind-ia64.c
index a49652e..dd7bd61 100644
--- a/gcc/config/ia64/unwind-ia64.c
+++ b/gcc/config/ia64/unwind-ia64.c
@@ -51,6 +51,51 @@
 #define UNW_FLAG_UHANDLER(x)	((x) & 0x0000000200000000L)
 #define UNW_LENGTH(x)		((x) & 0x00000000ffffffffL)
 
+#if defined (USE_SYMVER_GLOBAL) && defined (SHARED)
+extern _Unwind_Reason_Code __symverglobal_Unwind_Backtrace
+  (_Unwind_Trace_Fn, void *);
+extern void __symverglobal_Unwind_DeleteException
+  (struct _Unwind_Exception *);
+extern void * __symverglobal_Unwind_FindEnclosingFunction (void *);
+extern _Unwind_Reason_Code __symverglobal_Unwind_ForcedUnwind
+  (struct _Unwind_Exception *, _Unwind_Stop_Fn, void *);
+extern _Unwind_Word __symverglobal_Unwind_GetCFA
+  (struct _Unwind_Context *);
+extern _Unwind_Word __symverglobal_Unwind_GetBSP
+  (struct _Unwind_Context *);
+extern _Unwind_Word __symverglobal_Unwind_GetGR
+  (struct _Unwind_Context *, int );
+extern _Unwind_Ptr __symverglobal_Unwind_GetIP (struct _Unwind_Context *);
+extern void *__symverglobal_Unwind_GetLanguageSpecificData
+  (struct _Unwind_Context *);
+extern _Unwind_Ptr __symverglobal_Unwind_GetRegionStart
+  (struct _Unwind_Context *);
+extern _Unwind_Reason_Code __symverglobal_Unwind_RaiseException
+  (struct _Unwind_Exception *);
+extern void __symverglobal_Unwind_Resume (struct _Unwind_Exception *);
+extern _Unwind_Reason_Code __symverglobal_Unwind_Resume_or_Rethrow
+   (struct _Unwind_Exception *);
+extern void __symverglobal_Unwind_SetGR
+  (struct _Unwind_Context *, int, _Unwind_Word);
+extern void __symverglobal_Unwind_SetIP
+  (struct _Unwind_Context *, _Unwind_Ptr);
+#define _Unwind_Backtrace __symverglobal_Unwind_Backtrace
+#define _Unwind_DeleteException __symverglobal_Unwind_DeleteException
+#define _Unwind_FindEnclosingFunction __symverglobal_Unwind_FindEnclosingFunction
+#define _Unwind_ForcedUnwind __symverglobal_Unwind_ForcedUnwind
+#define _Unwind_GetBSP __symverglobal_Unwind_GetBSP
+#define _Unwind_GetCFA __symverglobal_Unwind_GetCFA
+#define _Unwind_GetGR __symverglobal_Unwind_GetGR
+#define _Unwind_GetIP __symverglobal_Unwind_GetIP
+#define _Unwind_GetLanguageSpecificData __symverglobal_Unwind_GetLanguageSpecificData
+#define _Unwind_GetRegionStart __symverglobal_Unwind_GetRegionStart
+#define _Unwind_RaiseException __symverglobal_Unwind_RaiseException
+#define _Unwind_Resume __symverglobal_Unwind_Resume
+#define _Unwind_Resume_or_Rethrow __symverglobal_Unwind_Resume_or_Rethrow
+#define _Unwind_SetGR __symverglobal_Unwind_SetGR
+#define _Unwind_SetIP __symverglobal_Unwind_SetIP
+#endif
+
 enum unw_application_register
 {
   UNW_AR_BSP,
@@ -2404,4 +2449,44 @@ alias (_Unwind_SetGR);
 alias (_Unwind_SetIP);
 #endif
 
+#if defined (USE_SYMVER_GLOBAL) && defined (SHARED)
+#undef alias
+#define symverglobal(name, version) \
+__typeof (__symverglobal##name) __symverlocal##name		\
+  __attribute__ ((alias ("__symverglobal" #name)));		\
+__asm__ (".symver __symverglobal" #name"," #name "@@GCC_3.4.2");\
+__asm__ (".symver __symverlocal" #name"," #name "@" #version)
+
+#undef _Unwind_Backtrace
+#undef _Unwind_DeleteException
+#undef _Unwind_FindEnclosingFunction
+#undef _Unwind_ForcedUnwind
+#undef _Unwind_GetBSP
+#undef _Unwind_GetCFA
+#undef _Unwind_GetGR
+#undef _Unwind_GetIP
+#undef _Unwind_GetLanguageSpecificData
+#undef _Unwind_GetRegionStart
+#undef _Unwind_RaiseException
+#undef _Unwind_Resume
+#undef _Unwind_Resume_or_Rethrow
+#undef _Unwind_SetGR
+#undef _Unwind_SetIP
+symverglobal (_Unwind_Backtrace, GCC_3.3);
+symverglobal (_Unwind_DeleteException, GCC_3.0);
+symverglobal (_Unwind_FindEnclosingFunction, GCC_3.3);
+symverglobal (_Unwind_ForcedUnwind, GCC_3.0);
+symverglobal (_Unwind_GetBSP, GCC_3.3.2);
+symverglobal (_Unwind_GetCFA, GCC_3.3);
+symverglobal (_Unwind_GetGR, GCC_3.0);
+symverglobal (_Unwind_GetIP, GCC_3.0);
+symverglobal (_Unwind_GetLanguageSpecificData, GCC_3.0);
+symverglobal (_Unwind_GetRegionStart, GCC_3.0);
+symverglobal (_Unwind_RaiseException, GCC_3.0);
+symverglobal (_Unwind_Resume, GCC_3.0);
+symverglobal (_Unwind_Resume_or_Rethrow, GCC_3.3);
+symverglobal (_Unwind_SetGR, GCC_3.0);
+symverglobal (_Unwind_SetIP, GCC_3.0);
+#endif
+
 #endif
diff --git a/gcc/config/ia64/unwind-shared-ia64.c b/gcc/config/ia64/unwind-shared-ia64.c
new file mode 100644
index 0000000..b1d9fd1
--- /dev/null
+++ b/gcc/config/ia64/unwind-shared-ia64.c
@@ -0,0 +1,2 @@
+#define SHARED
+#include "unwind-ia64.c"
diff --git a/gcc/config/m68k/m68k.md b/gcc/config/m68k/m68k.md
index 68ea933..a65618c 100644
--- a/gcc/config/m68k/m68k.md
+++ b/gcc/config/m68k/m68k.md
@@ -1454,11 +1454,20 @@
   ""
 {
   CC_STATUS_INIT;
-  operands[2] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);
-  if (TARGET_68020 || TARGET_COLDFIRE)
-    return "move%.b %1,%2\;extb%.l %2\;smi %0\;extb%.l %0";
+  if (ADDRESS_REG_P(operands[1]))
+    {
+      if (TARGET_68020 || TARGET_COLDFIRE)
+        return "move%.w %1,%R0\;extb%.l %R0\;smi %0\;extb%.l %0";
+      else
+        return "move%.w %1,%R0\;ext%.w %R0\;ext%.l %R0\;move%.l %R0,%0\;smi %0";
+    }
   else
-    return "move%.b %1,%2\;ext%.w %0\;ext%.l %2\;move%.l %2,%0\;smi %0";
+    {
+      if (TARGET_68020 || TARGET_COLDFIRE)
+        return "move%.b %1,%R0\;extb%.l %R0\;smi %0\;extb%.l %0";
+      else
+        return "move%.b %1,%R0\;ext%.w %R0\;ext%.l %R0\;move%.l %R0,%0\;smi %0";
+    }
 })
 
 (define_insn "extendhidi2"
@@ -4834,8 +4843,8 @@
 (define_insn ""
   [(set (match_operand:SI 0 "nonimmediate_operand" "=d")
 	(sign_extract:SI (match_operand:QI 1 "memory_operand" "o")
-			 (match_operand:SI 2 "general_operand" "di")
-			 (match_operand:SI 3 "general_operand" "di")))]
+			 (match_operand:SI 2 "general_operand" "dn")
+			 (match_operand:SI 3 "general_operand" "dn")))]
   "TARGET_68020 && TARGET_BITFIELD"
   "bfexts %1{%b3:%b2},%0")
 
@@ -4850,8 +4859,8 @@
 (define_insn ""
   [(set (match_operand:SI 0 "nonimmediate_operand" "=d,d")
 	(zero_extract:SI (match_operand:QI 1 "memory_operand" "o,d")
-			 (match_operand:SI 2 "general_operand" "di,di")
-			 (match_operand:SI 3 "general_operand" "di,di")))]
+			 (match_operand:SI 2 "general_operand" "dn,dn")
+			 (match_operand:SI 3 "general_operand" "dn,dn")))]
   "TARGET_68020 && TARGET_BITFIELD"
 {
   if (GET_CODE (operands[2]) == CONST_INT)
@@ -4868,8 +4877,8 @@
 
 (define_insn ""
   [(set (zero_extract:SI (match_operand:QI 0 "memory_operand" "+o")
-			 (match_operand:SI 1 "general_operand" "di")
-			 (match_operand:SI 2 "general_operand" "di"))
+			 (match_operand:SI 1 "general_operand" "dn")
+			 (match_operand:SI 2 "general_operand" "dn"))
         (xor:SI (zero_extract:SI (match_dup 0) (match_dup 1) (match_dup 2))
 		(match_operand 3 "const_int_operand" "n")))]
   "TARGET_68020 && TARGET_BITFIELD
@@ -4883,8 +4892,8 @@
 
 (define_insn ""
   [(set (zero_extract:SI (match_operand:QI 0 "memory_operand" "+o")
-			 (match_operand:SI 1 "general_operand" "di")
-			 (match_operand:SI 2 "general_operand" "di"))
+			 (match_operand:SI 1 "general_operand" "dn")
+			 (match_operand:SI 2 "general_operand" "dn"))
 	(const_int 0))]
   "TARGET_68020 && TARGET_BITFIELD"
 {
@@ -4894,8 +4903,8 @@
 
 (define_insn ""
   [(set (zero_extract:SI (match_operand:QI 0 "memory_operand" "+o")
-			 (match_operand:SI 1 "general_operand" "di")
-			 (match_operand:SI 2 "general_operand" "di"))
+			 (match_operand:SI 1 "general_operand" "dn")
+			 (match_operand:SI 2 "general_operand" "dn"))
 	(const_int -1))]
   "TARGET_68020 && TARGET_BITFIELD"
 {
@@ -4913,8 +4922,8 @@
 
 (define_insn ""
   [(set (zero_extract:SI (match_operand:QI 0 "memory_operand" "+o")
-			 (match_operand:SI 1 "general_operand" "di")
-			 (match_operand:SI 2 "general_operand" "di"))
+			 (match_operand:SI 1 "general_operand" "dn")
+			 (match_operand:SI 2 "general_operand" "dn"))
 	(match_operand:SI 3 "register_operand" "d"))]
   "TARGET_68020 && TARGET_BITFIELD"
   "bfins %3,%0{%b2:%b1}")
@@ -4925,16 +4934,16 @@
 (define_insn ""
   [(set (match_operand:SI 0 "nonimmediate_operand" "=d")
 	(sign_extract:SI (match_operand:SI 1 "register_operand" "d")
-			 (match_operand:SI 2 "general_operand" "di")
-			 (match_operand:SI 3 "general_operand" "di")))]
+			 (match_operand:SI 2 "general_operand" "dn")
+			 (match_operand:SI 3 "general_operand" "dn")))]
   "TARGET_68020 && TARGET_BITFIELD"
   "bfexts %1{%b3:%b2},%0")
 
 (define_insn ""
   [(set (match_operand:SI 0 "nonimmediate_operand" "=d")
 	(zero_extract:SI (match_operand:SI 1 "register_operand" "d")
-			 (match_operand:SI 2 "general_operand" "di")
-			 (match_operand:SI 3 "general_operand" "di")))]
+			 (match_operand:SI 2 "general_operand" "dn")
+			 (match_operand:SI 3 "general_operand" "dn")))]
   "TARGET_68020 && TARGET_BITFIELD"
 {
   if (GET_CODE (operands[2]) == CONST_INT)
@@ -4951,8 +4960,8 @@
 
 (define_insn ""
   [(set (zero_extract:SI (match_operand:SI 0 "register_operand" "+d")
-			 (match_operand:SI 1 "general_operand" "di")
-			 (match_operand:SI 2 "general_operand" "di"))
+			 (match_operand:SI 1 "general_operand" "dn")
+			 (match_operand:SI 2 "general_operand" "dn"))
 	(const_int 0))]
   "TARGET_68020 && TARGET_BITFIELD"
 {
@@ -4962,8 +4971,8 @@
 
 (define_insn ""
   [(set (zero_extract:SI (match_operand:SI 0 "register_operand" "+d")
-			 (match_operand:SI 1 "general_operand" "di")
-			 (match_operand:SI 2 "general_operand" "di"))
+			 (match_operand:SI 1 "general_operand" "dn")
+			 (match_operand:SI 2 "general_operand" "dn"))
 	(const_int -1))]
   "TARGET_68020 && TARGET_BITFIELD"
 {
@@ -4973,8 +4982,8 @@
 
 (define_insn ""
   [(set (zero_extract:SI (match_operand:SI 0 "register_operand" "+d")
-			 (match_operand:SI 1 "general_operand" "di")
-			 (match_operand:SI 2 "general_operand" "di"))
+			 (match_operand:SI 1 "general_operand" "dn")
+			 (match_operand:SI 2 "general_operand" "dn"))
 	(match_operand:SI 3 "register_operand" "d"))]
   "TARGET_68020 && TARGET_BITFIELD"
 {
@@ -4996,7 +5005,7 @@
   [(set (cc0)
 	(zero_extract:SI (match_operand:QI 0 "memory_operand" "o")
 			 (match_operand:SI 1 "const_int_operand" "n")
-			 (match_operand:SI 2 "general_operand" "di")))]
+			 (match_operand:SI 2 "general_operand" "dn")))]
   "TARGET_68020 && TARGET_BITFIELD"
 {
   if (operands[1] == const1_rtx
@@ -5021,7 +5030,7 @@
   [(set (cc0)
 	(zero_extract:SI (match_operand:SI 0 "register_operand" "d")
 			 (match_operand:SI 1 "const_int_operand" "n")
-			 (match_operand:SI 2 "general_operand" "di")))]
+			 (match_operand:SI 2 "general_operand" "dn")))]
   "TARGET_68020 && TARGET_BITFIELD"
 {
   if (operands[1] == const1_rtx
diff --git a/gcc/config/mips/linux.h b/gcc/config/mips/linux.h
index eee298f..ec48292 100644
--- a/gcc/config/mips/linux.h
+++ b/gcc/config/mips/linux.h
@@ -228,7 +228,7 @@ typedef struct _sig_ucontext {
       {                                                              \
         struct rt_sigframe {                                         \
           u_int32_t  trampoline[2];                                \
-          struct siginfo info;                                       \
+          siginfo_t info;                                       \
           _sig_ucontext_t uc;                                        \
         } *rt_ = (CONTEXT)->ra;                                      \
         sc_ = &rt_->uc.uc_mcontext;                                  \
diff --git a/gcc/config/mips/mips.c b/gcc/config/mips/mips.c
index 0aa24f6..b907b48 100644
--- a/gcc/config/mips/mips.c
+++ b/gcc/config/mips/mips.c
@@ -707,6 +707,7 @@ const struct mips_cpu_info mips_cpu_info_table[] = {
 
   /* MIPS IV */
   { "r8000", PROCESSOR_R8000, 4 },
+  { "r10000", PROCESSOR_R10000, 4 },
   { "vr5000", PROCESSOR_R5000, 4 },
   { "vr5400", PROCESSOR_R5400, 4 },
   { "vr5500", PROCESSOR_R5500, 4 },
@@ -9406,6 +9407,9 @@ mips_issue_rate (void)
 {
   switch (mips_tune)
     {
+    case PROCESSOR_R10000:
+      return 4;
+
     case PROCESSOR_R5400:
     case PROCESSOR_R5500:
     case PROCESSOR_R7000:
diff --git a/gcc/config/mips/mips.h b/gcc/config/mips/mips.h
index d087ed2..87562cb 100644
--- a/gcc/config/mips/mips.h
+++ b/gcc/config/mips/mips.h
@@ -66,6 +66,7 @@ enum processor_type {
   PROCESSOR_R7000,
   PROCESSOR_R8000,
   PROCESSOR_R9000,
+  PROCESSOR_R10000,
   PROCESSOR_SB1,
   PROCESSOR_SR71000
 };
diff --git a/gcc/config/mips/mips.md b/gcc/config/mips/mips.md
index 5054542..32b3ba7 100644
--- a/gcc/config/mips/mips.md
+++ b/gcc/config/mips/mips.md
@@ -103,6 +103,7 @@
 ;; arith	integer arithmetic instruction
 ;; darith	double precision integer arithmetic instructions
 ;; const	load constant
+;; shift        integer shift
 ;; imul		integer multiply
 ;; imadd	integer multiply-add
 ;; idiv		integer divide
@@ -120,7 +121,7 @@
 ;; multi	multiword sequence (or user asm statements)
 ;; nop		no operation
 (define_attr "type"
-  "unknown,branch,jump,call,load,store,prefetch,prefetchx,move,condmove,xfer,hilo,const,arith,darith,imul,imadd,idiv,icmp,fadd,fmul,fmadd,fdiv,fabs,fneg,fcmp,fcvt,fsqrt,frsqrt,multi,nop"
+  "unknown,branch,jump,call,load,store,prefetch,prefetchx,move,condmove,xfer,hilo,const,arith,darith,shift,imul,imadd,idiv,icmp,fadd,fmul,fmadd,fdiv,fabs,fneg,fcmp,fcvt,fsqrt,frsqrt,multi,nop"
   (cond [(eq_attr "jal" "!unset") (const_string "call")
 	 (eq_attr "got" "load") (const_string "load")]
 	(const_string "unknown")))
@@ -214,7 +215,7 @@
 ;; Attribute describing the processor.  This attribute must match exactly
 ;; with the processor_type enumeration in mips.h.
 (define_attr "cpu"
-  "default,4kc,5kc,20kc,m4k,r3000,r3900,r6000,r4000,r4100,r4111,r4120,r4300,r4600,r4650,r5000,r5400,r5500,r7000,r8000,r9000,sb1,sr71000"
+  "default,4kc,5kc,20kc,m4k,r3000,r3900,r6000,r4000,r4100,r4111,r4120,r4300,r4600,r4650,r5000,r5400,r5500,r7000,r8000,r9000,r10000,sb1,sr71000"
   (const (symbol_ref "mips_tune")))
 
 ;; The type of hardware hazard associated with this instruction.
@@ -306,12 +307,12 @@
 
 (define_function_unit "memory" 1 0
   (and (eq_attr "type" "load")
-       (eq_attr "cpu" "!r3000,r3900,r4600,r4650,r4100,r4120,r4300,r5000"))
+       (eq_attr "cpu" "!r3000,r3900,r4600,r4650,r4100,r4120,r4300,r5000,r10000"))
   3 0)
 
 (define_function_unit "memory" 1 0
   (and (eq_attr "type" "load")
-       (eq_attr "cpu" "r3000,r3900,r4600,r4650,r4100,r4120,r4300,r5000"))
+       (eq_attr "cpu" "r3000,r3900,r4600,r4650,r4100,r4120,r4300,r5000,r10000"))
   2 0)
 
 (define_function_unit "memory"   1 0 (eq_attr "type" "store") 1 0)
@@ -324,7 +325,7 @@
 
 (define_function_unit "imuldiv"  1 0
   (and (eq_attr "type" "imul,imadd")
-       (eq_attr "cpu" "!r3000,r3900,r4000,r4600,r4650,r4100,r4120,r4300,r5000"))
+       (eq_attr "cpu" "!r3000,r3900,r4000,r4600,r4650,r4100,r4120,r4300,r5000,r10000"))
   17 17)
 
 ;; On them mips16, we want to stronly discourage a mult from appearing
@@ -376,7 +377,7 @@
 
 (define_function_unit "imuldiv"  1 0
   (and (eq_attr "type" "idiv")
-       (eq_attr "cpu" "!r3000,r3900,r4000,r4600,r4650,r4100,r4120,r4300,r5000"))
+       (eq_attr "cpu" "!r3000,r3900,r4000,r4600,r4650,r4100,r4120,r4300,r5000,r10000"))
   38 38)
 
 (define_function_unit "imuldiv"  1 0
@@ -425,6 +426,40 @@
        (and (eq_attr "mode" "DI") (eq_attr "cpu" "r5000")))
   68 68)
 
+;; R10000 has 2 integer ALUs
+(define_function_unit "alu" 2 0
+  (and (eq_attr "type" "arith,darith,shift")
+       (eq_attr "cpu" "r10000"))
+  1 0)
+
+;; Only ALU1 can do shifts.  We model shifts as an additional unit
+(define_function_unit "alu1" 1 0
+  (and (eq_attr "type" "shift")
+       (eq_attr "cpu" "r10000"))
+  1 0)
+
+;; only ALU2 does multiplications and divisions
+(define_function_unit "alu2"  1 0
+  (and (eq_attr "type" "imul")
+       (and (eq_attr "mode" "SI") (eq_attr "cpu" "r10000")))
+  6 6)
+
+(define_function_unit "alu2"  1 0
+  (and (eq_attr "type" "imul")
+       (and (eq_attr "mode" "DI") (eq_attr "cpu" "r10000")))
+  10 10)
+
+(define_function_unit "alu2"  1 0
+  (and (eq_attr "type" "idiv")
+       (and (eq_attr "mode" "SI") (eq_attr "cpu" "r10000")))
+  35 35)
+
+(define_function_unit "alu2"  1 0
+  (and (eq_attr "type" "idiv")
+       (and (eq_attr "mode" "DI") (eq_attr "cpu" "r10000")))
+  67 67)
+
+
 ;; The R4300 does *NOT* have a separate Floating Point Unit, instead
 ;; the FP hardware is part of the normal ALU circuitry.  This means FP
 ;; instructions affect the pipe-line, and no functional unit
@@ -433,11 +468,11 @@
 ;; instructions to be processed in the "imuldiv" unit.
 
 (define_function_unit "adder" 1 1
-  (and (eq_attr "type" "fcmp") (eq_attr "cpu" "!r3000,r3900,r6000,r4300,r5000"))
+  (and (eq_attr "type" "fcmp") (eq_attr "cpu" "!r3000,r3900,r6000,r4300,r5000,r10000"))
   3 0)
 
 (define_function_unit "adder" 1 1
-  (and (eq_attr "type" "fcmp") (eq_attr "cpu" "r3000,r3900,r6000"))
+  (and (eq_attr "type" "fcmp") (eq_attr "cpu" "r3000,r3900,r6000,r10000"))
   2 0)
 
 (define_function_unit "adder" 1 1
@@ -445,7 +480,7 @@
   1 0)
 
 (define_function_unit "adder" 1 1
-  (and (eq_attr "type" "fadd") (eq_attr "cpu" "!r3000,r3900,r6000,r4300"))
+  (and (eq_attr "type" "fadd") (eq_attr "cpu" "!r3000,r3900,r6000,r4300,r10000"))
   4 0)
 
 (define_function_unit "adder" 1 1
@@ -456,6 +491,10 @@
   (and (eq_attr "type" "fadd") (eq_attr "cpu" "r6000"))
   3 0)
 
+(define_function_unit "adder" 1 1
+  (and (eq_attr "type" "fadd,fmadd") (eq_attr "cpu" "r10000"))
+  2 0)
+
 (define_function_unit "adder" 1 1
   (and (eq_attr "type" "fabs,fneg")
        (eq_attr "cpu" "!r3000,r3900,r4600,r4650,r4300,r5000"))
@@ -468,7 +507,7 @@
 (define_function_unit "mult" 1 1
   (and (eq_attr "type" "fmul")
        (and (eq_attr "mode" "SF")
-	    (eq_attr "cpu" "!r3000,r3900,r6000,r4600,r4650,r4300,r5000")))
+	    (eq_attr "cpu" "!r3000,r3900,r6000,r4600,r4650,r4300,r5000,r10000")))
   7 0)
 
 (define_function_unit "mult" 1 1
@@ -488,7 +527,7 @@
 
 (define_function_unit "mult" 1 1
   (and (eq_attr "type" "fmul")
-       (and (eq_attr "mode" "DF") (eq_attr "cpu" "!r3000,r3900,r6000,r4300,r5000")))
+       (and (eq_attr "mode" "DF") (eq_attr "cpu" "!r3000,r3900,r6000,r4300,r5000,r10000")))
   8 0)
 
 (define_function_unit "mult" 1 1
@@ -501,10 +540,14 @@
        (and (eq_attr "mode" "DF") (eq_attr "cpu" "r6000")))
   6 0)
 
+(define_function_unit "mult" 1 1
+  (and (eq_attr "type" "fmul,fmadd") (eq_attr "cpu" "r10000"))
+  2 0)
+
 (define_function_unit "divide" 1 1
   (and (eq_attr "type" "fdiv")
        (and (eq_attr "mode" "SF")
-	    (eq_attr "cpu" "!r3000,r3900,r6000,r4600,r4650,r4300,r5000")))
+	    (eq_attr "cpu" "!r3000,r3900,r6000,r4600,r4650,r4300,r5000,r10000")))
   23 0)
 
 (define_function_unit "divide" 1 1
@@ -530,7 +573,7 @@
 (define_function_unit "divide" 1 1
   (and (eq_attr "type" "fdiv")
        (and (eq_attr "mode" "DF")
-	    (eq_attr "cpu" "!r3000,r3900,r6000,r4600,r4650,r4300")))
+	    (eq_attr "cpu" "!r3000,r3900,r6000,r4600,r4650,r4300,r10000")))
   36 0)
 
 (define_function_unit "divide" 1 1
@@ -548,10 +591,21 @@
        (and (eq_attr "mode" "DF") (eq_attr "cpu" "r4600,r4650")))
   61 0)
 
+;; divisions keep multiplier busy on R10000
+(define_function_unit "mult" 1 1
+  (and (eq_attr "type" "fdiv") 
+       (and (eq_attr "mode" "SF") (eq_attr "cpu" "r10000")))
+  12 14)
+
+(define_function_unit "mult" 1 1
+  (and (eq_attr "type" "fdiv") 
+       (and (eq_attr "mode" "DF") (eq_attr "cpu" "r10000")))
+  19 21)
+
 ;;; ??? Is this number right?
 (define_function_unit "divide" 1 1
   (and (eq_attr "type" "fsqrt,frsqrt")
-       (and (eq_attr "mode" "SF") (eq_attr "cpu" "!r4600,r4650,r4300,r5000")))
+       (and (eq_attr "mode" "SF") (eq_attr "cpu" "!r4600,r4650,r4300,r5000,r10000")))
   54 0)
 
 (define_function_unit "divide" 1 1
@@ -567,7 +621,7 @@
 ;;; ??? Is this number right?
 (define_function_unit "divide" 1 1
   (and (eq_attr "type" "fsqrt,frsqrt")
-       (and (eq_attr "mode" "DF") (eq_attr "cpu" "!r4600,r4650,r4300,r5000")))
+       (and (eq_attr "mode" "DF") (eq_attr "cpu" "!r4600,r4650,r4300,r5000,r10000")))
   112 0)
 
 (define_function_unit "divide" 1 1
@@ -580,6 +634,17 @@
        (and (eq_attr "mode" "DF") (eq_attr "cpu" "r5000")))
   36 0)
 
+;; sqrt is executed by multiplier on R10000
+(define_function_unit "mult" 1 1
+  (and (eq_attr "type" "fsqrt")
+       (and (eq_attr "mode" "SF") (eq_attr "cpu" "r10000")))
+  18 20)
+
+(define_function_unit "mult" 1 1
+  (and (eq_attr "type" "fsqrt")
+       (and (eq_attr "mode" "DF") (eq_attr "cpu" "r10000")))
+  33 35)
+
 ;; R4300 FP instruction classes treated as part of the "imuldiv"
 ;; functional unit:
 
@@ -3158,7 +3223,7 @@ dsrl\t%3,%3,1\n\
   "@
     sll\t%0,%1,0
     sw\t%1,%0"
-  [(set_attr "type" "darith,store")
+  [(set_attr "type" "shift,store")
    (set_attr "mode" "SI")
    (set_attr "extended_mips16" "yes,*")])
 
@@ -3192,7 +3257,7 @@ dsrl\t%3,%3,1\n\
                                   (match_operand:DI 2 "small_int" "I"))))]
   "TARGET_64BIT && !TARGET_MIPS16 && INTVAL (operands[2]) >= 32"
   "dsra\t%0,%1,%2"
-  [(set_attr "type" "darith")
+  [(set_attr "type" "shift")
    (set_attr "mode" "SI")])
 
 (define_insn ""
@@ -3201,7 +3266,7 @@ dsrl\t%3,%3,1\n\
                                   (const_int 32))))]
   "TARGET_64BIT && !TARGET_MIPS16"
   "dsra\t%0,%1,32"
-  [(set_attr "type" "darith")
+  [(set_attr "type" "shift")
    (set_attr "mode" "SI")])
 
 
@@ -5246,7 +5311,7 @@ dsrl\t%3,%3,1\n\
 
   return "sll\t%0,%1,%2";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"shift")
    (set_attr "mode"	"SI")])
 
 (define_insn "ashlsi3_internal1_extend"
@@ -5260,7 +5325,7 @@ dsrl\t%3,%3,1\n\
 
   return "sll\t%0,%1,%2";
 }
-  [(set_attr "type"    "arith")
+  [(set_attr "type"    "shift")
    (set_attr "mode"    "DI")])
 
 
@@ -5278,7 +5343,7 @@ dsrl\t%3,%3,1\n\
 
   return "sll\t%0,%1,%2";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"shift")
    (set_attr "mode"	"SI")
    (set_attr_alternative "length"
 		[(const_int 4)
@@ -5379,7 +5444,7 @@ sll\t%L0,%L1,%2\n\
   operands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);
   return "sll\t%M0,%L1,%2\;move\t%L0,%.";
 }
-  [(set_attr "type"	"darith")
+  [(set_attr "type"	"shift")
    (set_attr "mode"	"DI")
    (set_attr "length"	"8")])
 
@@ -5434,7 +5499,7 @@ sll\t%L0,%L1,%2\n\
 
   return "sll\t%M0,%M1,%2\;srl\t%3,%L1,%4\;or\t%M0,%M0,%3\;sll\t%L0,%L1,%2";
 }
-  [(set_attr "type"	"darith")
+  [(set_attr "type"	"shift")
    (set_attr "mode"	"DI")
    (set_attr "length"	"16")])
 
@@ -5518,7 +5583,7 @@ sll\t%L0,%L1,%2\n\
 
   return "dsll\t%0,%1,%2";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"shift")
    (set_attr "mode"	"DI")])
 
 (define_insn ""
@@ -5535,7 +5600,7 @@ sll\t%L0,%L1,%2\n\
 
   return "dsll\t%0,%1,%2";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"shift")
    (set_attr "mode"	"DI")
    (set_attr_alternative "length"
 		[(const_int 4)
@@ -5596,7 +5661,7 @@ sll\t%L0,%L1,%2\n\
 
   return "sra\t%0,%1,%2";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"shift")
    (set_attr "mode"	"SI")])
 
 (define_insn "ashrsi3_internal2"
@@ -5613,7 +5678,7 @@ sll\t%L0,%L1,%2\n\
 
   return "sra\t%0,%1,%2";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"shift")
    (set_attr "mode"	"SI")
    (set_attr_alternative "length"
 		[(const_int 4)
@@ -5710,7 +5775,7 @@ sra\t%M0,%M1,%2\n\
   operands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);
   return "sra\t%L0,%M1,%2\;sra\t%M0,%M1,31";
 }
-  [(set_attr "type"	"darith")
+  [(set_attr "type"	"shift")
    (set_attr "mode"	"DI")
    (set_attr "length"	"8")])
 
@@ -5765,7 +5830,7 @@ sra\t%M0,%M1,%2\n\
 
   return "srl\t%L0,%L1,%2\;sll\t%3,%M1,%4\;or\t%L0,%L0,%3\;sra\t%M0,%M1,%2";
 }
-  [(set_attr "type"	"darith")
+  [(set_attr "type"	"shift")
    (set_attr "mode"	"DI")
    (set_attr "length"	"16")])
 
@@ -5849,7 +5914,7 @@ sra\t%M0,%M1,%2\n\
 
   return "dsra\t%0,%1,%2";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"shift")
    (set_attr "mode"	"DI")])
 
 (define_insn ""
@@ -5863,7 +5928,7 @@ sra\t%M0,%M1,%2\n\
 
   return "dsra\t%0,%2";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"shift")
    (set_attr "mode"	"DI")
    (set_attr_alternative "length"
 		[(const_int 4)
@@ -5923,7 +5988,7 @@ sra\t%M0,%M1,%2\n\
 
   return "srl\t%0,%1,%2";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"shift")
    (set_attr "mode"	"SI")])
 
 (define_insn "lshrsi3_internal2"
@@ -5940,7 +6005,7 @@ sra\t%M0,%M1,%2\n\
 
   return "srl\t%0,%1,%2";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"shift")
    (set_attr "mode"	"SI")
    (set_attr_alternative "length"
 		[(const_int 4)
@@ -6061,7 +6126,7 @@ srl\t%M0,%M1,%2\n\
   operands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);
   return "srl\t%L0,%M1,%2\;move\t%M0,%.";
 }
-  [(set_attr "type"	"darith")
+  [(set_attr "type"	"shift")
    (set_attr "mode"	"DI")
    (set_attr "length"	"8")])
 
@@ -6116,7 +6181,7 @@ srl\t%M0,%M1,%2\n\
 
   return "srl\t%L0,%L1,%2\;sll\t%3,%M1,%4\;or\t%L0,%L0,%3\;srl\t%M0,%M1,%2";
 }
-  [(set_attr "type"	"darith")
+  [(set_attr "type"	"shift")
    (set_attr "mode"	"DI")
    (set_attr "length"	"16")])
 
@@ -6200,7 +6265,7 @@ srl\t%M0,%M1,%2\n\
 
   return "dsrl\t%0,%1,%2";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"shift")
    (set_attr "mode"	"DI")])
 
 (define_insn ""
@@ -6214,7 +6279,7 @@ srl\t%M0,%M1,%2\n\
 
   return "dsrl\t%0,%2";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"shift")
    (set_attr "mode"	"DI")
    (set_attr_alternative "length"
 		[(const_int 4)
diff --git a/gcc/config/netbsd-elf.h b/gcc/config/netbsd-elf.h
index a87699c..0cbdb92 100644
--- a/gcc/config/netbsd-elf.h
+++ b/gcc/config/netbsd-elf.h
@@ -83,6 +83,7 @@ Boston, MA 02111-1307, USA.  */
 #define NETBSD_LINK_SPEC_ELF \
   "%{assert*} %{R*} %{rpath*} \
    %{shared:-shared} \
+   %{symbolic:-Bsymbolic} \
    %{!shared: \
      -dc -dp \
      %{!nostdlib: \
diff --git a/gcc/config/openbsd.h b/gcc/config/openbsd.h
index 670a0a0..0e3b4ec 100644
--- a/gcc/config/openbsd.h
+++ b/gcc/config/openbsd.h
@@ -52,15 +52,14 @@ Boston, MA 02111-1307, USA.  */
 
 #ifdef OPENBSD_NATIVE
 
-#undef GCC_INCLUDE_DIR
-#define GCC_INCLUDE_DIR "/usr/include"
-
 /* The compiler is configured with ONLY the gcc/g++ standard headers.  */
 #undef INCLUDE_DEFAULTS
 #define INCLUDE_DEFAULTS			\
   {						\
     { GPLUSPLUS_INCLUDE_DIR, "G++", 1, 1 },	\
-    { GCC_INCLUDE_DIR, "GCC", 0, 0 },		\
+    { GPLUSPLUS_TOOL_INCLUDE_DIR, "G++", 1, 1 }, \
+    { GPLUSPLUS_BACKWARD_INCLUDE_DIR, "G++", 1, 1 }, \
+    { STANDARD_INCLUDE_DIR, STANDARD_INCLUDE_COMPONENT, 0, 0 }, \
     { 0, 0, 0, 0 }				\
   }
 
@@ -72,9 +71,39 @@ Boston, MA 02111-1307, USA.  */
 
 
 /* Controlling the compilation driver.  */
+/* TARGET_OS_CPP_BUILTINS() common to all OpenBSD targets.  */
+#define OPENBSD_OS_CPP_BUILTINS_COMMON()	\
+  do						\
+    {						\
+      builtin_define ("__OpenBSD__");		\
+      builtin_define ("__unix__");		\
+      builtin_define ("__ANSI_COMPAT");		\
+      builtin_assert ("system=unix");		\
+      builtin_assert ("system=bsd");		\
+      builtin_assert ("system=OpenBSD");	\
+    }						\
+  while (0)
+
+/* TARGET_OS_CPP_BUILTINS() common to all OpenBSD ELF targets.  */
+#define OPENBSD_OS_CPP_BUILTINS_ELF()		\
+  do						\
+    {						\
+      OPENBSD_OS_CPP_BUILTINS_COMMON();		\
+      builtin_define ("__ELF__");		\
+    }						\
+  while (0)
+
+/* TARGET_OS_CPP_BUILTINS() common to all LP64 OpenBSD targets.  */
+#define OPENBSD_OS_CPP_BUILTINS_LP64()		\
+  do						\
+    {						\
+      builtin_define ("_LP64");			\
+      builtin_define ("__LP64__");		\
+    }						\
+  while (0)
 
 /* CPP_SPEC appropriate for OpenBSD. We deal with -posix and -pthread.
-   XXX the way threads are handling currently is not very satisfying,
+   XXX the way threads are handled currently is not very satisfying,
    since all code must be compiled with -pthread to work. 
    This two-stage defines makes it easy to pick that for targets that
    have subspecs.  */
@@ -84,10 +113,9 @@ Boston, MA 02111-1307, USA.  */
 #define OBSD_CPP_SPEC "%{posix:-D_POSIX_SOURCE} %{pthread:-D_POSIX_THREADS}"
 #endif
 
-/* LIB_SPEC appropriate for OpenBSD.  Select the appropriate libc, 
-   depending on profiling and threads.  Basically, 
-   -lc(_r)?(_p)?, select _r for threads, and _p for p or pg.  */
-#define OBSD_LIB_SPEC "%{!shared:-lc%{pthread:_r}%{p:_p}%{!p:%{pg:_p}}}"
+/* LIB_SPEC appropriate for OpenBSD.  Include -lpthread if -pthread is
+   specified on the command line. */
+#define OBSD_LIB_SPEC "%{!shared:%{pthread:-lpthread%{p:_p}%{!p:%{pg:_p}}}} %{!shared:-lc%{p:_p}%{!p:%{pg:_p}}}"
 
 #ifndef OBSD_HAS_CORRECT_SPECS
 
diff --git a/gcc/config/rs6000/ppc-asm.h b/gcc/config/rs6000/ppc-asm.h
index 74e1483..47547f6 100644
--- a/gcc/config/rs6000/ppc-asm.h
+++ b/gcc/config/rs6000/ppc-asm.h
@@ -158,7 +158,7 @@ GLUE(.L,name): \
 	.size FUNC_NAME(name),GLUE(.L,name)-FUNC_NAME(name)
 #endif
 
-#if defined __linux__ && !defined __powerpc64__
+#if defined __linux__
 	.section .note.GNU-stack
 	.previous
 #endif
diff --git a/gcc/config/rs6000/rs6000.c b/gcc/config/rs6000/rs6000.c
index ea35843..6909cef 100644
--- a/gcc/config/rs6000/rs6000.c
+++ b/gcc/config/rs6000/rs6000.c
@@ -1177,6 +1177,12 @@ rs6000_file_start (void)
       if (*start == '\0')
 	putc ('\n', file);
     }
+
+  if (DEFAULT_ABI == ABI_AIX || (TARGET_ELF && flag_pic == 2))
+    {
+      toc_section ();
+      text_section ();
+    }
 }
 
 /* Return nonzero if this function is known to have a null epilogue.  */
@@ -11452,13 +11458,6 @@ rs6000_emit_load_toc_table (int fromprolog)
 		   ? gen_rtx_REG (Pmode, 0)
 		   : gen_reg_rtx (Pmode));
 
-      /* possibly create the toc section */
-      if (! toc_initialized)
-	{
-	  toc_section ();
-	  function_section (current_function_decl);
-	}
-
       if (fromprolog)
 	{
 	  rtx symF, symL;
@@ -15920,7 +15919,6 @@ rs6000_xcoff_file_start (void)
   fputs ("\t.file\t", asm_out_file);
   output_quoted_string (asm_out_file, main_input_filename);
   fputc ('\n', asm_out_file);
-  toc_section ();
   if (write_symbols != NO_DEBUG)
     private_data_section ();
   text_section ();
diff --git a/gcc/config/rs6000/t-linux64 b/gcc/config/rs6000/t-linux64
index 6d1e6f4..84b99a8 100644
--- a/gcc/config/rs6000/t-linux64
+++ b/gcc/config/rs6000/t-linux64
@@ -9,13 +9,13 @@ TARGET_LIBGCC2_CFLAGS = -mno-minimal-toc -fPIC -specs=bispecs
 
 SHLIB_MAPFILES += $(srcdir)/config/rs6000/libgcc-ppc64.ver
 
-MULTILIB_OPTIONS        = m64/m32 msoft-float
-MULTILIB_DIRNAMES       = 64 32 nof
+MULTILIB_OPTIONS        = m64/m32
+MULTILIB_DIRNAMES       = 64 32
 MULTILIB_EXTRA_OPTS     = fPIC mstrict-align
-MULTILIB_EXCEPTIONS     = m64/msoft-float
-MULTILIB_EXCLUSIONS     = m64/!m32/msoft-float
-MULTILIB_OSDIRNAMES	= ../lib64 ../lib nof
-MULTILIB_MATCHES        = $(MULTILIB_MATCHES_FLOAT)
+MULTILIB_EXCEPTIONS     =
+MULTILIB_EXCLUSIONS     =
+MULTILIB_OSDIRNAMES	= ../lib64 ../lib
+MULTILIB_MATCHES        =
 
 # We want fine grained libraries, so use the new code to build the
 # floating point emulation libraries.
diff --git a/gcc/config/sh/lib1funcs.asm b/gcc/config/sh/lib1funcs.asm
index eebce2e..1d58d09 100644
--- a/gcc/config/sh/lib1funcs.asm
+++ b/gcc/config/sh/lib1funcs.asm
@@ -37,9 +37,19 @@ Boston, MA 02111-1307, USA.  */
    ELF local label prefixes by J"orn Rennecke
    amylaar@cygnus.com  */
 
+#define ALIAS(X,Y)	.global GLOBAL(X); .set GLOBAL(X),GLOBAL(Y)
+
 #ifdef __ELF__
 #define LOCAL(X)	.L_##X
-#define FUNC(X)		.type X,@function
+
+#if 1 /* ??? The export list mechanism is broken, everything that is not
+	 hidden is exported.  */
+#undef FUNC
+#define FUNC(X)		.type X,@function; .hidden X
+#undef ALIAS
+#define ALIAS(X,Y)	.global GLOBAL(X); .set GLOBAL(X),GLOBAL(Y); .hidden GLOBAL(X)
+#endif
+
 #define ENDFUNC0(X)	.Lfe_##X: .size X,.Lfe_##X-X
 #define ENDFUNC(X)	ENDFUNC0(X)
 #else
diff --git a/gcc/config/sh/linux.h b/gcc/config/sh/linux.h
index b2ad064..94c2293 100644
--- a/gcc/config/sh/linux.h
+++ b/gcc/config/sh/linux.h
@@ -145,6 +145,7 @@ do { \
 /* Do code reading to identify a signal frame, and set the frame
    state data appropriately.  See unwind-dw2.c for the structs.  */
 
+#ifndef inhibit_libc
 #ifdef IN_LIBGCC2
 #include <signal.h>
 #include <sys/ucontext.h>
@@ -244,8 +245,8 @@ do { \
 		 && (*(unsigned short *) (pc_+14)  == 0x00ad))))	\
       {									\
 	struct rt_sigframe {						\
-	  struct siginfo info;						\
-	  struct ucontext uc;						\
+	  siginfo_t info;						\
+	  ucontext_t uc;						\
 	} *rt_ = (CONTEXT)->cfa;					\
 	sc_ = (struct sigcontext *) &rt_->uc.uc_mcontext;		\
       }									\
@@ -295,6 +296,7 @@ do { \
 
 #endif /* defined (__SH5__) */
 #endif /* IN_LIBGCC2 */
+#endif /* inhibit_libc */
 
 /* For SH3 and SH4, we use a slot of the unwind frame which correspond
    to a fake register number 16 as a placeholder for the return address
diff --git a/gcc/config/sh/sh.c b/gcc/config/sh/sh.c
index 403c274..847309a 100644
--- a/gcc/config/sh/sh.c
+++ b/gcc/config/sh/sh.c
@@ -8999,6 +8999,9 @@ sh_register_move_cost (enum machine_mode mode,
       && REGCLASS_HAS_FP_REG (dstclass))
     return 4;
 
+  if (REGCLASS_HAS_FP_REG (dstclass) && srcclass == T_REGS)
+    return ((TARGET_HARD_SH4 && !optimize_size) ? 10 : 7);
+
   if ((REGCLASS_HAS_FP_REG (dstclass) && srcclass == MAC_REGS)
       || (dstclass== MAC_REGS && REGCLASS_HAS_FP_REG (srcclass)))
     return 9;
@@ -9107,6 +9110,15 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,
     }
   this = FUNCTION_ARG (cum, Pmode, ptr_type_node, 1);
 
+  /* In PIC case, we set PIC register to compute the target address.  We
+     can use a scratch register to save and restore the original value  
+     except for SHcompact.  For SHcompact, use stack.  */
+  if (flag_pic && TARGET_SHCOMPACT)
+    {
+      push (PIC_OFFSET_TABLE_REGNUM);
+      emit_insn (gen_GOTaddr2picreg ());
+    }
+
   /* For SHcompact, we only have r0 for a scratch register: r1 is the
      static chain pointer (even if you can't have nested virtual functions
      right now, someone might implement them sometime), and the rest of the
@@ -9189,8 +9201,24 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,
       assemble_external (function);
       TREE_USED (function) = 1;
     }
+  /* We can use scratch1 to save and restore the original value of
+     PIC register except for SHcompact.  */
+  if (flag_pic && ! TARGET_SHCOMPACT)
+    {
+      emit_move_insn (scratch1,
+		      gen_rtx_REG (Pmode, PIC_OFFSET_TABLE_REGNUM));
+      emit_insn (gen_GOTaddr2picreg ());
+    }
   funexp = XEXP (DECL_RTL (function), 0);
   emit_move_insn (scratch2, funexp);
+  if (flag_pic)
+    {
+      if (! TARGET_SHCOMPACT)
+	emit_move_insn (gen_rtx_REG (Pmode, PIC_OFFSET_TABLE_REGNUM),
+			scratch1);
+      else
+	pop (PIC_OFFSET_TABLE_REGNUM);
+    }
   funexp = gen_rtx_MEM (FUNCTION_MODE, scratch2);
   sibcall = emit_call_insn (gen_sibcall (funexp, const0_rtx, NULL_RTX));
   SIBLING_CALL_P (sibcall) = 1;
diff --git a/gcc/config/sh/sh.h b/gcc/config/sh/sh.h
index bfba34a..5828974 100644
--- a/gcc/config/sh/sh.h
+++ b/gcc/config/sh/sh.h
@@ -422,6 +422,10 @@ extern int target_flags;
 do {									\
   if (LEVEL)								\
     flag_omit_frame_pointer = -1;					\
+  if (LEVEL <= 2)							\
+    {									\
+      flag_reorder_blocks = 0;						\
+    }									\
   if (SIZE)								\
     target_flags |= SPACE_BIT;						\
   if (TARGET_SHMEDIA && LEVEL > 1)					\
diff --git a/gcc/config/sparc/openbsd.h b/gcc/config/sparc/openbsd.h
index e36f51e..2c35c95 100644
--- a/gcc/config/sparc/openbsd.h
+++ b/gcc/config/sparc/openbsd.h
@@ -22,10 +22,7 @@ Boston, MA 02111-1307, USA.  */
 #define TARGET_OS_CPP_BUILTINS()		\
   do						\
     {						\
-	builtin_define ("__unix__");		\
-	builtin_define ("__OpenBSD__");		\
-	builtin_assert ("system=unix");		\
-	builtin_assert ("system=OpenBSD");	\
+      OPENBSD_OS_CPP_BUILTINS_ELF();		\
     }						\
   while (0)
 
@@ -44,6 +41,23 @@ Boston, MA 02111-1307, USA.  */
 #undef WCHAR_TYPE_SIZE
 #define WCHAR_TYPE_SIZE 32
 
+#undef LINK_SPEC
+#define LINK_SPEC \
+  "%{!shared:%{!nostdlib:%{!r*:%{!e*:-e __start}}}} \
+   %{shared:-shared} %{R*} \
+   %{static:-Bstatic} \
+   %{!static:-Bdynamic} \
+   %{assert*} \
+   %{!dynamic-linker:-dynamic-linker /usr/libexec/ld.so}"
+
+/* As an elf system, we need crtbegin/crtend stuff.  */
+#undef STARTFILE_SPEC
+#define STARTFILE_SPEC "\
+	%{!shared: %{pg:gcrt0%O%s} %{!pg:%{p:gcrt0%O%s} %{!p:crt0%O%s}} \
+	crtbegin%O%s} %{shared:crtbeginS%O%s}"
+#undef ENDFILE_SPEC
+#define ENDFILE_SPEC "%{!shared:crtend%O%s} %{shared:crtendS%O%s}"
+
 /* Specific options for DBX Output.  */
 
 /* This is BSD, so it wants DBX format.  */
diff --git a/gcc/configure.ac b/gcc/configure.ac
index d9151dd..1526221 100644
--- a/gcc/configure.ac
+++ b/gcc/configure.ac
@@ -2218,7 +2218,7 @@ foo:	.long	25
 	tls_first_minor=14
 	tls_as_opt="-m64 -Aesame --fatal-warnings"
 	;;
-  sh-*-* | sh[34]-*-*)
+  sh-*-* | sh[34]*-*-*)
     conftest_s='
 	.section ".tdata","awT",@progbits
 foo:	.long	25
diff --git a/gcc/cp/class.c b/gcc/cp/class.c
index c14313c..6d01476 100644
--- a/gcc/cp/class.c
+++ b/gcc/cp/class.c
@@ -6803,14 +6803,8 @@ initialize_vtable (tree binfo, tree inits)
 static void
 initialize_array (tree decl, tree inits)
 {
-  tree context;
-
-  context = DECL_CONTEXT (decl);
-  DECL_CONTEXT (decl) = NULL_TREE;
   DECL_INITIAL (decl) = build_constructor (NULL_TREE, inits);
-  TREE_HAS_CONSTRUCTOR (DECL_INITIAL (decl)) = 1;
   cp_finish_decl (decl, DECL_INITIAL (decl), NULL_TREE, 0);
-  DECL_CONTEXT (decl) = context;
 }
 
 /* Build the VTT (virtual table table) for T.
diff --git a/gcc/cp/cp-tree.h b/gcc/cp/cp-tree.h
index cc1f937..680790a 100644
--- a/gcc/cp/cp-tree.h
+++ b/gcc/cp/cp-tree.h
@@ -75,6 +75,7 @@ struct diagnostic_context;
           or FIELD_DECL).
       NEED_TEMPORARY_P (in REF_BIND, BASE_CONV)
       IDENTIFIER_TYPENAME_P (in IDENTIFIER_NODE)
+      DECL_TINFO_P (in VAR_DECL)
    5: C_IS_RESERVED_WORD (in IDENTIFIER_NODE)
       DECL_VTABLE_OR_VTT_P (in VAR_DECL)
    6: For future expansion
@@ -1008,7 +1009,12 @@ enum languages { lang_c, lang_cplusplus, lang_java };
 #define PUBLICLY_UNIQUELY_DERIVED_P(PARENT, TYPE) \
   (lookup_base ((TYPE), (PARENT),  ba_not_special | ba_quiet, NULL) \
    != NULL_TREE)
-
+
+/* Gives the visibility specification for a class type.  */
+#define CLASSTYPE_VISIBILITY(TYPE)		DECL_VISIBILITY (TYPE_NAME (TYPE))
+#define CLASSTYPE_VISIBILITY_SPECIFIED(TYPE)	DECL_VISIBILITY_SPECIFIED (TYPE_NAME (TYPE))
+
+
 /* This is a few header flags for 'struct lang_type'.  Actually,
    all but the first are used only for lang_type_class; they
    are put in this structure to save space.  */
@@ -2064,6 +2070,10 @@ struct lang_decl GTY(())
   (DECL_CONTEXT (NODE) \
    && TREE_CODE (DECL_CONTEXT (NODE)) == FUNCTION_DECL)
 
+/* 1 iff VAR_DECL node NODE is a type-info decl.  This flag is set for
+   both the primary typeinfo object and the associated NTBS name.  */
+#define DECL_TINFO_P(NODE) TREE_LANG_FLAG_4 (VAR_DECL_CHECK (NODE))
+
 /* 1 iff VAR_DECL node NODE is virtual table or VTT.  */
 #define DECL_VTABLE_OR_VTT_P(NODE) TREE_LANG_FLAG_5 (VAR_DECL_CHECK (NODE))
 
@@ -2440,13 +2450,17 @@ struct lang_decl GTY(())
    When appearing in a SAVE_EXPR, it means that underneath
    is a call to a constructor.
 
-   When appearing in a CONSTRUCTOR, it means that it was
-   a GNU C constructor expression.
+   When appearing in a CONSTRUCTOR, the expression is a
+   compound literal.
 
    When appearing in a FIELD_DECL, it means that this field
    has been duly initialized in its constructor.  */
 #define TREE_HAS_CONSTRUCTOR(NODE) (TREE_LANG_FLAG_4 (NODE))
 
+/* True if NODE is a brace-enclosed initializer.  */
+#define BRACE_ENCLOSED_INITIALIZER_P(NODE) \
+  (TREE_CODE (NODE) == CONSTRUCTOR && !TREE_TYPE (NODE))
+
 #define EMPTY_CONSTRUCTOR_P(NODE) (TREE_CODE (NODE) == CONSTRUCTOR	   \
 				   && CONSTRUCTOR_ELTS (NODE) == NULL_TREE \
 				   && ! TREE_HAS_CONSTRUCTOR (NODE))
@@ -3669,7 +3683,7 @@ extern int init_type_desc			(void);
 extern tree check_tag_decl			(tree);
 extern tree shadow_tag				(tree);
 extern tree groktypename			(tree);
-extern tree start_decl				(tree, tree, int, tree, tree);
+extern tree start_decl				(tree, tree, int, tree, tree, bool *);
 extern void start_decl_1			(tree);
 extern void cp_finish_decl			(tree, tree, tree, int);
 extern void finish_decl				(tree, tree, tree);
@@ -3754,6 +3768,7 @@ extern tree finish_table (tree, tree, tree, int);
 extern tree coerce_new_type (tree);
 extern tree coerce_delete_type (tree);
 extern void comdat_linkage (tree);
+extern void determine_visibility (tree);
 extern void import_export_vtable (tree, tree, int);
 extern void import_export_decl (tree);
 extern void import_export_tinfo	(tree, tree, bool);
diff --git a/gcc/cp/decl.c b/gcc/cp/decl.c
index 451993e..20f1fc6 100644
--- a/gcc/cp/decl.c
+++ b/gcc/cp/decl.c
@@ -1886,17 +1886,20 @@ duplicate_decls (tree newdecl, tree olddecl)
   DECL_COMMON (newdecl) = DECL_COMMON (olddecl);
   COPY_DECL_ASSEMBLER_NAME (olddecl, newdecl);
 
-  /* If either declaration has a nondefault visibility, use it.  */
-  if (DECL_VISIBILITY (olddecl) != VISIBILITY_DEFAULT)
+  /* Warn about conflicting visibility specifications.  */
+  if (DECL_VISIBILITY_SPECIFIED (olddecl) 
+      && DECL_VISIBILITY_SPECIFIED (newdecl)
+      && DECL_VISIBILITY (newdecl) != DECL_VISIBILITY (olddecl))
+    {
+      warning ("%J'%D': visibility attribute ignored because it",
+	       newdecl, newdecl);
+      warning ("%Jconflicts with previous declaration here", olddecl);
+    }
+  /* Choose the declaration which specified visibility.  */
+  if (DECL_VISIBILITY_SPECIFIED (olddecl))
     {
-      if (DECL_VISIBILITY (newdecl) != VISIBILITY_DEFAULT
-	  && DECL_VISIBILITY (newdecl) != DECL_VISIBILITY (olddecl))
-	{
-	  warning ("%J'%D': visibility attribute ignored because it",
-		   newdecl, newdecl);
-	  warning ("%Jconflicts with previous declaration here", olddecl);
-	}
       DECL_VISIBILITY (newdecl) = DECL_VISIBILITY (olddecl);
+      DECL_VISIBILITY_SPECIFIED (newdecl) = 1;
     }
 
   if (TREE_CODE (newdecl) == FUNCTION_DECL)
@@ -3309,6 +3312,10 @@ build_library_fn_1 (tree name, enum tree_code operator_code, tree type)
   TREE_NOTHROW (fn) = 1;
   SET_OVERLOADED_OPERATOR_CODE (fn, operator_code);
   SET_DECL_LANGUAGE (fn, lang_c);
+  /* Runtime library routines are, by definition, available in an
+     external shared object.  */
+  DECL_VISIBILITY (fn) = VISIBILITY_DEFAULT;
+  DECL_VISIBILITY_SPECIFIED (fn) = 1;
   return fn;
 }
 
@@ -3672,7 +3679,8 @@ start_decl (tree declarator,
             tree declspecs, 
             int initialized, 
             tree attributes, 
-            tree prefix_attributes)
+            tree prefix_attributes,
+            bool *pop_scope_p)
 {
   tree decl;
   tree type, tem;
@@ -3708,14 +3716,11 @@ start_decl (tree declarator,
 
   context = DECL_CONTEXT (decl);
 
-  if (initialized && context && TREE_CODE (context) == NAMESPACE_DECL
-      && context != current_namespace && TREE_CODE (decl) == VAR_DECL)
-    {
-      /* When parsing the initializer, lookup should use the object's
-	 namespace.  */
-      push_decl_namespace (context);
-    }
-
+  if (context)
+    *pop_scope_p = push_scope (context);
+  else
+    *pop_scope_p = false;
+  
   /* We are only interested in class contexts, later.  */
   if (context && TREE_CODE (context) == NAMESPACE_DECL)
     context = NULL_TREE;
@@ -3771,8 +3776,6 @@ start_decl (tree declarator,
 
   if (context && COMPLETE_TYPE_P (complete_type (context)))
     {
-      push_nested_class (context);
-
       if (TREE_CODE (decl) == VAR_DECL)
 	{
 	  tree field = lookup_field (context, DECL_NAME (decl), 0, false);
@@ -4283,8 +4286,7 @@ reshape_init (tree type, tree *initp)
      enclosed elements.  Advance past the brace-enclosed initializer
      now.  */
   if (TREE_CODE (old_init_value) == CONSTRUCTOR
-      && TREE_TYPE (old_init_value) == NULL_TREE
-      && TREE_HAS_CONSTRUCTOR (old_init_value))
+      && BRACE_ENCLOSED_INITIALIZER_P (old_init_value))
     {
       *initp = TREE_CHAIN (old_init);
       TREE_CHAIN (old_init) = NULL_TREE;
@@ -4356,8 +4358,7 @@ reshape_init (tree type, tree *initp)
   else
     {
       /* Build a CONSTRUCTOR to hold the contents of the aggregate.  */  
-      new_init = build_constructor (type, NULL_TREE);
-      TREE_HAS_CONSTRUCTOR (new_init) = 1;
+      new_init = build_constructor (NULL_TREE, NULL_TREE);
 
       if (CLASS_TYPE_P (type))
 	{
@@ -4417,7 +4418,8 @@ reshape_init (tree type, tree *initp)
 		}
 	    }
 	}
-      else if ((TREE_CODE (type) == ARRAY_TYPE)|| (TREE_CODE (type) == VECTOR_TYPE))
+      else if (TREE_CODE (type) == ARRAY_TYPE
+	       || TREE_CODE (type) == VECTOR_TYPE)
 	{
 	  tree max_index;
 
@@ -4515,7 +4517,8 @@ check_initializer (tree decl, tree init, int flags, tree *cleanup)
     init = grok_reference_init (decl, type, init, cleanup);
   else if (init)
     {
-      if (TREE_CODE (init) == CONSTRUCTOR && TREE_HAS_CONSTRUCTOR (init))
+      if (TREE_CODE (init) == CONSTRUCTOR 
+	  && BRACE_ENCLOSED_INITIALIZER_P (init))
 	{
 	  /* [dcl.init] paragraph 13,
 	     If T is a scalar type, then a declaration of the form
@@ -4540,15 +4543,13 @@ check_initializer (tree decl, tree init, int flags, tree *cleanup)
 	 array size from the initializer.  */
       maybe_deduce_size_from_array_init (decl, init);
       type = TREE_TYPE (decl);
-      if (TREE_CODE (init) == CONSTRUCTOR && TREE_HAS_CONSTRUCTOR (init))
-	TREE_TYPE (init) = type;
 
       if (TYPE_HAS_CONSTRUCTOR (type) || TYPE_NEEDS_CONSTRUCTING (type))
 	{
 	  if (TREE_CODE (type) == ARRAY_TYPE)
 	    goto initialize_aggr;
 	  else if (TREE_CODE (init) == CONSTRUCTOR
-		   && TREE_HAS_CONSTRUCTOR (init))
+		   && BRACE_ENCLOSED_INITIALIZER_P (init))
 	    {
 	      if (TYPE_NON_AGGREGATE_CLASS (type))
 		{
@@ -4808,20 +4809,10 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)
       && (DECL_INITIAL (decl) || init))
     DECL_INITIALIZED_IN_CLASS_P (decl) = 1;
 
-  if (TREE_CODE (decl) == VAR_DECL
-      && DECL_CONTEXT (decl)
-      && TREE_CODE (DECL_CONTEXT (decl)) == NAMESPACE_DECL
-      && DECL_CONTEXT (decl) != current_namespace
-      && init)
-    {
-      /* Leave the namespace of the object.  */
-      pop_decl_namespace ();
-    }
-
   type = TREE_TYPE (decl);
 
   if (type == error_mark_node)
-    goto finish_end0;
+    goto finish_end;
 
   if (TYPE_HAS_MUTABLE_P (type))
     TREE_READONLY (decl) = 0;
@@ -4838,7 +4829,7 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)
 	  && !DECL_PRETTY_FUNCTION_P (decl)
 	  && !dependent_type_p (TREE_TYPE (decl)))
 	maybe_deduce_size_from_array_init (decl, init);
-      goto finish_end0;
+      goto finish_end;
     }
 
   /* Parameters are handled by store_parm_decls, not cp_finish_decl.  */
@@ -4941,6 +4932,9 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)
 	     the class specifier.  */
 	  if (!DECL_EXTERNAL (decl))
 	    var_definition_p = true;
+	  /* The variable is being defined, so determine its
+	     visibility.  */
+	  determine_visibility (decl);
 	}
       /* If the variable has an array type, lay out the type, even if
 	 there is no initializer.  It is valid to index through the
@@ -5026,26 +5020,6 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)
 	  if (var_definition_p && TREE_STATIC (decl))
 	    expand_static_init (decl, init); 
 	}
-    finish_end0:
-
-      /* Undo call to `pushclass' that was done in `start_decl'
-	 due to initialization of qualified member variable.
-	 I.e., Foo::x = 10;  */
-      {
-	tree context = CP_DECL_CONTEXT (decl);
-	if (context
-	    && TYPE_P (context)
-	    && (TREE_CODE (decl) == VAR_DECL
-		/* We also have a pushclass done that we need to undo here
-		   if we're at top level and declare a method.  */
-		|| TREE_CODE (decl) == FUNCTION_DECL)
-	    /* If size hasn't been set, we're still defining it,
-	       and therefore inside the class body; don't pop
-	       the binding level..  */
-	    && COMPLETE_TYPE_P (context)
-	    && context == current_class_type)
-	  pop_nested_class ();
-      }
     }
 
   /* If a CLEANUP_STMT was created to destroy a temporary bound to a
@@ -10260,6 +10234,9 @@ start_function (tree declspecs, tree declarator, tree attrs, int flags)
       && lookup_attribute ("noinline", attrs))
     warning ("%Jinline function '%D' given attribute noinline", decl1, decl1);
 
+  /* Determine the ELF visibility attribute for the function.  */
+  determine_visibility (decl1);
+
   if (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (decl1))
     /* This is a constructor, we must ensure that any default args
        introduced by this definition are propagated to the clones
diff --git a/gcc/cp/decl2.c b/gcc/cp/decl2.c
index abd86f7..9caecdd 100644
--- a/gcc/cp/decl2.c
+++ b/gcc/cp/decl2.c
@@ -1656,6 +1656,63 @@ maybe_emit_vtables (tree ctype)
   return true;
 }
 
+/* Determine the ELF symbol visibility for DECL.  */
+
+void
+determine_visibility (tree decl)
+{
+  tree class_type;
+
+  /* Cloned constructors and destructors get the same visibility as
+     the underlying function.  That should be set up in
+     maybe_clone_body.  */
+  if (DECL_CLONED_FUNCTION_P (decl))
+    return;
+
+  if (DECL_CLASS_SCOPE_P (decl))
+    class_type = DECL_CONTEXT (decl);
+  else if (TREE_CODE (decl) == VAR_DECL
+	   && DECL_TINFO_P (decl)
+	   && CLASS_TYPE_P (TREE_TYPE (DECL_NAME (decl))))
+    class_type = TREE_TYPE (DECL_NAME (decl));
+  else
+    {
+      /* Virtual tables have DECL_CONTEXT set to their associated class,
+	 so they are automatically handled above.  */
+      my_friendly_assert (!(TREE_CODE (decl) == VAR_DECL
+			    && DECL_VTABLE_OR_VTT_P (decl)), 20040803);
+      /* Entities not associated with any class just get the
+	 visibility specified by their attributes.  */
+      return;
+    }
+
+  /* By default, static data members and function members receive
+     the visibility of their containing class.  */
+  if (class_type
+      && (TREE_CODE (decl) == VAR_DECL 
+	  || TREE_CODE (decl) == FUNCTION_DECL)
+      && !lookup_attribute ("visibility", DECL_ATTRIBUTES (decl)))
+    {
+      if (TREE_CODE (decl) == FUNCTION_DECL
+	  && DECL_DECLARED_INLINE_P (decl)
+	  && visibility_options.inlines_hidden)
+	{
+	  /* Don't change it if it has been set explicitly by user.  */
+	  if (!DECL_VISIBILITY_SPECIFIED (decl))
+	    {
+	      DECL_VISIBILITY (decl) = VISIBILITY_HIDDEN;
+	      DECL_VISIBILITY_SPECIFIED (decl) = 1;
+	    }
+	}
+      else
+	{
+	  DECL_VISIBILITY (decl) = CLASSTYPE_VISIBILITY (class_type);
+	  DECL_VISIBILITY_SPECIFIED (decl)
+	    = CLASSTYPE_VISIBILITY_SPECIFIED (class_type);
+	}
+    }
+}
+
 /* Determines the proper settings of TREE_PUBLIC and DECL_EXTERNAL for an
    inline function or template instantiation at end-of-file.  */
 
diff --git a/gcc/cp/init.c b/gcc/cp/init.c
index 4e3cd4b..618d618 100644
--- a/gcc/cp/init.c
+++ b/gcc/cp/init.c
@@ -341,8 +341,7 @@ perform_member_init (tree member, tree init)
 	  finish_expr_stmt (init);
 	}
     }
-  else if (TYPE_NEEDS_CONSTRUCTING (type)
-	   || (init && TYPE_HAS_CONSTRUCTOR (type)))
+  else if (TYPE_NEEDS_CONSTRUCTING (type))
     {
       if (explicit
 	  && TREE_CODE (type) == ARRAY_TYPE
@@ -1092,34 +1091,24 @@ build_aggr_init (tree exp, tree init, int flags)
 
   if (TREE_CODE (type) == ARRAY_TYPE)
     {
-      /* Must arrange to initialize each element of EXP
-	 from elements of INIT.  */
-      tree itype = init ? TREE_TYPE (init) : NULL_TREE;
-      
-      if (init && !itype)
+      tree itype;
+      /* An array may not be initialized use the parenthesized
+	 initialization form -- unless the initializer is "()".  */
+      if (init && TREE_CODE (init) == TREE_LIST)
 	{
-	  /* Handle bad initializers like:
-	     class COMPLEX {
-	     public:
-	       double re, im;
-	       COMPLEX(double r = 0.0, double i = 0.0) {re = r; im = i;};
-	       ~COMPLEX() {};
-	     };
-
-	     int main(int argc, char **argv) {
-	       COMPLEX zees(1.0, 0.0)[10];
-	     }
-	  */
 	  error ("bad array initializer");
 	  return error_mark_node;
 	}
+      /* Must arrange to initialize each element of EXP
+	 from elements of INIT.  */
+      itype = init ? TREE_TYPE (init) : NULL_TREE;
       if (cp_type_quals (type) != TYPE_UNQUALIFIED)
 	TREE_TYPE (exp) = TYPE_MAIN_VARIANT (type);
       if (itype && cp_type_quals (itype) != TYPE_UNQUALIFIED)
-	TREE_TYPE (init) = TYPE_MAIN_VARIANT (itype);
+	itype = TREE_TYPE (init) = TYPE_MAIN_VARIANT (itype);
       stmt_expr = build_vec_init (exp, NULL_TREE, init,
-				  init && same_type_p (TREE_TYPE (init),
-						       TREE_TYPE (exp)));
+				  itype && same_type_p (itype,
+							TREE_TYPE (exp)));
       TREE_READONLY (exp) = was_const;
       TREE_THIS_VOLATILE (exp) = was_volatile;
       TREE_TYPE (exp) = type;
@@ -1195,8 +1184,7 @@ expand_default_init (tree binfo, tree true_exp, tree exp, tree init, int flags)
 	   to run a new constructor; and catching an exception, where we
 	   have already built up the constructor call so we could wrap it
 	   in an exception region.  */;
-      else if (TREE_CODE (init) == CONSTRUCTOR 
-	       && TREE_HAS_CONSTRUCTOR (init))
+      else if (BRACE_ENCLOSED_INITIALIZER_P (init))
 	{
 	  /* A brace-enclosed initializer for an aggregate.  */
 	  my_friendly_assert (CP_AGGREGATE_TYPE_P (type), 20021016);
diff --git a/gcc/cp/method.c b/gcc/cp/method.c
index 9f3e72e..174b731 100644
--- a/gcc/cp/method.c
+++ b/gcc/cp/method.c
@@ -398,6 +398,8 @@ use_thunk (tree thunk_fndecl, bool emit_p)
      rewrite.  */
   TREE_PUBLIC (thunk_fndecl) = TREE_PUBLIC (function);
   DECL_VISIBILITY (thunk_fndecl) = DECL_VISIBILITY (function);
+  DECL_VISIBILITY_SPECIFIED (thunk_fndecl)
+    = DECL_VISIBILITY_SPECIFIED (function);
 
   if (flag_syntax_only)
     {
diff --git a/gcc/cp/optimize.c b/gcc/cp/optimize.c
index 5ada131..387fcb4 100644
--- a/gcc/cp/optimize.c
+++ b/gcc/cp/optimize.c
@@ -155,6 +155,7 @@ maybe_clone_body (tree fn)
       DECL_NOT_REALLY_EXTERN (clone) = DECL_NOT_REALLY_EXTERN (fn);
       TREE_PUBLIC (clone) = TREE_PUBLIC (fn);
       DECL_VISIBILITY (clone) = DECL_VISIBILITY (fn);
+      DECL_VISIBILITY_SPECIFIED (clone) = DECL_VISIBILITY_SPECIFIED (fn);
 
       /* Adjust the parameter names and locations.  */
       parm = DECL_ARGUMENTS (fn);
diff --git a/gcc/cp/parser.c b/gcc/cp/parser.c
index 032cbd7..0eb4bf7 100644
--- a/gcc/cp/parser.c
+++ b/gcc/cp/parser.c
@@ -5855,10 +5855,13 @@ cp_parser_condition (cp_parser* parser)
 	 for sure.  */
       if (cp_parser_parse_definitely (parser))
 	{
+	  bool pop_p;
+
 	  /* Create the declaration.  */
 	  decl = start_decl (declarator, type_specifiers, 
 			     /*initialized_p=*/true,
-			     attributes, /*prefix_attributes=*/NULL_TREE);
+			     attributes, /*prefix_attributes=*/NULL_TREE,
+			     &pop_p);
 	  /* Parse the assignment-expression.  */
 	  initializer = cp_parser_assignment_expression (parser);
 	  
@@ -5867,7 +5870,9 @@ cp_parser_condition (cp_parser* parser)
 			  initializer, 
 			  asm_specification, 
 			  LOOKUP_ONLYCONVERTING);
-	  
+	  if (pop_p)
+	    pop_scope (DECL_CONTEXT (decl));
+
 	  return convert_from_reference (decl);
 	}
     }
@@ -10105,12 +10110,12 @@ cp_parser_init_declarator (cp_parser* parser,
 	  have_extern_spec = false;
 	}
       decl = start_decl (declarator, decl_specifiers,
-			 is_initialized, attributes, prefix_attributes);
+			 is_initialized, attributes, prefix_attributes,
+			 &pop_p);
     }
-
-  /* Enter the SCOPE.  That way unqualified names appearing in the
-     initializer will be looked up in SCOPE.  */
-  if (scope)
+  else if (scope)
+    /* Enter the SCOPE.  That way unqualified names appearing in the
+       initializer will be looked up in SCOPE.  */
     pop_p = push_scope (scope);
 
   /* Perform deferred access control checks, now that we know in which
@@ -10157,17 +10162,13 @@ cp_parser_init_declarator (cp_parser* parser,
     if (cp_parser_attributes_opt (parser))
       warning ("attributes after parenthesized initializer ignored");
 
-  /* Leave the SCOPE, now that we have processed the initializer.  It
-     is important to do this before calling cp_finish_decl because it
-     makes decisions about whether to create DECL_STMTs or not based
-     on the current scope.  */
-  if (pop_p)
-    pop_scope (scope);
-
   /* For an in-class declaration, use `grokfield' to create the
      declaration.  */
   if (member_p)
     {
+      if (pop_p)
+	pop_scope (scope);
+
       decl = grokfield (declarator, decl_specifiers,
 			initializer, /*asmspec=*/NULL_TREE,
 			/*attributes=*/NULL_TREE);
@@ -10178,15 +10179,19 @@ cp_parser_init_declarator (cp_parser* parser,
   /* Finish processing the declaration.  But, skip friend
      declarations.  */
   if (!friend_p && decl)
-    cp_finish_decl (decl, 
-		    initializer, 
-		    asm_specification,
-		    /* If the initializer is in parentheses, then this is
-		       a direct-initialization, which means that an
-		       `explicit' constructor is OK.  Otherwise, an
-		       `explicit' constructor cannot be used.  */
-		    ((is_parenthesized_init || !is_initialized)
-		     ? 0 : LOOKUP_ONLYCONVERTING));
+    {
+      cp_finish_decl (decl, 
+		      initializer, 
+		      asm_specification,
+		      /* If the initializer is in parentheses, then this is
+			 a direct-initialization, which means that an
+			 `explicit' constructor is OK.  Otherwise, an
+			 `explicit' constructor cannot be used.  */
+		      ((is_parenthesized_init || !is_initialized)
+		       ? 0 : LOOKUP_ONLYCONVERTING));
+      if (pop_p)
+	pop_scope (DECL_CONTEXT (decl));
+    }
 
   /* Remember whether or not variables were initialized by
      constant-expressions.  */
@@ -11610,10 +11615,6 @@ cp_parser_initializer_clause (cp_parser* parser, bool* non_constant_p)
       cp_lexer_consume_token (parser->lexer);
       /* Create a CONSTRUCTOR to represent the braced-initializer.  */
       initializer = make_node (CONSTRUCTOR);
-      /* Mark it with TREE_HAS_CONSTRUCTOR.  This should not be
-	 necessary, but check_initializer depends upon it, for 
-	 now.  */
-      TREE_HAS_CONSTRUCTOR (initializer) = 1;
       /* If it's not a `}', then there is a non-trivial initializer.  */
       if (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_BRACE))
 	{
diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
index 0ae2d23..fe56691 100644
--- a/gcc/cp/pt.c
+++ b/gcc/cp/pt.c
@@ -11297,20 +11297,13 @@ instantiate_decl (tree d, int defer_ok)
 	}
       else
 	{
-	  /* This is done in analogous to `start_decl'.  It is
-	     required for correct access checking.  */
+	  /* Enter the scope of D so that access-checking works correctly.  */
 	  push_nested_class (DECL_CONTEXT (d));
 	  cp_finish_decl (d, 
 			  (!DECL_INITIALIZED_IN_CLASS_P (d) 
 			   ? DECL_INITIAL (d) : NULL_TREE),
 			  NULL_TREE, 0);
-	  /* Normally, pop_nested_class is called by cp_finish_decl
-	     above.  But when instantiate_decl is triggered during
-	     instantiate_class_template processing, its DECL_CONTEXT
-	     is still not completed yet, and pop_nested_class isn't
-	     called.  */
-	  if (!COMPLETE_TYPE_P (DECL_CONTEXT (d)))
-	    pop_nested_class ();
+	  pop_nested_class ();
 	}
       /* We're not deferring instantiation any more.  */
       TI_PENDING_TEMPLATE_FLAG (DECL_TEMPLATE_INFO (d)) = 0;
diff --git a/gcc/cp/rtti.c b/gcc/cp/rtti.c
index e9c0616..1f903f5 100644
--- a/gcc/cp/rtti.c
+++ b/gcc/cp/rtti.c
@@ -354,17 +354,16 @@ get_tinfo_decl (tree type)
       TREE_READONLY (d) = 1;
       TREE_STATIC (d) = 1;
       DECL_EXTERNAL (d) = 1;
+      DECL_TINFO_P (d) = 1;
       DECL_COMDAT (d) = 1;
       TREE_PUBLIC (d) = 1;
       SET_DECL_ASSEMBLER_NAME (d, name);
-
-      pushdecl_top_level_and_finish (d, NULL_TREE);
-
+      /* Remember the type it is for.  */
+      TREE_TYPE (name) = type;
       if (CLASS_TYPE_P (type))
 	CLASSTYPE_TYPEINFO_VAR (TYPE_MAIN_VARIANT (type)) = d;
 
-      /* Remember the type it is for.  */
-      TREE_TYPE (name) = type;
+      pushdecl_top_level_and_finish (d, NULL_TREE);
 
       /* Add decl to the global array of tinfo decls.  */
       my_friendly_assert (unemitted_tinfo_decls != 0, 20030312);
@@ -751,19 +750,20 @@ tinfo_base_init (tree desc, tree target)
                      NULL_TREE);
     tree name_string = tinfo_name (target);
 
+    /* Determine the name of the variable -- and remember with which
+       type it is associated.  */
     name_name = mangle_typeinfo_string_for_type (target);
+    TREE_TYPE (name_name) = target;
+
     name_decl = build_lang_decl (VAR_DECL, name_name, name_type);
-    
+    SET_DECL_ASSEMBLER_NAME (name_decl, name_name);
     DECL_ARTIFICIAL (name_decl) = 1;
     TREE_READONLY (name_decl) = 1;
     TREE_STATIC (name_decl) = 1;
     DECL_EXTERNAL (name_decl) = 0;
+    DECL_TINFO_P (name_decl) = 1;
     TREE_PUBLIC (name_decl) = 1;
     import_export_tinfo (name_decl, target, typeinfo_in_lib_p (target));
-    /* External name of the string containing the type's name has a
-       special name.  */
-    SET_DECL_ASSEMBLER_NAME (name_decl,
-			     mangle_typeinfo_string_for_type (target));
     DECL_INITIAL (name_decl) = name_string;
     mark_used (name_decl);
     pushdecl_top_level_and_finish (name_decl, name_string);
@@ -807,7 +807,7 @@ tinfo_base_init (tree desc, tree target)
   init = tree_cons (NULL_TREE, decay_conversion (name_decl), init);
   
   init = build_constructor (NULL_TREE, nreverse (init));
-  TREE_HAS_CONSTRUCTOR (init) = TREE_CONSTANT (init) = TREE_STATIC (init) = 1;
+  TREE_CONSTANT (init) = TREE_STATIC (init) = 1;
   init = tree_cons (NULL_TREE, init, NULL_TREE);
   
   return init;
@@ -823,7 +823,7 @@ generic_initializer (tree desc, tree target)
   tree init = tinfo_base_init (desc, target);
   
   init = build_constructor (NULL_TREE, init);
-  TREE_HAS_CONSTRUCTOR (init) = TREE_CONSTANT (init) = TREE_STATIC (init) = 1;
+  TREE_CONSTANT (init) = TREE_STATIC (init) = 1;
   return init;
 }
 
@@ -850,7 +850,7 @@ ptr_initializer (tree desc, tree target, bool *non_public_ptr)
                     init);
   
   init = build_constructor (NULL_TREE, nreverse (init));
-  TREE_HAS_CONSTRUCTOR (init) = TREE_CONSTANT (init) = TREE_STATIC (init) = 1;
+  TREE_CONSTANT (init) = TREE_STATIC (init) = 1;
   return init;
 }
 
@@ -887,7 +887,7 @@ ptm_initializer (tree desc, tree target, bool *non_public_ptr)
 		    init);  
   
   init = build_constructor (NULL_TREE, nreverse (init));
-  TREE_HAS_CONSTRUCTOR (init) = TREE_CONSTANT (init) = TREE_STATIC (init) = 1;
+  TREE_CONSTANT (init) = TREE_STATIC (init) = 1;
   return init;  
 }
 
@@ -955,7 +955,7 @@ class_initializer (tree desc, tree target, tree trail)
   
   TREE_CHAIN (init) = trail;
   init = build_constructor (NULL_TREE, init);
-  TREE_HAS_CONSTRUCTOR (init) = TREE_CONSTANT (init) = TREE_STATIC (init) = 1;
+  TREE_CONSTANT (init) = TREE_STATIC (init) = 1;
   return init;  
 }
 
@@ -1072,11 +1072,9 @@ get_pseudo_ti_init (tree type, tree var_desc, bool *non_public_p)
               base_init = tree_cons (NULL_TREE, offset, base_init);
               base_init = tree_cons (NULL_TREE, tinfo, base_init);
               base_init = build_constructor (NULL_TREE, base_init);
-	      TREE_HAS_CONSTRUCTOR (base_init) = 1;
               base_inits = tree_cons (NULL_TREE, base_init, base_inits);
             }
 	  base_inits = build_constructor (NULL_TREE, base_inits);
-	  TREE_HAS_CONSTRUCTOR (base_inits) = 1;
 	  base_inits = tree_cons (NULL_TREE, base_inits, NULL_TREE);
 	  /* Prepend the number of bases.  */
 	  base_inits = tree_cons (NULL_TREE,
diff --git a/gcc/cp/typeck.c b/gcc/cp/typeck.c
index b13fb85..f93322a 100644
--- a/gcc/cp/typeck.c
+++ b/gcc/cp/typeck.c
@@ -1948,12 +1948,6 @@ finish_class_member_access_expr (tree object, tree name)
 	     or a BIT_NOT_EXPR.  */
 	  scope = TREE_OPERAND (name, 0);
 	  name = TREE_OPERAND (name, 1);
-	  my_friendly_assert ((CLASS_TYPE_P (scope) 
-			       || TREE_CODE (scope) == NAMESPACE_DECL),
-			      20020804);
-	  my_friendly_assert ((TREE_CODE (name) == IDENTIFIER_NODE
-			       || TREE_CODE (name) == BIT_NOT_EXPR),
-			      20020804);
 
 	  /* If SCOPE is a namespace, then the qualified name does not
 	     name a member of OBJECT_TYPE.  */
@@ -1964,6 +1958,10 @@ finish_class_member_access_expr (tree object, tree name)
 	      return error_mark_node;
 	    }
 
+	  my_friendly_assert (CLASS_TYPE_P (scope), 20020804);
+	  my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE
+		      || TREE_CODE (name) == BIT_NOT_EXPR, 20020804);
+
 	  /* Find the base of OBJECT_TYPE corresponding to SCOPE.  */
 	  access_path = lookup_base (object_type, scope, ba_check, NULL);
 	  if (access_path == error_mark_node)
diff --git a/gcc/cp/typeck2.c b/gcc/cp/typeck2.c
index 780c3e7..e305782 100644
--- a/gcc/cp/typeck2.c
+++ b/gcc/cp/typeck2.c
@@ -479,8 +479,6 @@ digest_init (tree type, tree init, tree* tail)
   enum tree_code code = TREE_CODE (type);
   tree element = NULL_TREE;
   tree old_tail_contents = NULL_TREE;
-  /* Nonzero if INIT is a braced grouping.  */
-  int raw_constructor;
 
   /* By default, assume we use one element from a list.
      We correct this later in the sole case where it is not true.  */
@@ -510,10 +508,7 @@ digest_init (tree type, tree init, tree* tail)
   if (TREE_CODE (init) == NON_LVALUE_EXPR)
     init = TREE_OPERAND (init, 0);
 
-  raw_constructor = (TREE_CODE (init) == CONSTRUCTOR 
-		     && TREE_HAS_CONSTRUCTOR (init));
-
-  if (raw_constructor
+  if (BRACE_ENCLOSED_INITIALIZER_P (init)
       && CONSTRUCTOR_ELTS (init) != 0
       && TREE_CHAIN (CONSTRUCTOR_ELTS (init)) == 0)
     {
@@ -585,7 +580,7 @@ digest_init (tree type, tree init, tree* tail)
       || code == BOOLEAN_TYPE || code == COMPLEX_TYPE
       || TYPE_PTR_TO_MEMBER_P (type))
     {
-      if (raw_constructor)
+      if (BRACE_ENCLOSED_INITIALIZER_P (init))
 	{
 	  if (element == 0)
 	    {
@@ -594,7 +589,7 @@ digest_init (tree type, tree init, tree* tail)
 	    }
 	  init = element;
 	}
-      while (TREE_CODE (init) == CONSTRUCTOR && TREE_HAS_CONSTRUCTOR (init))
+      while (BRACE_ENCLOSED_INITIALIZER_P (init))
 	{
 	  pedwarn ("braces around scalar initializer for `%T'", type);
 	  init = CONSTRUCTOR_ELTS (init);
@@ -618,15 +613,16 @@ digest_init (tree type, tree init, tree* tail)
 
   if (code == ARRAY_TYPE || code == VECTOR_TYPE || IS_AGGR_TYPE_CODE (code))
     {
-      if (raw_constructor && TYPE_NON_AGGREGATE_CLASS (type)
-	  && TREE_HAS_CONSTRUCTOR (init))
+      if (BRACE_ENCLOSED_INITIALIZER_P (init))
 	{
-	  error ("subobject of type `%T' must be initialized by constructor, not by `%E'",
-		    type, init);
-	  return error_mark_node;
+	  if (TYPE_NON_AGGREGATE_CLASS (type))
+	    {
+	      error ("subobject of type `%T' must be initialized by constructor, not by `%E'",
+		     type, init);
+	      return error_mark_node;
+	    }
+	  return process_init_constructor (type, init, (tree *)0);
 	}
-      else if (raw_constructor)
-	return process_init_constructor (type, init, (tree *)0);
       else if (can_convert_arg (type, TREE_TYPE (init), init)
 	       || TYPE_NON_AGGREGATE_CLASS (type))
 	/* These are never initialized from multiple constructor elements.  */;
@@ -868,7 +864,7 @@ process_init_constructor (tree type, tree init, tree* elts)
 
 	      /* Warn when some struct elements are implicitly initialized.  */
 	      if (extra_warnings
-	          && (!init || TREE_HAS_CONSTRUCTOR (init)))
+	          && (!init || BRACE_ENCLOSED_INITIALIZER_P (init)))
 		warning ("missing initializer for member `%D'", field);
 	    }
 	  else
@@ -884,7 +880,7 @@ process_init_constructor (tree type, tree init, tree* elts)
 	      /* Warn when some struct elements are implicitly initialized
 		 to zero.  */
 	      if (extra_warnings
-	          && (!init || TREE_HAS_CONSTRUCTOR (init)))
+	          && (!init || BRACE_ENCLOSED_INITIALIZER_P (init)))
 		warning ("missing initializer for member `%D'", field);
 
 	      if (! zero_init_p (TREE_TYPE (field)))
diff --git a/gcc/diagnostic.c b/gcc/diagnostic.c
index c29867a..ac553e3 100644
--- a/gcc/diagnostic.c
+++ b/gcc/diagnostic.c
@@ -272,14 +272,14 @@ diagnostic_action_after_output (diagnostic_context *context,
 	real_abort ();
 
       fnotice (stderr, bug_report_request, bug_report_url);
-      exit (FATAL_EXIT_CODE);
+      exit (ICE_EXIT_CODE);
 
     case DK_FATAL:
       if (context->abort_on_error)
 	real_abort ();
 
       fnotice (stderr, "compilation terminated.\n");
-      exit (FATAL_EXIT_CODE);
+      exit (ICE_EXIT_CODE);
 
     default:
       real_abort ();
@@ -571,7 +571,7 @@ error_recursion (diagnostic_context *context)
   fnotice (stderr,
 	   "Internal compiler error: Error reporting routines re-entered.\n");
   fnotice (stderr, bug_report_request, bug_report_url);
-  exit (FATAL_EXIT_CODE);
+  exit (ICE_EXIT_CODE);
 }
 
 /* Report an internal compiler error in a friendly manner.  This is
diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
index e683d0c..fb9273f 100644
--- a/gcc/doc/invoke.texi
+++ b/gcc/doc/invoke.texi
@@ -183,7 +183,8 @@ in the following sections.
 -fno-optional-diags  -fpermissive @gol
 -frepo  -fno-rtti  -fstats  -ftemplate-depth-@var{n} @gol
 -fuse-cxa-atexit  -fno-weak  -nostdinc++ @gol
--fno-default-inline  -Wabi  -Wctor-dtor-privacy @gol
+-fno-default-inline  -fvisibility-inlines-hidden @gol
+-Wabi  -Wctor-dtor-privacy @gol
 -Wnon-virtual-dtor  -Wreorder @gol
 -Weffc++  -Wno-deprecated @gol
 -Wno-non-template-friend  -Wold-style-cast @gol
@@ -678,7 +679,8 @@ in the following sections.
 -fargument-alias  -fargument-noalias @gol
 -fargument-noalias-global  -fleading-underscore @gol
 -ftls-model=@var{model} @gol
--ftrapv  -fwrapv  -fbounds-check}
+-ftrapv  -fwrapv  -fbounds-check @gol
+-fvisibility}
 @end table
 
 @menu
@@ -1437,6 +1439,20 @@ This option is required for fully standards-compliant handling of static
 destructors, but will only work if your C library supports
 @code{__cxa_atexit}.
 
+@item -fvisibility-inlines-hidden
+@opindex fvisibility-inlines-hidden
+Causes all inlined methods to be marked with
+@code{__attribute__ ((visibility ("hidden")))} so that they do not
+appear in the export table of a DSO and do not require a PLT indirection
+when used within the DSO. Enabling this option can have a dramatic effect
+on load and link times of a DSO as it massively reduces the size of the
+dynamic export table when the library makes heavy use of templates. While
+it can cause bloating through duplication of code within each DSO where
+it is used, often the wastage is less than the considerable space occupied
+by a long symbol name in the export table which is typical when using
+templates and namespaces. For even more savings, combine with the
+@code{-fvisibility=hidden} switch.
+
 @item -fno-weak
 @opindex fno-weak
 Do not use weak symbol support, even if it is provided by the linker.
@@ -11273,6 +11289,54 @@ The @var{model} argument should be one of @code{global-dynamic},
 
 The default without @option{-fpic} is @code{initial-exec}; with
 @option{-fpic} the default is @code{global-dynamic}.
+
+@item -fvisibility=@var{default|internal|hidden|protected}
+@opindex fvisibility
+Set the default ELF image symbol visibility to the specified option - all
+symbols will be marked with this unless overrided within the code.
+Using this feature can very substantially improve linking and
+load times of shared object libraries, produce more optimised
+code, provide near-perfect API export and prevent symbol clashes.
+It is @strong{strongly} recommended that you use this in any shared objects
+you distribute.
+     
+Despite the nomenclature, @code{default} always means public ie;
+available to be linked against from outside the shared object.
+@code{protected} and @code{internal} are pretty useless in real-world
+usage so the only other commonly used option will be @code{hidden}.
+The default if -fvisibility isn't specified is @code{default} ie; make every
+symbol public - this causes the same behaviour as previous versions of
+GCC.
+     
+A good explanation of the benefits offered by ensuring ELF
+symbols have the correct visibility is given by ``How To Write
+Shared Libraries'' by Ulrich Drepper (which can be found at
+@w{@uref{http://people.redhat.com/~drepper/}}) - however a superior
+solution made possible by this option to marking things hidden when
+the default is public is to make the default hidden and mark things
+public. This is the norm with DLL's on Windows and with @option{-fvisibility=hidden}
+and @code{__attribute__ ((visibility("default")))} instead of
+@code{__declspec(dllexport)} you get almost identical semantics with
+identical syntax. This is a great boon to those working with
+cross-platform projects.
+
+For those adding visibility support to existing code, you may find
+@samp{#pragma GCC visibility} of use. This works by you enclosing
+the declarations you wish to set visibility for with (for example)
+@samp{#pragma GCC visibility push(hidden)} and
+@samp{#pragma GCC visibility pop}. These can be nested up to sixteen
+times. Bear in mind that symbol visibility should be viewed @strong{as
+part of the API interface contract} and thus all new code should
+always specify visibility when it is not the default ie; declarations
+only for use within the local DSO should @strong{always} be marked explicitly
+as hidden as so to avoid PLT indirection overheads - making this
+abundantly clear also aids readability and self-documentation of the code.
+Note that due to ISO C++ specification requirements, operator new and
+operator delete must always be of default visibility.
+
+An overview of these techniques, their benefits and how to use them
+is at @w{@uref{http://www.nedprod.com/programs/gccvisibility.html}}.
+
 @end table
 
 @c man end
diff --git a/gcc/final.c b/gcc/final.c
index dd5b64e..3ab428b 100644
--- a/gcc/final.c
+++ b/gcc/final.c
@@ -1881,7 +1881,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,
 		{
 		  int log_align;
 
-		  readonly_data_section ();
+		  function_readonly_data_section (current_function_decl);
 
 #ifdef ADDR_VEC_ALIGN
 		  log_align = ADDR_VEC_ALIGN (NEXT_INSN (insn));
diff --git a/gcc/flags.h b/gcc/flags.h
index e947f2a..eed69a4 100644
--- a/gcc/flags.h
+++ b/gcc/flags.h
@@ -60,6 +60,30 @@ extern bool use_gnu_debug_info_extensions;
 /* Nonzero means emit debugging information only for symbols which are used.  */
 extern int flag_debug_only_used_symbols;
 
+/* Enumerate visibility settings.  */
+#ifndef SYMBOL_VISIBILITY_DEFINED
+#define SYMBOL_VISIBILITY_DEFINED
+enum symbol_visibility
+{
+  VISIBILITY_DEFAULT,
+  VISIBILITY_INTERNAL,
+  VISIBILITY_HIDDEN,
+  VISIBILITY_PROTECTED
+};
+#endif
+
+/* The default visibility for all symbols (unless overridden).  */
+extern enum symbol_visibility default_visibility;
+
+struct visibility_flags
+{
+  unsigned inpragma : 1;	/* True when in #pragma GCC visibility.  */
+  unsigned inlines_hidden : 1;	/* True when -finlineshidden in effect.  */
+};
+
+/* Global visibility options.  */
+extern struct visibility_flags visibility_options;
+
 /* Nonzero means do optimizations.  -opt.  */
 
 extern int optimize;
diff --git a/gcc/flow.c b/gcc/flow.c
index 9f1e1b7..a1b445e 100644
--- a/gcc/flow.c
+++ b/gcc/flow.c
@@ -1884,6 +1884,7 @@ init_propagate_block_info (basic_block bb, regset live, regset local_set,
 	  rtx set_src = SET_SRC (pc_set (BB_END (bb)));
 	  rtx cond_true = XEXP (set_src, 0);
 	  rtx reg = XEXP (cond_true, 0);
+ 	  enum rtx_code inv_cond;
 
 	  if (GET_CODE (reg) == SUBREG)
 	    reg = SUBREG_REG (reg);
@@ -1892,11 +1893,13 @@ init_propagate_block_info (basic_block bb, regset live, regset local_set,
 	     in the form of a comparison of a register against zero.  
 	     If the condition is more complex than that, then it is safe
 	     not to record any information.  */
-	  if (GET_CODE (reg) == REG
+ 	  inv_cond = reversed_comparison_code (cond_true, BB_END (bb));
+ 	  if (inv_cond != UNKNOWN
+	      && GET_CODE (reg) == REG
 	      && XEXP (cond_true, 1) == const0_rtx)
 	    {
 	      rtx cond_false
-		= gen_rtx_fmt_ee (reverse_condition (GET_CODE (cond_true)),
+		= gen_rtx_fmt_ee (inv_cond,
 				  GET_MODE (cond_true), XEXP (cond_true, 0),
 				  XEXP (cond_true, 1));
 	      if (GET_CODE (XEXP (set_src, 1)) == PC)
diff --git a/gcc/gcc.c b/gcc/gcc.c
index ee380ed..997c37c 100644
--- a/gcc/gcc.c
+++ b/gcc/gcc.c
@@ -354,6 +354,9 @@ static void init_gcc_specs (struct obstack *, const char *, const char *,
 #if defined(HAVE_TARGET_OBJECT_SUFFIX) || defined(HAVE_TARGET_EXECUTABLE_SUFFIX)
 static const char *convert_filename (const char *, int, int);
 #endif
+#if !(defined (__MSDOS__) || defined (OS2) || defined (VMS) || defined (WIN32))
+static void retry_ice (const char *prog, const char **argv);
+#endif
 
 static const char *if_exists_spec_function (int, const char **);
 static const char *if_exists_else_spec_function (int, const char **);
@@ -2770,7 +2773,7 @@ execute (void)
       if (commands[i].pid == -1)
 	pfatal_pexecute (errmsg_fmt, errmsg_arg);
 
-      if (string != commands[i].prog)
+      if (i && string != commands[i].prog)
 	free ((void *) string);
     }
 
@@ -2848,6 +2851,18 @@ See %s for instructions.",
 	      else if (WIFEXITED (status)
 		       && WEXITSTATUS (status) >= MIN_FATAL_STATUS)
 		{
+#if !(defined (__MSDOS__) || defined (OS2) || defined (VMS) || defined (WIN32))
+		  /* For ICEs in cc1, cc1obj, cc1plus see if it is
+		     reproducible or not.  */
+		  char *p;
+		  if (getenv("GCC_RETRY_ICE") == NULL
+		      && WEXITSTATUS (status) == ICE_EXIT_CODE
+		      && j == 0
+		      && (p = strrchr (commands[j].argv[0], DIR_SEPARATOR))
+		      && ! strncmp (p + 1, "cc1", 3))
+		    retry_ice (commands[j].prog, commands[j].argv);
+#endif
+
 		  if (WEXITSTATUS (status) > greatest_status)
 		    greatest_status = WEXITSTATUS (status);
 		  ret_code = -1;
@@ -2859,6 +2874,10 @@ See %s for instructions.",
 	      break;
 	    }
       }
+
+    if (commands[0].argv[0] != commands[0].prog)
+      free ((PTR) commands[0].argv[0]);
+
     return ret_code;
   }
 }
@@ -5796,6 +5815,224 @@ give_switch (int switchnum, int omit_first_word)
   switches[switchnum].validated = 1;
 }
 
+#if !(defined (__MSDOS__) || defined (OS2) || defined (VMS) || defined (WIN32))
+#define RETRY_ICE_ATTEMPTS 2
+
+static void
+retry_ice (const char *prog, const char **argv)
+{
+  int nargs, out_arg = -1, quiet = 0, attempt;
+  int pid, retries, sleep_interval;
+  const char **new_argv;
+  char *temp_filenames[RETRY_ICE_ATTEMPTS * 2 + 2];
+
+  if (input_filename == NULL || ! strcmp (input_filename, "-"))
+    return;
+
+  for (nargs = 0; argv[nargs] != NULL; ++nargs)
+    /* Only retry compiler ICEs, not preprocessor ones.  */
+    if (! strcmp (argv[nargs], "-E"))
+      return;
+    else if (argv[nargs][0] == '-' && argv[nargs][1] == 'o')
+      {
+	if (out_arg == -1)
+	  out_arg = nargs;
+	else
+	  return;
+      }
+    /* If the compiler is going to output any time information,
+       it might varry between invocations.  */
+    else if (! strcmp (argv[nargs], "-quiet"))
+      quiet = 1;
+    else if (! strcmp (argv[nargs], "-ftime-report"))
+      return;
+
+  if (out_arg == -1 || !quiet)
+    return;
+
+  memset (temp_filenames, '\0', sizeof (temp_filenames));
+  new_argv = alloca ((nargs + 3) * sizeof (const char *));
+  memcpy (new_argv, argv, (nargs + 1) * sizeof (const char *));
+  new_argv[nargs++] = "-frandom-seed=0";
+  new_argv[nargs] = NULL;
+  if (new_argv[out_arg][2] == '\0')
+    new_argv[out_arg + 1] = "-";
+  else
+    new_argv[out_arg] = "-o-";
+
+  for (attempt = 0; attempt < RETRY_ICE_ATTEMPTS + 1; ++attempt)
+    {
+      int fd;
+      int status;
+
+      temp_filenames[attempt * 2] = make_temp_file (".out");
+      temp_filenames[attempt * 2 + 1] = make_temp_file (".err");
+
+      if (attempt == RETRY_ICE_ATTEMPTS)
+        {
+	  int i;
+	  int fd1, fd2;
+	  struct stat st1, st2;
+	  size_t n, len;
+	  char *buf;
+
+	  buf = xmalloc (8192);
+
+	  for (i = 0; i < 2; ++i)
+	    {
+	      fd1 = open (temp_filenames[i], O_RDONLY);
+	      fd2 = open (temp_filenames[2 + i], O_RDONLY);
+
+	      if (fd1 < 0 || fd2 < 0)
+		{
+		  i = -1;
+		  close (fd1);
+		  close (fd2);
+		  break;
+		}
+
+	      if (fstat (fd1, &st1) < 0 || fstat (fd2, &st2) < 0)
+		{
+		  i = -1;
+		  close (fd1);
+		  close (fd2);
+		  break;
+		}
+
+	      if (st1.st_size != st2.st_size)
+		{
+		  close (fd1);
+		  close (fd2);
+		  break;
+		}
+
+	      len = 0;
+	      for (n = st1.st_size; n; n -= len)
+		{
+		  len = n;
+		  if (len > 4096)
+		    len = 4096;
+
+		  if (read (fd1, buf, len) != (int) len
+		      || read (fd2, buf + 4096, len) != (int) len)
+		    {
+		      i = -1;
+		      break;
+		    }
+
+		  if (memcmp (buf, buf + 4096, len) != 0)
+		    break;
+		}
+
+	      close (fd1);
+	      close (fd2);
+
+	      if (n)
+		break;
+	    }
+
+	  free (buf);
+	  if (i == -1)
+	    break;
+
+	  if (i != 2)
+	    {
+	      notice ("The bug is not reproducible, so it is likely a hardware or OS problem.\n");
+	      break;
+	    }
+
+          fd = open (temp_filenames[attempt * 2], O_RDWR);
+	  if (fd < 0)
+	    break;
+	  write (fd, "//", 2);
+	  for (i = 0; i < nargs; i++)
+	    {
+	      write (fd, " ", 1);
+	      write (fd, new_argv[i], strlen (new_argv[i]));
+	    }
+	  write (fd, "\n", 1);
+	  new_argv[nargs] = "-E";
+	  new_argv[nargs + 1] = NULL;
+        }
+
+      /* Fork a subprocess; wait and retry if it fails.  */
+      sleep_interval = 1;
+      pid = -1;
+      for (retries = 0; retries < 4; retries++)
+	{
+	  pid = fork ();
+	  if (pid >= 0)
+	    break;
+	  sleep (sleep_interval);
+	  sleep_interval *= 2;
+	}
+
+      if (pid < 0)
+	break;
+      else if (pid == 0)
+	{
+	  if (attempt != RETRY_ICE_ATTEMPTS)
+	    fd = open (temp_filenames[attempt * 2], O_RDWR);
+	  if (fd < 0)
+	    exit (-1);
+	  if (fd != 1)
+	    {
+	      close (1);
+	      dup (fd);
+	      close (fd);
+	    }
+
+	  fd = open (temp_filenames[attempt * 2 + 1], O_RDWR);
+	  if (fd < 0)
+	    exit (-1);
+	  if (fd != 2)
+	    {
+	      close (2);
+	      dup (fd);
+	      close (fd);
+	    }
+
+	  if (prog == new_argv[0])
+	    execvp (prog, (char *const *) new_argv);
+	  else
+	    execv (new_argv[0], (char *const *) new_argv);
+	  exit (-1);
+	}
+
+      if (waitpid (pid, &status, 0) < 0)
+	break;
+
+      if (attempt < RETRY_ICE_ATTEMPTS
+	  && (! WIFEXITED (status) || WEXITSTATUS (status) != ICE_EXIT_CODE))
+	{
+	  notice ("The bug is not reproducible, so it is likely a hardware or OS problem.\n");
+	  break;
+	}
+      else if (attempt == RETRY_ICE_ATTEMPTS)
+	{
+	  close (fd);
+	  if (WIFEXITED (status)
+	      && WEXITSTATUS (status) == SUCCESS_EXIT_CODE)
+	    {
+	      notice ("Preprocessed source stored into %s file, please attach this to your bugreport.\n",
+		      temp_filenames[attempt * 2]);
+	      /* Make sure it is not deleted.  */
+	      free (temp_filenames[attempt * 2]);
+	      temp_filenames[attempt * 2] = NULL;
+	      break;
+	    }
+	}
+    }
+
+  for (attempt = 0; attempt < RETRY_ICE_ATTEMPTS * 2 + 2; attempt++)
+    if (temp_filenames[attempt])
+      {
+	unlink (temp_filenames[attempt]);
+	free (temp_filenames[attempt]);
+      }
+}
+#endif
+
 /* Search for a file named NAME trying various prefixes including the
    user's -B prefix and some standard ones.
    Return the absolute file name found.  If nothing is found, return NAME.  */
diff --git a/gcc/genpeep.c b/gcc/genpeep.c
index 4c6e64b..0bce155 100644
--- a/gcc/genpeep.c
+++ b/gcc/genpeep.c
@@ -381,6 +381,7 @@ from the machine description file `md'.  */\n\n");
   printf ("#include \"recog.h\"\n");
   printf ("#include \"except.h\"\n\n");
   printf ("#include \"function.h\"\n\n");
+  printf ("#include \"flags.h\"\n\n");
 
   printf ("#ifdef HAVE_peephole\n");
   printf ("extern rtx peep_operand[];\n\n");
diff --git a/gcc/java/keyword.gperf b/gcc/java/keyword.gperf
index 4127588..1316243 100644
--- a/gcc/java/keyword.gperf
+++ b/gcc/java/keyword.gperf
@@ -34,7 +34,7 @@ static unsigned int hash (const char *, unsigned int);
 #ifdef __GNUC__
 __inline
 #endif
-const struct java_keyword *java_keyword (const char *, unsigned int);
+static const struct java_keyword *java_keyword (const char *, unsigned int);
 %%
 abstract, ABSTRACT_TK
 default, DEFAULT_TK
diff --git a/gcc/java/keyword.h b/gcc/java/keyword.h
index 49eda19..6236605 100644
--- a/gcc/java/keyword.h
+++ b/gcc/java/keyword.h
@@ -34,7 +34,7 @@ static unsigned int hash (const char *, unsigned int);
 #ifdef __GNUC__
 __inline
 #endif
-const struct java_keyword *java_keyword (const char *, unsigned int);
+static const struct java_keyword *java_keyword (const char *, unsigned int);
 
 #define TOTAL_KEYWORDS 52
 #define MIN_WORD_LENGTH 2
diff --git a/gcc/mklibgcc.in b/gcc/mklibgcc.in
index 8fafce4..7ac15d8 100644
--- a/gcc/mklibgcc.in
+++ b/gcc/mklibgcc.in
@@ -41,6 +41,7 @@
 # SHLIB_NM_FLAGS
 # SHLIB_INSTALL
 # MULTILIB_OSDIRNAMES
+# GCC_FOR_TARGET
 
 # Make needs VPATH to be literal.
 echo 'srcdir = @srcdir@'
@@ -513,8 +514,8 @@ EOF
       shlib_slibdir_qual=
       if [ -n "$MULTILIB_OSDIRNAMES" ]; then
 	if [ "$dir" != . ]; then
-	  gcc_multilib_dir=`./xgcc -B./ $flags --print-multi-directory`
-	  os_multilib_dir=`./xgcc -B./ $flags --print-multi-os-directory`
+	  gcc_multilib_dir=`$GCC_FOR_TARGET -B./ $flags --print-multi-directory`
+	  os_multilib_dir=`$GCC_FOR_TARGET -B./ $flags --print-multi-os-directory`
 	  shlib_dir="$dir"/
 	  gcc_multilib_sup=`echo $gcc_multilib_dir | sed 's~^[^/]*/~~'`
 	  os_multilib_base=`echo $os_multilib_dir | sed -n "s~/${gcc_multilib_sup}\$~~p"`
@@ -707,8 +708,8 @@ for ml in $MULTILIBS; do
       shlib_dir=
       shlib_slibdir_qual=
       if [ -n "$MULTILIB_OSDIRNAMES" ]; then
-	gcc_multilib_dir=`./xgcc -B./ $flags --print-multi-directory`
-	os_multilib_dir=`./xgcc -B./ $flags --print-multi-os-directory`
+	gcc_multilib_dir=`$GCC_FOR_TARGET -B./ $flags --print-multi-directory`
+	os_multilib_dir=`$GCC_FOR_TARGET -B./ $flags --print-multi-os-directory`
 	if [ "$dir" != . ]; then
 	  shlib_dir="$dir"/
 	fi
diff --git a/gcc/opts.c b/gcc/opts.c
index ff50ad1..03c2381 100644
--- a/gcc/opts.c
+++ b/gcc/opts.c
@@ -142,6 +142,12 @@ enum debug_info_level debug_info_level = DINFO_LEVEL_NONE;
    write_symbols is set to DBX_DEBUG, XCOFF_DEBUG, or DWARF_DEBUG.  */
 bool use_gnu_debug_info_extensions;
 
+/* The default visibility for all symbols (unless overridden) */
+enum symbol_visibility default_visibility = VISIBILITY_DEFAULT;
+
+/* Global visibility options.  */
+struct visibility_flags visibility_options;
+
 /* Columns of --help display.  */
 static unsigned int columns = 80;
 
@@ -1214,6 +1220,21 @@ common_handle_option (size_t scode, const char *arg,
       flag_profile_values = value;
       break;
 
+    case OPT_fvisibility_:
+      {
+        if (!strcmp(arg, "default"))
+          default_visibility = VISIBILITY_DEFAULT;
+        else if (!strcmp(arg, "internal"))
+          default_visibility = VISIBILITY_INTERNAL;
+        else if (!strcmp(arg, "hidden"))
+          default_visibility = VISIBILITY_HIDDEN;
+        else if (!strcmp(arg, "protected"))
+          default_visibility = VISIBILITY_PROTECTED;
+        else
+          error ("unrecognised visibility value \"%s\"", arg);
+      }
+      break;
+
     case OPT_fvpt:
       flag_value_profile_transformations_set = value;
       flag_value_profile_transformations = value;
diff --git a/gcc/output.h b/gcc/output.h
index 05a3743..20d70c3 100644
--- a/gcc/output.h
+++ b/gcc/output.h
@@ -213,6 +213,10 @@ extern void named_section (tree, const char *, int);
 /* Tell assembler to switch to the section for function DECL.  */
 extern void function_section (tree);
 
+/* Tell assembler to switch to the readonly data section associated
+   with function DECL.  */
+extern void function_readonly_data_section (tree);
+
 /* Tell assembler to switch to the section for string merging.  */
 extern void mergeable_string_section (tree, unsigned HOST_WIDE_INT,
 				      unsigned int);
diff --git a/gcc/po/ca.po b/gcc/po/ca.po
index e077d02..17622e2 100644
--- a/gcc/po/ca.po
+++ b/gcc/po/ca.po
@@ -17340,7 +17340,7 @@ msgstr "passant el valor negatiu `%E' per a %s %P de \"%D\""
 
 #: cp/typeck.c:5684
 msgid "%s of negative value `%E' to `%T'"
-msgstr "%s de valor negatiu `%I' a \"%T\""
+msgstr "%s de valor negatiu `%E' a \"%T\""
 
 #: cp/typeck.c:5772
 msgid "cannot convert `%T' to `%T' for argument `%P' to `%D'"
diff --git a/gcc/po/es.po b/gcc/po/es.po
index 4887014..523052e 100644
--- a/gcc/po/es.po
+++ b/gcc/po/es.po
@@ -1882,7 +1882,7 @@ msgstr "precisi
 #: c-format.c:1956
 #, c-format
 msgid "%s does not support the `%s' %s length modifier"
-msgstr "%1$s no tiene soporte para el modificador de longitud %3$s `%2$s'"
+msgstr "%s no tiene soporte para el modificador de longitud `%s' %s"
 
 #: c-format.c:2006
 msgid "conversion lacks type at end of format"
@@ -1901,12 +1901,12 @@ msgstr "se desconoce el car
 #: c-format.c:2027
 #, c-format
 msgid "%s does not support the `%%%c' %s format"
-msgstr "%1$s no tiene soporte para el formato %3$s `%%%2$c'"
+msgstr "%s no tiene soporte para el formato `%%%c' %s"
 
 #: c-format.c:2043
 #, c-format
 msgid "%s used with `%%%c' %s format"
-msgstr "se us %1$s con el formato %3$s `%%%2$c'"
+msgstr "se us %s con el formato `%%%c' %s"
 
 #: c-format.c:2052
 #, c-format
@@ -1916,12 +1916,12 @@ msgstr "%s no tiene soporte para %s"
 #: c-format.c:2061
 #, c-format
 msgid "%s does not support %s with the `%%%c' %s format"
-msgstr "%1$s no tiene soporte para %2$s con el formato %4$s `%%%3$c'"
+msgstr "%s no tiene soporte para %s con el formato `%%%c' %s"
 
 #: c-format.c:2094
 #, c-format
 msgid "%s ignored with %s and `%%%c' %s format"
-msgstr "se ignora %1$s con %2$s y el formato %4$s `%%%3$c'"
+msgstr "se ignora %s con %s y el formato `%%%c' %s"
 
 #: c-format.c:2098
 #, c-format
@@ -1931,7 +1931,7 @@ msgstr "se ignora %s con %s en el formato %s"
 #: c-format.c:2104
 #, c-format
 msgid "use of %s and %s together with `%%%c' %s format"
-msgstr "uso de %1$s y %2$s junto con el formato %4$s `%%%3$c'"
+msgstr "uso de %s y %s junto con el formato `%%%c' %s"
 
 #: c-format.c:2108
 #, c-format
@@ -1962,7 +1962,7 @@ msgstr "uso del modificador de longitud `%s' con el car
 #: c-format.c:2180
 #, c-format
 msgid "%s does not support the `%%%s%c' %s format"
-msgstr "%1$s no tiene soporte para el formato %4$s `%%%2$s%3$c'"
+msgstr "%s no tiene soporte para el formato `%%%s%c' %s"
 
 #: c-format.c:2195
 msgid "operand number specified with suppressed assignment"
diff --git a/gcc/system.h b/gcc/system.h
index e19de3f..d0a2818 100644
--- a/gcc/system.h
+++ b/gcc/system.h
@@ -154,6 +154,10 @@ extern int errno;
 # endif
 #endif
 
+#ifndef ICE_EXIT_CODE
+# define ICE_EXIT_CODE 27
+#endif
+
 #ifdef HAVE_UNISTD_H
 # include <unistd.h>
 #endif
diff --git a/gcc/testsuite/g++.dg/ext/visibility/assign1.C b/gcc/testsuite/g++.dg/ext/visibility/assign1.C
new file mode 100644
index 0000000..cbd909e
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/visibility/assign1.C
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+/* { dg-require-visibility "" } */
+/* { dg-final { scan-hidden "_ZN1DaSERKS_" } } */
+
+struct B {
+  B& operator=(const B&);
+};
+
+struct D : public B {
+  // The implicit assignment operator should be hidden.
+} __attribute__((visibility("hidden")));
+
+D d1, d2;
+
+void f() {
+  d1 = d2;
+}
diff --git a/gcc/testsuite/g++.dg/ext/visibility/fvisibility-inlines-hidden.C b/gcc/testsuite/g++.dg/ext/visibility/fvisibility-inlines-hidden.C
new file mode 100644
index 0000000..2ee8f07
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/visibility/fvisibility-inlines-hidden.C
@@ -0,0 +1,18 @@
+/* Test that -fvisibility-inlines-hidden affects class members. */
+/* { dg-do compile } */
+/* { dg-require-visibility "" } */
+/* { dg-options "-fvisibility-inlines-hidden" } */
+/* { dg-final { scan-hidden "_ZN3Foo6methodEv" } } */
+
+class Foo
+{
+public:
+  void method() { }
+};
+
+int main(void)
+{
+  Foo f;
+  f.method();
+  return 0;
+}
diff --git a/gcc/testsuite/g++.dg/ext/visibility/fvisibility-override1.C b/gcc/testsuite/g++.dg/ext/visibility/fvisibility-override1.C
new file mode 100644
index 0000000..67d5ef0
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/visibility/fvisibility-override1.C
@@ -0,0 +1,12 @@
+/* Test that -fvisibility does not override class member specific settings. */
+/* { dg-do compile } */
+/* { dg-require-visibility "" } */
+/* { dg-options "-fvisibility=hidden" } */
+/* { dg-final { scan-assembler "\\.internal.*Foo.methodEv" } } */
+
+class __attribute__ ((visibility ("internal"))) Foo
+{
+  void method();
+};
+
+void Foo::method() { }
diff --git a/gcc/testsuite/g++.dg/ext/visibility/fvisibility-override2.C b/gcc/testsuite/g++.dg/ext/visibility/fvisibility-override2.C
new file mode 100644
index 0000000..a0a2df5
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/visibility/fvisibility-override2.C
@@ -0,0 +1,12 @@
+/* Test that -fvisibility does not override class member specific settings. */
+/* { dg-do compile } */
+/* { dg-require-visibility "" } */
+/* { dg-options "-fvisibility=hidden" } */
+/* { dg-final { scan-assembler "\\.internal.*Foo.methodEv" } } */
+
+class Foo
+{
+  __attribute__ ((visibility ("internal"))) void method();
+};
+
+void Foo::method() { }
diff --git a/gcc/testsuite/g++.dg/ext/visibility/fvisibility.C b/gcc/testsuite/g++.dg/ext/visibility/fvisibility.C
new file mode 100644
index 0000000..4358d25
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/visibility/fvisibility.C
@@ -0,0 +1,12 @@
+/* Test that -fvisibility affects class members. */
+/* { dg-do compile } */
+/* { dg-require-visibility "" } */
+/* { dg-options "-fvisibility=hidden" } */
+/* { dg-final { scan-hidden "_ZN3Foo6methodEv" } } */
+
+class Foo
+{
+  void method();
+};
+
+void Foo::method() { }
diff --git a/gcc/testsuite/g++.dg/ext/visibility/memfuncts.C b/gcc/testsuite/g++.dg/ext/visibility/memfuncts.C
new file mode 100644
index 0000000..45eb641
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/visibility/memfuncts.C
@@ -0,0 +1,11 @@
+/* Test that setting visibility for class member functions works. */
+/* { dg-do compile } */
+/* { dg-require-visibility "" } */
+/* { dg-final { scan-hidden "_ZN3Foo6methodEv" } } */
+
+class __attribute__ ((visibility ("hidden"))) Foo
+{
+  void method();
+};
+
+void Foo::method() { }
diff --git a/gcc/testsuite/g++.dg/ext/visibility/new1.C b/gcc/testsuite/g++.dg/ext/visibility/new1.C
new file mode 100644
index 0000000..ec201cb
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/visibility/new1.C
@@ -0,0 +1,13 @@
+// { dg-require-visibility "" }
+// { dg-options "-fvisibility=hidden" }
+// { dg-final { scan-not-hidden "_Znwj" } }
+
+void f() {
+  new int;
+}
+
+void *g();
+
+void *operator new(__SIZE_TYPE__) {
+  return g();
+}
diff --git a/gcc/testsuite/g++.dg/ext/visibility/noPLT.C b/gcc/testsuite/g++.dg/ext/visibility/noPLT.C
new file mode 100644
index 0000000..0ad981f
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/visibility/noPLT.C
@@ -0,0 +1,20 @@
+/* Test that -fvisibility=hidden prevents PLT. */
+/* { dg-do compile } */
+/* { dg-require-visibility "" } */
+/* { dg-options "-fPIC -fvisibility=hidden" } */
+/* { dg-final { scan-assembler-not "methodEv@PLT" } } */
+
+class Foo
+{
+public:
+  void method();
+};
+
+void Foo::method() { }
+
+int main(void)
+{
+  Foo f;
+  f.method();
+  return 0;
+}
diff --git a/gcc/testsuite/g++.dg/ext/visibility/pragma-override1.C b/gcc/testsuite/g++.dg/ext/visibility/pragma-override1.C
new file mode 100644
index 0000000..a2c93eb
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/visibility/pragma-override1.C
@@ -0,0 +1,13 @@
+/* Test that #pragma GCC visibility does not override class member specific settings. */
+/* { dg-do compile } */
+/* { dg-require-visibility "" } */
+/* { dg-final { scan-assembler "\\.internal.*Foo.methodEv" } } */
+
+#pragma GCC visibility push(hidden)
+class __attribute__ ((visibility ("internal"))) Foo
+{
+  void method();
+};
+#pragma GCC visibility pop
+
+void Foo::method() { }
diff --git a/gcc/testsuite/g++.dg/ext/visibility/pragma-override2.C b/gcc/testsuite/g++.dg/ext/visibility/pragma-override2.C
new file mode 100644
index 0000000..a4bb42c
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/visibility/pragma-override2.C
@@ -0,0 +1,13 @@
+/* Test that #pragma GCC visibility does not override class member specific settings. */
+/* { dg-do compile } */
+/* { dg-require-visibility "" } */
+/* { dg-final { scan-assembler "\\.internal.*Foo.methodEv" } } */
+
+#pragma GCC visibility push(hidden)
+class Foo
+{
+  __attribute__ ((visibility ("internal"))) void method();
+};
+#pragma GCC visibility pop
+
+void Foo::method() { }
diff --git a/gcc/testsuite/g++.dg/ext/visibility/pragma.C b/gcc/testsuite/g++.dg/ext/visibility/pragma.C
new file mode 100644
index 0000000..98384c9
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/visibility/pragma.C
@@ -0,0 +1,13 @@
+/* Test that #pragma GCC visibility affects class members. */
+/* { dg-do compile } */
+/* { dg-require-visibility "" } */
+/* { dg-final { scan-hidden "_ZN3Foo6methodEv" } } */
+
+#pragma GCC visibility push(hidden)
+class Foo
+{
+  void method();
+};
+#pragma GCC visibility pop
+
+void Foo::method() { }
diff --git a/gcc/testsuite/g++.dg/ext/visibility/staticmemfuncts.C b/gcc/testsuite/g++.dg/ext/visibility/staticmemfuncts.C
new file mode 100644
index 0000000..e745caa
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/visibility/staticmemfuncts.C
@@ -0,0 +1,11 @@
+/* Test that setting visibility for static class member functions works. */
+/* { dg-do compile } */
+/* { dg-require-visibility "" } */
+/* { dg-final { scan-hidden "_ZN3Foo6methodEv" } } */
+
+class __attribute__ ((visibility ("hidden"))) Foo
+{
+  static void method();
+};
+
+void Foo::method() { }
diff --git a/gcc/testsuite/g++.dg/ext/visibility/virtual.C b/gcc/testsuite/g++.dg/ext/visibility/virtual.C
new file mode 100644
index 0000000..746c489
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/visibility/virtual.C
@@ -0,0 +1,11 @@
+/* Test that setting visibility for class affects virtual table. */
+/* { dg-do compile } */
+/* { dg-require-visibility "" } */
+/* { dg-final { scan-hidden "ZTV3Foo" } } */
+
+class __attribute__ ((visibility ("hidden"))) Foo
+{
+  virtual void method();
+};
+
+void Foo::method() { }
diff --git a/gcc/testsuite/g++.dg/ext/visibility-1.C b/gcc/testsuite/g++.dg/ext/visibility/visibility-1.C
similarity index 50%
rename from gcc/testsuite/g++.dg/ext/visibility-1.C
rename to gcc/testsuite/g++.dg/ext/visibility/visibility-1.C
index d579eb2..8ea270b 100644
--- a/gcc/testsuite/g++.dg/ext/visibility-1.C
+++ b/gcc/testsuite/g++.dg/ext/visibility/visibility-1.C
@@ -1,6 +1,6 @@
 /* Test visibility attribute on function definition. */
-/* { dg-do compile { target *86-*-linux* } } */
-/* { dg-final { scan-assembler "\\.hidden.*_Z3foov" } } */
+/* { dg-require-visibility "" }
+/* { dg-final { scan-hidden "_Z3foov" } } */
 
 void
 __attribute__((visibility ("hidden")))
diff --git a/gcc/testsuite/g++.dg/ext/visibility-2.C b/gcc/testsuite/g++.dg/ext/visibility/visibility-2.C
similarity index 57%
rename from gcc/testsuite/g++.dg/ext/visibility-2.C
rename to gcc/testsuite/g++.dg/ext/visibility/visibility-2.C
index 89e853c..26272ab 100644
--- a/gcc/testsuite/g++.dg/ext/visibility-2.C
+++ b/gcc/testsuite/g++.dg/ext/visibility/visibility-2.C
@@ -1,6 +1,6 @@
 /* Test that visibility attribute on declaration extends to definition. */
-/* { dg-do compile { target *86-*-linux* } } */
-/* { dg-final { scan-assembler "\\.hidden.*_Z3foov" } } */
+/* { dg-require-visibility "" }
+/* { dg-final { scan-hidden "_Z3foov" } } */
 
 void __attribute__((visibility ("hidden"))) foo();
 
diff --git a/gcc/testsuite/g++.dg/ext/visibility-3.C b/gcc/testsuite/g++.dg/ext/visibility/visibility-3.C
similarity index 55%
rename from gcc/testsuite/g++.dg/ext/visibility-3.C
rename to gcc/testsuite/g++.dg/ext/visibility/visibility-3.C
index d0cc891..e4f499f 100644
--- a/gcc/testsuite/g++.dg/ext/visibility-3.C
+++ b/gcc/testsuite/g++.dg/ext/visibility/visibility-3.C
@@ -1,6 +1,6 @@
 /* Test visibility attribute on forward declaration of global variable */
-/* { dg-do compile { target *86-*-linux* } } */
-/* { dg-final { scan-assembler "\\.hidden.*xyzzy" } } */
+/* { dg-require-visibility "" }
+/* { dg-final { scan-hidden "xyzzy" } } */
 
 int
 __attribute__((visibility ("hidden")))
diff --git a/gcc/testsuite/g++.dg/ext/visibility-4.C b/gcc/testsuite/g++.dg/ext/visibility/visibility-4.C
similarity index 58%
rename from gcc/testsuite/g++.dg/ext/visibility-4.C
rename to gcc/testsuite/g++.dg/ext/visibility/visibility-4.C
index d217bc9..f676595 100644
--- a/gcc/testsuite/g++.dg/ext/visibility-4.C
+++ b/gcc/testsuite/g++.dg/ext/visibility/visibility-4.C
@@ -1,6 +1,6 @@
 /* Test visibility attribute on forward declaration of global variable */
-/* { dg-do compile { target *86-*-linux* } } */
-/* { dg-final { scan-assembler "\\.hidden.*xyzzy" } } */
+/* { dg-require-visibility "" }
+/* { dg-final { scan-hidden "xyzzy" } } */
 
 extern int __attribute__ ((visibility ("hidden")))
 xyzzy;
diff --git a/gcc/testsuite/g++.dg/ext/visibility-5.C b/gcc/testsuite/g++.dg/ext/visibility/visibility-5.C
similarity index 62%
rename from gcc/testsuite/g++.dg/ext/visibility-5.C
rename to gcc/testsuite/g++.dg/ext/visibility/visibility-5.C
index 9cdc802..592529e 100644
--- a/gcc/testsuite/g++.dg/ext/visibility-5.C
+++ b/gcc/testsuite/g++.dg/ext/visibility/visibility-5.C
@@ -1,7 +1,7 @@
 /* Test visibility attribute on definition of a function that has
    already had a forward declaration. */
-/* { dg-do compile { target *86-*-linux* } } */
-/* { dg-final { scan-assembler "\\.hidden.*_Z3foov" } } */
+/* { dg-require-visibility "" }
+/* { dg-final { scan-hidden "_Z3foov" } } */
 
 void foo();
 
diff --git a/gcc/testsuite/g++.dg/ext/visibility-6.C b/gcc/testsuite/g++.dg/ext/visibility/visibility-6.C
similarity index 64%
rename from gcc/testsuite/g++.dg/ext/visibility-6.C
rename to gcc/testsuite/g++.dg/ext/visibility/visibility-6.C
index 6e8f0ce..0fecf6b 100644
--- a/gcc/testsuite/g++.dg/ext/visibility-6.C
+++ b/gcc/testsuite/g++.dg/ext/visibility/visibility-6.C
@@ -1,7 +1,7 @@
 /* Test visibility attribute on definition of global variable that has
    already had a forward declaration. */
-/* { dg-do compile { target *86-*-linux* } } */
-/* { dg-final { scan-assembler "\\.hidden.*xyzzy" } } */
+/* { dg-require-visibility "" }
+/* { dg-final { scan-hidden "xyzzy" } } */
 
 extern int xyzzy;
 
diff --git a/gcc/testsuite/g++.dg/ext/visibility-7.C b/gcc/testsuite/g++.dg/ext/visibility/visibility-7.C
similarity index 73%
rename from gcc/testsuite/g++.dg/ext/visibility-7.C
rename to gcc/testsuite/g++.dg/ext/visibility/visibility-7.C
index 40acb72..dbd7010 100644
--- a/gcc/testsuite/g++.dg/ext/visibility-7.C
+++ b/gcc/testsuite/g++.dg/ext/visibility/visibility-7.C
@@ -1,6 +1,6 @@
 /* Test warning from conflicting visibility specifications. */
-/* { dg-do compile { target *86-*-linux* } } */
-/* { dg-final { scan-assembler "\\.hidden.*xyzzy" } } */
+/* { dg-require-visibility "" } */
+/* { dg-final { scan-hidden "xyzzy" } } */
 
 extern int 
 __attribute__((visibility ("hidden")))
diff --git a/gcc/testsuite/g++.old-deja/g++.other/comdat4-aux.cc b/gcc/testsuite/g++.old-deja/g++.other/comdat4-aux.cc
new file mode 100644
index 0000000..e0556a5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/comdat4-aux.cc
@@ -0,0 +1,40 @@
+extern void
+bar (int x);
+
+inline void
+foo (int i)
+{
+  switch (i)
+    {
+    case 3:
+    case 5:
+    case 6:
+    case 9:
+    case 15:
+      bar (1);
+      break;
+    case 2:
+    case 4:
+    case 7:
+    case 10:
+    case 11:
+    case 12:
+      bar (2);
+      break;
+    case 0:
+    case 1:
+    case 8:
+    case 13:
+    case 16:
+      bar (3);
+      break;
+    case 14:
+      bar (4);
+      break;
+    default:
+      bar (5);
+      break;
+    }
+}
+
+void *fooaddr2 = (void *) foo;
diff --git a/gcc/testsuite/g++.old-deja/g++.other/comdat4.C b/gcc/testsuite/g++.old-deja/g++.other/comdat4.C
new file mode 100644
index 0000000..28b26a1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/comdat4.C
@@ -0,0 +1,57 @@
+// PR c++/16276
+// { dg-do link }
+// { dg-additional-sources " comdat4-aux.cc" }
+// { dg-options "-O2" }
+
+extern void
+bar (int x);
+
+inline void
+foo (int i)
+{
+  switch (i)
+    {
+    case 3:
+    case 5:
+    case 6:
+    case 9:
+    case 15:
+      bar (1);
+      break;
+    case 2:
+    case 4:
+    case 7:
+    case 10:
+    case 11:
+    case 12:
+      bar (2);
+      break;
+    case 0:
+    case 1:
+    case 8:
+    case 13:
+    case 16:
+      bar (3);
+      break;
+    case 14:
+      bar (4);
+      break;
+    default:
+      bar (5);
+      break;
+    }
+}
+
+void *fooaddr = (void *) foo;
+
+void
+bar (int x)
+{
+  __asm __volatile ("" : : "r" (x));
+}
+
+int
+main (void)
+{
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/ppc64-toc.c b/gcc/testsuite/gcc.dg/ppc64-toc.c
new file mode 100644
index 0000000..747f137
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/ppc64-toc.c
@@ -0,0 +1,22 @@
+/* { dg-do link } */
+/* { dg-options "-m64 -mminimal-toc" { target powerpc64-*-* } } */
+
+char *strchr (const char *, int);
+
+int
+foo (int a)
+{
+  int b;
+
+  b = 0;
+  if ("/"[1] != '\0')
+    if (strchr ("/", a))
+      b = 1;
+  return b;
+}
+
+int
+main (void)
+{
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/visibility-9.c b/gcc/testsuite/gcc.dg/visibility-9.c
new file mode 100644
index 0000000..ac6493e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/visibility-9.c
@@ -0,0 +1,9 @@
+/* Test that -fvisibility works. */
+/* { dg-do compile } */
+/* { dg-require-visibility "" } */
+/* { dg-options "-fvisibility=hidden" } */
+/* { dg-final { scan-assembler "\\.hidden.*foo" } } */
+
+void foo();
+
+void foo() { }
diff --git a/gcc/testsuite/gcc.dg/visibility-a.c b/gcc/testsuite/gcc.dg/visibility-a.c
new file mode 100644
index 0000000..1749234
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/visibility-a.c
@@ -0,0 +1,10 @@
+/* Test that #pragma GCC visibility works. */
+/* { dg-do compile } */
+/* { dg-require-visibility "" } */
+/* { dg-final { scan-assembler "\\.hidden.*foo" } } */
+
+#pragma GCC visibility push(hidden)
+void foo();
+#pragma GCC visibility pop
+
+void foo() { }
diff --git a/gcc/testsuite/gcc/testsuite/g++.special/inline-hidden-1.cc b/gcc/testsuite/gcc/testsuite/g++.special/inline-hidden-1.cc
new file mode 100644
index 0000000..ec33811
--- /dev/null
+++ b/gcc/testsuite/gcc/testsuite/g++.special/inline-hidden-1.cc
@@ -0,0 +1,16 @@
+#pragma GCC visibility push(default)
+template<typename CharT>
+struct VisTest
+{
+  inline VisTest ();
+};
+template<typename CharT>
+inline VisTest<CharT>::VisTest()
+{}
+extern template class VisTest<char>;
+#pragma GCC visibility pop
+int some_function( int do_something )
+{
+  VisTest<char> a;
+  return 0;
+}
diff --git a/gcc/testsuite/gcc/testsuite/g++.special/inline-hidden-1.x b/gcc/testsuite/gcc/testsuite/g++.special/inline-hidden-1.x
new file mode 100644
index 0000000..cdbe925
--- /dev/null
+++ b/gcc/testsuite/gcc/testsuite/g++.special/inline-hidden-1.x
@@ -0,0 +1,9 @@
+if ![is-shared-library-supported] {
+    return
+}
+
+#
+# build shared libray
+#
+gcc-special-compile $srcdir/$subdir/inline-hidden-1.cc \
+	"-shared -fPIC -fvisibility-inlines-hidden" "" "no"
diff --git a/gcc/testsuite/gcc/testsuite/g++.special/inline-hidden-2.cc b/gcc/testsuite/gcc/testsuite/g++.special/inline-hidden-2.cc
new file mode 100644
index 0000000..8de3bab
--- /dev/null
+++ b/gcc/testsuite/gcc/testsuite/g++.special/inline-hidden-2.cc
@@ -0,0 +1,14 @@
+template<typename CharT>
+struct VisTest
+{
+  inline VisTest ();
+};
+template<typename CharT>
+inline VisTest<CharT>::VisTest()
+{}
+extern template class VisTest<char>;
+int some_function( int do_something )
+{
+  VisTest<char> a;
+  return 0;
+}
diff --git a/gcc/testsuite/gcc/testsuite/g++.special/inline-hidden-2.x b/gcc/testsuite/gcc/testsuite/g++.special/inline-hidden-2.x
new file mode 100644
index 0000000..cd53921
--- /dev/null
+++ b/gcc/testsuite/gcc/testsuite/g++.special/inline-hidden-2.x
@@ -0,0 +1,9 @@
+if ![is-shared-library-supported] {
+    return
+}
+
+#
+# build shared libray
+#
+gcc-special-compile $srcdir/$subdir/inline-hidden-2.cc \
+	"-shared -fPIC -fvisibility-inlines-hidden" "" "yes"
diff --git a/gcc/testsuite/gcc/testsuite/g++.special/inline-hidden-3.x b/gcc/testsuite/gcc/testsuite/g++.special/inline-hidden-3.x
new file mode 100644
index 0000000..6306ab4
--- /dev/null
+++ b/gcc/testsuite/gcc/testsuite/g++.special/inline-hidden-3.x
@@ -0,0 +1,11 @@
+if ![is-shared-library-supported] {
+    return
+}
+
+#
+# build shared libray
+#
+set obj [gcc-special-compile "$srcdir/$subdir/inline-hidden-3a.cc" \
+	 "-fPIC -fvisibility-inlines-hidden" "" "no"]
+gcc-special-compile $srcdir/$subdir/inline-hidden-3b.cc \
+	"-shared -fPIC" "$obj" "no"
diff --git a/gcc/testsuite/gcc/testsuite/g++.special/inline-hidden-3a.cc b/gcc/testsuite/gcc/testsuite/g++.special/inline-hidden-3a.cc
new file mode 100644
index 0000000..8de3bab
--- /dev/null
+++ b/gcc/testsuite/gcc/testsuite/g++.special/inline-hidden-3a.cc
@@ -0,0 +1,14 @@
+template<typename CharT>
+struct VisTest
+{
+  inline VisTest ();
+};
+template<typename CharT>
+inline VisTest<CharT>::VisTest()
+{}
+extern template class VisTest<char>;
+int some_function( int do_something )
+{
+  VisTest<char> a;
+  return 0;
+}
diff --git a/gcc/testsuite/gcc/testsuite/g++.special/inline-hidden-3b.cc b/gcc/testsuite/gcc/testsuite/g++.special/inline-hidden-3b.cc
new file mode 100644
index 0000000..d12aa28
--- /dev/null
+++ b/gcc/testsuite/gcc/testsuite/g++.special/inline-hidden-3b.cc
@@ -0,0 +1,9 @@
+template<typename CharT>
+struct VisTest
+{
+  inline VisTest ();
+};
+template<typename CharT>
+inline VisTest<CharT>::VisTest()
+{}
+template class VisTest<char>;
diff --git a/gcc/testsuite/gcc/testsuite/g++.special/special.exp b/gcc/testsuite/gcc/testsuite/g++.special/special.exp
new file mode 100644
index 0000000..f8f31fe
--- /dev/null
+++ b/gcc/testsuite/gcc/testsuite/g++.special/special.exp
@@ -0,0 +1,30 @@
+# Copyright (C) 2005 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. 
+
+if $tracelevel then {
+    strace $tracelevel
+}
+
+# load support procs
+load_lib gcc-special.exp
+
+#
+# run special tests 
+#
+
+foreach src [lsort [glob -nocomplain $srcdir/$subdir/*.x]] {
+    source $src
+}
diff --git a/gcc/testsuite/gcc/testsuite/gcc.special/protfunc-1-dso.c b/gcc/testsuite/gcc/testsuite/gcc.special/protfunc-1-dso.c
new file mode 100644
index 0000000..743a926
--- /dev/null
+++ b/gcc/testsuite/gcc/testsuite/gcc.special/protfunc-1-dso.c
@@ -0,0 +1,13 @@
+void
+__attribute__ ((visibility ("protected")))
+foo ()
+{
+}
+
+void (*foo_p) () = foo;
+
+void *
+bar (void)
+{
+  return foo;
+}
diff --git a/gcc/testsuite/gcc/testsuite/gcc.special/protfunc-1-main.c b/gcc/testsuite/gcc/testsuite/gcc.special/protfunc-1-main.c
new file mode 100644
index 0000000..c154032
--- /dev/null
+++ b/gcc/testsuite/gcc/testsuite/gcc.special/protfunc-1-main.c
@@ -0,0 +1,14 @@
+extern void (*foo_p) (void);
+extern void foo (void);
+extern void* bar (void);
+
+int
+main ()
+{
+  void *p;
+  p = bar ();
+  if (p == foo && p == foo_p)
+    return 0;
+  else
+    return 1;
+}
diff --git a/gcc/testsuite/gcc/testsuite/gcc.special/protfunc-1.x b/gcc/testsuite/gcc/testsuite/gcc.special/protfunc-1.x
new file mode 100644
index 0000000..5cc886b
--- /dev/null
+++ b/gcc/testsuite/gcc/testsuite/gcc.special/protfunc-1.x
@@ -0,0 +1,14 @@
+if ![is-shared-library-supported] {
+    return
+}
+
+#
+# build shared libray
+#
+set dso [gcc-special-compile $srcdir/$subdir/protfunc-1-dso.c \
+	 "-fPIC -shared -O" "" "no"]
+
+#
+# build and run executable
+#
+gcc-special-execute $srcdir/$subdir/protfunc-1-main.c $dso "-O"
diff --git a/gcc/testsuite/gcc/testsuite/gcc.special/special.exp b/gcc/testsuite/gcc/testsuite/gcc.special/special.exp
new file mode 100644
index 0000000..f8f31fe
--- /dev/null
+++ b/gcc/testsuite/gcc/testsuite/gcc.special/special.exp
@@ -0,0 +1,30 @@
+# Copyright (C) 2005 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. 
+
+if $tracelevel then {
+    strace $tracelevel
+}
+
+# load support procs
+load_lib gcc-special.exp
+
+#
+# run special tests 
+#
+
+foreach src [lsort [glob -nocomplain $srcdir/$subdir/*.x]] {
+    source $src
+}
diff --git a/gcc/testsuite/gcc/testsuite/lib/gcc-special.exp b/gcc/testsuite/gcc/testsuite/lib/gcc-special.exp
new file mode 100644
index 0000000..7ac24cc
--- /dev/null
+++ b/gcc/testsuite/gcc/testsuite/lib/gcc-special.exp
@@ -0,0 +1,177 @@
+# Copyright (C) 2005 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+# Based on c-torture.exp.
+
+load_lib file-format.exp
+load_lib target-supports.exp
+
+#
+# gcc-special-compile -- compile source file or build shared library.
+#
+# SRC is the full pathname of the testcase.
+# OPTIONS is the specific compiler flag we're testing (eg: -O2).
+# OBJ is the additional object.
+# XFAIL is to indicate if it should fail.
+#
+proc gcc-special-compile { src options obj xfail } {
+    global tool
+    global output
+    global srcdir tmpdir
+    global host_triplet
+
+    if [string match "yes" $xfail] {
+	setup_xfail "*-*-*"
+    }
+
+    set shared "no"
+    set option ""
+    foreach opt $options {
+	if [string match "-shared" $opt] {
+	    lappend option [get-build-shared-library-option]
+	    set shared "yes"
+	} elseif [string match "-fPIC" $opt] {
+	    lappend option [get-compile-shared-library-option]
+	} else {
+	    lappend option "$opt"
+	}
+    }
+
+    if [string match "yes" $shared] {
+	set type "executable"
+	set output "$tmpdir/[file tail [file rootname $src]].so"
+    } else {
+	set type "object"
+	set output "$tmpdir/[file tail [file rootname $src]].o"
+    }
+
+    regsub "^$srcdir/?" $src "" testcase
+    # If we couldn't rip $srcdir out of `src' then just do the best we can.
+    # The point is to reduce the unnecessary noise in the logs.  Don't strip
+    # out too much because different testcases with the same name can confuse
+    # `test-tool'.
+    if [string match "/*" $testcase] {
+	set testcase "[file tail [file dirname $src]]/[file tail $src]"
+    }
+
+    verbose "Testing $testcase, $option" 1
+
+    # Run the compiler and analyze the results.
+    set options ""
+    lappend options "additional_flags=-w $option $obj"
+
+    set comp_output [${tool}_target_compile "$src" "$output" $type $options];
+    if [${tool}_check_compile $testcase $option $output $comp_output] {
+	if [string match "yes" $xfail] {
+	    fail "$testcase, $option"
+	} else {
+	    foreach file "$obj" {
+		remote_file build delete $file
+	    }
+	}
+    } elseif [string match "yes" $xfail] {
+	foreach file "$obj" {
+	    remote_file build delete $file
+	}
+    }
+    return $output
+}
+
+#
+# gcc-special-execute -- utility to compile and execute a testcase
+#
+# SOURCES is a list of full pathnames to the test source files.
+# The first filename in this list forms the "testcase".
+#
+# If the testcase has an associated .x file, we source that to run the
+# test instead.  We use .x so that we don't lengthen the existing filename
+# to more than 14 chars.
+#
+proc gcc-special-execute { sources shlib additional_flags } {
+    global tmpdir tool srcdir output compiler_conditional_xfail_data
+
+    # Use the first source filename given as the filename under test.
+    set src [lindex $sources 0]
+
+    set option ""
+
+    # Check for alternate driver.
+    if [file exists [file rootname $src].x] {
+	verbose "Using alternate driver [file rootname [file tail $src]].x" 2
+	set done_p 0
+	catch "set done_p \[source [file rootname $src].x\]"
+	if { $done_p } {
+	    return
+	}
+    }
+
+    set executable $tmpdir/[file tail [file rootname $src].x]
+
+    regsub "^$srcdir/?" $src "" testcase
+    # If we couldn't rip $srcdir out of `src' then just do the best we can.
+    # The point is to reduce the unnecessary noise in the logs.  Don't strip
+    # out too much because different testcases with the same name can confuse
+    # `test-tool'.
+    if [string match "/*" $testcase] {
+	set testcase "[file tail [file dirname $src]]/[file tail $src]"
+    }
+
+    # torture_{compile,execute}_xfail are set by the .x script
+    # (if present)
+    if [info exists torture_compile_xfail] {
+	setup_xfail $torture_compile_xfail
+    }
+
+    # torture_execute_before_{compile,execute} can be set by the .x script
+    # (if present)
+    if [info exists torture_eval_before_compile] {
+	set ignore_me [eval $torture_eval_before_compile]
+    }
+
+    verbose "Testing $testcase, $option" 1
+
+    set options ""
+    lappend options "additional_flags=-w $option $shlib"
+    if { $additional_flags != "" } {
+	lappend options "additional_flags=$additional_flags";
+    }
+
+    set comp_output [${tool}_target_compile "$sources" "${executable}" executable $options];
+
+    if ![${tool}_check_compile "$testcase compilation" $option $executable $comp_output] {
+	unresolved "$testcase execution, $option"
+	remote_file build delete $executable
+	return
+    }
+
+    if [info exists torture_execute_xfail] {
+	setup_xfail $torture_execute_xfail
+    }
+
+    if [info exists torture_eval_before_execute] {
+	set ignore_me [eval $torture_eval_before_execute]
+    }
+
+    set result [${tool}_load "$executable" "" ""]
+    set status [lindex $result 0];
+    set output [lindex $result 1];
+    $status "$testcase execution, $option"
+    if { $status == "pass" } {
+	foreach file "$executable $shlib" {
+	    remote_file build delete $file
+	}
+    }
+}
diff --git a/gcc/testsuite/lib/scanasm.exp b/gcc/testsuite/lib/scanasm.exp
index 79d93cb..9116afc 100644
--- a/gcc/testsuite/lib/scanasm.exp
+++ b/gcc/testsuite/lib/scanasm.exp
@@ -79,6 +79,32 @@ proc scan-assembler-not { args } {
     dg-scan "scan-assembler-not" 0 $testcase $output_file $args
 }
 
+# Check that a symbol is defined as a hidden symbol in the .s file
+# produced by the compiler.
+
+proc scan-hidden { args } {
+    upvar 2 name testcase
+    set output_file "[file rootname [file tail $testcase]].s"
+
+    set symbol [lindex $args 0]
+    set args [lreplace $args 0 0 "hidden\[ \t_\]*$symbol"]
+
+    dg-scan "scan-hidden" 1 $testcase $output_file $args
+}
+
+# Check that a symbol is not defined as a hidden symbol in the .s file
+# produced by the compiler.
+
+proc scan-not-hidden { args } {
+    upvar 2 name testcase
+    set output_file "[file rootname [file tail $testcase]].s"
+
+    set symbol [lindex $args 0]
+    set args [lreplace $args 0 0 "hidden\[ \t_\]*$symbol"]
+
+    dg-scan "scan-not-hidden" 0 $testcase $output_file $args
+}
+
 # Look for a pattern in OUTPUT_FILE.  See dg-scan for details.
 
 proc scan-file { output_file args } {
diff --git a/gcc/testsuite/lib/target-supports.exp b/gcc/testsuite/lib/target-supports.exp
index a2dde90..b211d6b 100644
--- a/gcc/testsuite/lib/target-supports.exp
+++ b/gcc/testsuite/lib/target-supports.exp
@@ -488,3 +488,53 @@ proc is-effective-target-keyword { arg } {
 	}
     }
 }
+
+# Return 1 if the target support shared library.
+
+proc is-shared-library-supported { } {
+    # Shared library is only supported on a couple of ELF platforms.
+    if { ![istarget hppa*64*-*-hpux*] \
+	 && ![istarget hppa*-*-linux*] \
+	 && ![istarget i?86-*-sysv4*] \
+	 && ![istarget i?86-*-unixware] \
+	 && ![istarget i?86-*-elf*] \
+	 && ![istarget i?86-*-linux*] \
+	 && ![istarget ia64-*-elf*] \
+	 && ![istarget ia64-*-linux*] \
+	 && ![istarget m68k-*-linux*] \
+	 && ![istarget mips*-*-irix5*] \
+	 && ![istarget mips*-*-linux*] \
+	 && ![istarget powerpc-*-elf*] \
+	 && ![istarget powerpc-*-linux*] \
+	 && ![istarget powerpc-*-sysv4*] \
+	 && ![istarget sparc*-*-elf] \
+	 && ![istarget sparc*-*-solaris2*] \
+	 && ![istarget sparc*-*-linux*] \
+	 && ![istarget arm*-*-linux*] \
+	 && ![istarget alpha*-*-linux*] \
+	 && ![istarget s390*-*-linux*] \
+	 && ![istarget x86_64-*-linux*] } {
+	return 0
+    }
+
+    if { [istarget *-*-linux*aout*] \
+	 || [istarget *-*-linux*oldld*] } {
+	return 0
+    }
+
+    return 1
+}
+
+# Return gcc option to compile .o file for shared library.
+
+proc get-compile-shared-library-option { } {
+    set picflag "-fPIC"
+    return $picflag
+}
+
+# Return gcc option to build shared library.
+
+proc get-build-shared-library-option { } {
+    set ldflag "-shared"
+    return $ldflag
+}
diff --git a/gcc/tree.c b/gcc/tree.c
index a9b6d1a..0b25837 100644
--- a/gcc/tree.c
+++ b/gcc/tree.c
@@ -2563,6 +2563,11 @@ build_decl (enum tree_code code, tree name, tree type)
     layout_decl (t, 0);
   else if (code == FUNCTION_DECL)
     DECL_MODE (t) = FUNCTION_MODE;
+    
+  /* Set default visibility to whatever the user supplied with
+     visibility_specified depending on #pragma GCC visibility.  */
+  DECL_VISIBILITY (t) = default_visibility;
+  DECL_VISIBILITY_SPECIFIED (t) = visibility_options.inpragma;
 
   return t;
 }
diff --git a/gcc/tree.h b/gcc/tree.h
index 7a3ec26..68ae6d4 100644
--- a/gcc/tree.h
+++ b/gcc/tree.h
@@ -1499,6 +1499,10 @@ struct tree_type GTY(())
 /* Value of the decls's visibility attribute */
 #define DECL_VISIBILITY(NODE) (DECL_CHECK (NODE)->decl.visibility)
 
+/* Nonzero means that the decl had its visibility specified rather than
+   being inferred.  */
+#define DECL_VISIBILITY_SPECIFIED(NODE) (DECL_CHECK (NODE)->decl.visibility_specified)
+
 /* In a FUNCTION_DECL, nonzero if the function cannot be inlined.  */
 #define DECL_UNINLINABLE(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.uninlinable)
 
@@ -1633,7 +1637,8 @@ struct tree_type GTY(())
    || TREE_CODE (DECL_CONTEXT (EXP)) == TRANSLATION_UNIT_DECL)
 
 /* Enumerate visibility settings.  */
-
+#ifndef SYMBOL_VISIBILITY_DEFINED
+#define SYMBOL_VISIBILITY_DEFINED
 enum symbol_visibility
 {
   VISIBILITY_DEFAULT,
@@ -1641,6 +1646,7 @@ enum symbol_visibility
   VISIBILITY_HIDDEN,
   VISIBILITY_PROTECTED
 };
+#endif
 
 struct function;
 
@@ -1684,8 +1690,7 @@ struct tree_decl GTY(())
   unsigned thread_local_flag : 1;
   unsigned declared_inline_flag : 1;
   ENUM_BITFIELD(symbol_visibility) visibility : 2;
-  unsigned unused : 1;
-  /* one unused bit.  */
+  unsigned visibility_specified : 1;
 
   unsigned lang_flag_0 : 1;
   unsigned lang_flag_1 : 1;
diff --git a/gcc/varasm.c b/gcc/varasm.c
index 33307e5..3dc2866 100644
--- a/gcc/varasm.c
+++ b/gcc/varasm.c
@@ -535,6 +535,45 @@ function_section (tree decl)
     text_section ();
 }
 
+/* Switch to read-only data section associated with function DECL.
+
+   If DECL is NULL_TREE, switch to readonly_data_section ().  */
+
+void
+function_readonly_data_section (tree decl)
+{
+  if (decl != NULL_TREE && DECL_SECTION_NAME (decl))
+    {
+      const char *name = TREE_STRING_POINTER (DECL_SECTION_NAME (decl));
+
+      /* For .gnu.linkonce.t.foo we want to use .gnu.linkonce.r.foo.  */
+      if (DECL_ONE_ONLY (decl) && strncmp (name, ".gnu.linkonce.t.", 16) == 0)
+       {
+         size_t len = strlen (name) + 1;
+         char *rname = alloca (len);
+
+         memcpy (rname, name, len);
+         rname[14] = 'r';
+         named_section_flags (rname, SECTION_LINKONCE);
+         return;
+       }
+      /* For .text.foo we want to use .rodata.foo.  */
+      else if (flag_function_sections && flag_data_sections
+              && strncmp (name, ".text.", 6) == 0)
+       {
+         size_t len = strlen (name) + 1;
+         char *rname = alloca (len + 2);
+
+         memcpy (rname, ".rodata", 7);
+         memcpy (rname + 7, name + 5, len - 5);
+         named_section_flags (rname, 0);
+         return;
+       }
+    }
+
+  readonly_data_section ();
+}
+
 /* Switch to section for variable DECL.  RELOC is the same as the
    argument to SELECT_SECTION.  */
 
@@ -2066,6 +2105,11 @@ struct constant_descriptor_tree GTY(())
 
   /* The value of the constant.  */
   tree value;
+
+  /* Hash of value.  Computing the hash from value each time
+     hashfn is called can't work properly, as that means recursive
+     use of the hash table during hash table expansion.  */
+  hashval_t hash;
 };
 
 static GTY((param_is (struct constant_descriptor_tree)))
@@ -2079,7 +2123,7 @@ static void maybe_output_constant_def_contents (struct constant_descriptor_tree
 static hashval_t
 const_desc_hash (const void *ptr)
 {
-  return const_hash_1 (((struct constant_descriptor_tree *)ptr)->value);
+  return ((struct constant_descriptor_tree *)ptr)->hash;
 }
 
 static hashval_t
@@ -2193,8 +2237,11 @@ const_hash_1 (const tree exp)
 static int
 const_desc_eq (const void *p1, const void *p2)
 {
-  return compare_constant (((struct constant_descriptor_tree *)p1)->value,
-			   ((struct constant_descriptor_tree *)p2)->value);
+  const struct constant_descriptor_tree *c1 = p1;
+  const struct constant_descriptor_tree *c2 = p2;
+  if (c1->hash != c2->hash)
+    return 0;
+  return compare_constant (c1->value, c2->value);
 }
 
 /* Compare t1 and t2, and return 1 only if they are known to result in
@@ -2491,12 +2538,14 @@ output_constant_def (tree exp, int defer)
   /* Look up EXP in the table of constant descriptors.  If we didn't find
      it, create a new one.  */
   key.value = exp;
-  loc = htab_find_slot (const_desc_htab, &key, INSERT);
+  key.hash = const_hash_1 (exp);
+  loc = htab_find_slot_with_hash (const_desc_htab, &key, key.hash, INSERT);
 
   desc = *loc;
   if (desc == 0)
     {
       desc = build_constant_desc (exp);
+      desc->hash = key.hash;
       *loc = desc;
     }
 
@@ -2606,7 +2655,8 @@ lookup_constant_def (tree exp)
   struct constant_descriptor_tree key;
 
   key.value = exp;
-  desc = htab_find (const_desc_htab, &key);
+  key.hash = const_hash_1 (exp);
+  desc = htab_find_with_hash (const_desc_htab, &key, key.hash);
 
   return (desc ? desc->rtl : NULL_RTX);
 }
@@ -5211,8 +5261,8 @@ default_binds_local_p_1 (tree exp, int shlib)
   /* Static variables are always local.  */
   else if (! TREE_PUBLIC (exp))
     local_p = true;
-  /* A variable is local if the user tells us so.  */
-  else if (DECL_VISIBILITY (exp) != VISIBILITY_DEFAULT)
+  /* A variable is local if the user explicitly tells us so.  */
+  else if (DECL_VISIBILITY_SPECIFIED (exp) && DECL_VISIBILITY (exp) != VISIBILITY_DEFAULT)
     local_p = true;
   /* Otherwise, variables defined outside this object may not be local.  */
   else if (DECL_EXTERNAL (exp))
@@ -5220,6 +5270,9 @@ default_binds_local_p_1 (tree exp, int shlib)
   /* Linkonce and weak data are never local.  */
   else if (DECL_ONE_ONLY (exp) || DECL_WEAK (exp))
     local_p = false;
+  /* If none of the above and visibility is not default, make local.  */
+  else if (DECL_VISIBILITY (exp) != VISIBILITY_DEFAULT)
+    local_p = true;
   /* If PIC, then assume that any global name can be overridden by
      symbols resolved from other modules.  */
   else if (shlib)
diff --git a/libf2c/libI77/fio.h b/libf2c/libI77/fio.h
index 7734f0c..4515bbe 100644
--- a/libf2c/libI77/fio.h
+++ b/libf2c/libI77/fio.h
@@ -86,7 +86,7 @@ extern unit f__units[];
 #define errfl(f,m,s) do {return err__fl((int)f,m,s);} while(0)
 
 /*Table sizes*/
-#define MXUNIT 100
+#define MXUNIT 512
 
 extern int f__recpos;		/*position in current record */
 extern int f__cursor;		/* offset to move to */
diff --git a/libffi/configure b/libffi/configure
index 698ae01..851859f 100755
--- a/libffi/configure
+++ b/libffi/configure
@@ -1322,14 +1322,7 @@ irix5* | irix6*)
 
 # This must be Linux ELF.
 linux-gnu*)
-  case $host_cpu in
-  alpha* | mips* | hppa* | i*86 | powerpc* | sparc* | ia64* | sh* )
-    lt_cv_deplibs_check_method=pass_all ;;
-  *)
-    # glibc up to 2.1.1 does not perform some relocations on ARM
-    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )' ;;
-  esac
-  lt_cv_file_magic_test_file=`echo /lib/libc.so* /lib/libc-*.so`
+  lt_cv_deplibs_check_method=pass_all
   ;;
 
 netbsd*)
diff --git a/libffi/src/alpha/osf.S b/libffi/src/alpha/osf.S
index 2f03d62..36052b3 100644
--- a/libffi/src/alpha/osf.S
+++ b/libffi/src/alpha/osf.S
@@ -356,4 +356,8 @@ $LASFDE3:
 	.byte	16		# uleb128 offset 16*-8
 	.align 3
 $LEFDE3:
+
+#ifdef __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
 #endif
diff --git a/libffi/src/arm/sysv.S b/libffi/src/arm/sysv.S
index 0e41861..cf37b69 100644
--- a/libffi/src/arm/sysv.S
+++ b/libffi/src/arm/sysv.S
@@ -125,3 +125,6 @@ epilogue:
 .ffi_call_SYSV_end:
         .size    CNAME(ffi_call_SYSV),.ffi_call_SYSV_end-CNAME(ffi_call_SYSV)
 
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",%progbits
+#endif
diff --git a/libffi/src/ia64/ffi.c b/libffi/src/ia64/ffi.c
index c846f6e..8a7b8e0 100644
--- a/libffi/src/ia64/ffi.c
+++ b/libffi/src/ia64/ffi.c
@@ -547,7 +547,7 @@ ffi_prep_incoming_args_UNIX(struct ia64_args *args, void **rvalue,
   register unsigned int i;
   register unsigned int avn;
   register void **p_argv;
-  register unsigned long *argp = args -> out_regs;
+  register long *argp = args -> out_regs;
   unsigned fp_reg_num = 0;
   register ffi_type **p_arg;
 
@@ -576,17 +576,15 @@ ffi_prep_incoming_args_UNIX(struct ia64_args *args, void **rvalue,
 	case FFI_TYPE_FLOAT:
 	  z = 1;
 	  /* Convert argument back to float in place from the saved value */
-	  if (fp_reg_num < 8) {
+	  if (argp - args->out_regs < 8 && fp_reg_num < 8) {
 	      *(float *)argp = args -> fp_regs[fp_reg_num++];
-	  } else {
-	      *(float *)argp = *(double *)argp;
 	  }
 	  *p_argv = (void *)argp;
 	  break;
 
 	case FFI_TYPE_DOUBLE:
 	  z = 1;
-	  if (fp_reg_num < 8) {
+	  if (argp - args->out_regs < 8 && fp_reg_num < 8) {
 	      *p_argv = args -> fp_regs + fp_reg_num++;
 	  } else {
 	      *p_argv = (void *)argp;
@@ -598,7 +596,8 @@ ffi_prep_incoming_args_UNIX(struct ia64_args *args, void **rvalue,
 	      size_t sz = (*p_arg)->size;
 	      unsigned short element_type;
               z = ((*p_arg)->size + FFI_SIZEOF_ARG - 1)/FFI_SIZEOF_ARG;
-	      if (is_homogeneous_fp_aggregate(*p_arg, 8, &element_type)) {
+	      if (argp - args->out_regs < 8
+		  && is_homogeneous_fp_aggregate(*p_arg, 8, &element_type)) {
 		int nelements = sz/float_type_size(element_type);
 		if (nelements + fp_reg_num >= 8) {
 		  /* hard case NYI.	*/
diff --git a/libffi/src/ia64/unix.S b/libffi/src/ia64/unix.S
index be267f6..52851ed 100644
--- a/libffi/src/ia64/unix.S
+++ b/libffi/src/ia64/unix.S
@@ -325,3 +325,7 @@ ffi_closure_UNIX:
 	.endp ffi_closure_UNIX
 	
 
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/m68k/sysv.S b/libffi/src/m68k/sysv.S
index d019a37..24bb081 100644
--- a/libffi/src/m68k/sysv.S
+++ b/libffi/src/m68k/sysv.S
@@ -95,3 +95,7 @@ epilogue:
 	unlk	%a6
 	rts
 	.size	ffi_call_SYSV,.-ffi_call_SYSV
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/powerpc/linux64.S b/libffi/src/powerpc/linux64.S
index 11cf926..b78d319 100644
--- a/libffi/src/powerpc/linux64.S
+++ b/libffi/src/powerpc/linux64.S
@@ -174,3 +174,7 @@ ffi_call_LINUX64:
 	.align 3
 .LEFDE1:
 #endif
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/powerpc/linux64_closure.S b/libffi/src/powerpc/linux64_closure.S
index fa331db..5fb2f36 100644
--- a/libffi/src/powerpc/linux64_closure.S
+++ b/libffi/src/powerpc/linux64_closure.S
@@ -203,3 +203,7 @@ ffi_closure_LINUX64:
 	.align 3
 .LEFDE1:
 #endif
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/powerpc/ppc_closure.S b/libffi/src/powerpc/ppc_closure.S
index dce9dab..dda63a4 100644
--- a/libffi/src/powerpc/ppc_closure.S
+++ b/libffi/src/powerpc/ppc_closure.S
@@ -248,3 +248,7 @@ END(ffi_closure_SYSV)
 .LEFDE1:
 
 #endif
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/powerpc/sysv.S b/libffi/src/powerpc/sysv.S
index a7aaa3f..b4b2ffd 100644
--- a/libffi/src/powerpc/sysv.S
+++ b/libffi/src/powerpc/sysv.S
@@ -189,3 +189,7 @@ END(ffi_call_SYSV)
       .align 2
 .LEFDE1:
 #endif
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/s390/sysv.S b/libffi/src/s390/sysv.S
index e9cbed9..09cdec1 100644
--- a/libffi/src/s390/sysv.S
+++ b/libffi/src/s390/sysv.S
@@ -427,3 +427,6 @@ ffi_closure_SYSV:
 
 #endif
 
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/sparc/v8.S b/libffi/src/sparc/v8.S
index aaa7be7..b278306 100644
--- a/libffi/src/sparc/v8.S
+++ b/libffi/src/sparc/v8.S
@@ -255,3 +255,7 @@ done2:
 	.byte	0x1f	! uleb128 0x1f
 	.align	WS
 .LLEFDE2:
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/sparc/v9.S b/libffi/src/sparc/v9.S
index d640e02..a8e8bf9 100644
--- a/libffi/src/sparc/v9.S
+++ b/libffi/src/sparc/v9.S
@@ -300,3 +300,7 @@ longdouble1:
 	.align 8
 .LLEFDE2:
 #endif
+
+#ifdef __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/x86/sysv.S b/libffi/src/x86/sysv.S
index 53a4c2b..37e1e29 100644
--- a/libffi/src/x86/sysv.S
+++ b/libffi/src/x86/sysv.S
@@ -182,3 +182,7 @@ epilogue:
 .LEFDE1:
 
 #endif /* ifndef __x86_64__ */
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/x86/unix64.S b/libffi/src/x86/unix64.S
index 310fed7..9d75e7f 100644
--- a/libffi/src/x86/unix64.S
+++ b/libffi/src/x86/unix64.S
@@ -301,3 +301,7 @@ ffi_closure_UNIX64:
 .LEFDE3:
 
 #endif /* __x86_64__  */
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libiberty/Makefile.in b/libiberty/Makefile.in
index fc86feb..416948a 100644
--- a/libiberty/Makefile.in
+++ b/libiberty/Makefile.in
@@ -224,6 +224,7 @@ $(TARGETLIB): $(REQUIRED_OFILES) $(EXTRA_OFILES) $(LIBOBJS)
 	  $(AR) $(AR_FLAGS) $(TARGETLIB) \
 	    $(REQUIRED_OFILES) $(EXTRA_OFILES) $(LIBOBJS); \
 	  $(RANLIB) $(TARGETLIB); \
+	  cp $(TARGETLIB) ../ ; \
 	  cd ..; \
 	else true; fi
 
diff --git a/libiberty/splay-tree.c b/libiberty/splay-tree.c
index fc98db1..b1410aa 100644
--- a/libiberty/splay-tree.c
+++ b/libiberty/splay-tree.c
@@ -59,18 +59,59 @@ splay_tree_delete_helper (sp, node)
      splay_tree sp;
      splay_tree_node node;
 {
+  splay_tree_node pending = 0;
+  splay_tree_node active = 0;
+
   if (!node)
     return;
 
-  splay_tree_delete_helper (sp, node->left);
-  splay_tree_delete_helper (sp, node->right);
+#define KDEL(x)  if (sp->delete_key) (*sp->delete_key)(x);
+#define VDEL(x)  if (sp->delete_value) (*sp->delete_value)(x);
+
+  KDEL (node->key);
+  VDEL (node->value);
+
+  /* We use the "key" field to hold the "next" pointer.  */
+  node->key = (splay_tree_key)pending;
+  pending = (splay_tree_node)node;
+
+  /* Now, keep processing the pending list until there aren't any
+     more.  This is a little more complicated than just recursing, but
+     it doesn't toast the stack for large trees.  */
+
+  while (pending)
+    {
+      active = pending;
+      pending = 0;
+      while (active)
+	{
+	  splay_tree_node temp;
+
+	  /* active points to a node which has its key and value
+	     deallocated, we just need to process left and right.  */
 
-  if (sp->delete_key)
-    (*sp->delete_key)(node->key);
-  if (sp->delete_value)
-    (*sp->delete_value)(node->value);
+	  if (active->left)
+	    {
+	      KDEL (active->left->key);
+	      VDEL (active->left->value);
+	      active->left->key = (splay_tree_key)pending;
+	      pending = (splay_tree_node)(active->left);
+	    }
+	  if (active->right)
+	    {
+	      KDEL (active->right->key);
+	      VDEL (active->right->value);
+	      active->right->key = (splay_tree_key)pending;
+	      pending = (splay_tree_node)(active->right);
+	    }
 
-  (*sp->deallocate) ((char*) node, sp->allocate_data);
+	  temp = active;
+	  active = (splay_tree_node)(temp->key);
+	  (*sp->deallocate) ((char*) temp, sp->allocate_data);
+	}
+    }
+#undef KDEL
+#undef VDEL
 }
 
 /* Help splay SP around KEY.  PARENT and GRANDPARENT are the parent
diff --git a/libjava/configure b/libjava/configure
index 969bd91..5b72290 100755
--- a/libjava/configure
+++ b/libjava/configure
@@ -2033,14 +2033,7 @@ irix5* | irix6*)
 
 # This must be Linux ELF.
 linux-gnu*)
-  case $host_cpu in
-  alpha* | mips* | hppa* | i*86 | powerpc* | sparc* | ia64* | sh* )
-    lt_cv_deplibs_check_method=pass_all ;;
-  *)
-    # glibc up to 2.1.1 does not perform some relocations on ARM
-    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )' ;;
-  esac
-  lt_cv_file_magic_test_file=`echo /lib/libc.so* /lib/libc-*.so`
+  lt_cv_deplibs_check_method=pass_all
   ;;
 
 netbsd*)
@@ -4128,6 +4121,9 @@ use_gtk_awt=""
 # The default toolkit to use is the first one specified.
 TOOLKIT=
 
+if test -n "${with_multisubdir}"; then
+  peerlibs=no
+fi
 
 for peer in $peerlibs ; do
   case $peer in
diff --git a/libjava/configure.in b/libjava/configure.in
index 26f39cc..cbfc0b0 100644
--- a/libjava/configure.in
+++ b/libjava/configure.in
@@ -367,6 +367,10 @@ use_gtk_awt=""
 TOOLKIT=
 AC_SUBST(TOOLKIT)
 
+if test -n "${with_multisubdir}"; then
+  peerlibs=no
+fi
+
 for peer in $peerlibs ; do
   case $peer in
     xlib)
diff --git a/libjava/include/x86_64-signal.h b/libjava/include/x86_64-signal.h
index f9c8e23..23f4011 100644
--- a/libjava/include/x86_64-signal.h
+++ b/libjava/include/x86_64-signal.h
@@ -40,7 +40,7 @@ do									     \
   /* Advance the program counter so that it is after the start of the	     \
      instruction:  the x86_64 exception handler expects			     \
      the PC to point to the instruction after a call. */		     \
-  struct ucontext *_uc = (struct ucontext *)_p;				     \
+  ucontext_t *_uc = (ucontext_t *)_p;				     \
   volatile struct sigcontext *_sc = (struct sigcontext *) &_uc->uc_mcontext; \
   _sc->rip += 2;							     \
 }									     \
diff --git a/libobjc/configure b/libobjc/configure
index 55eb9ce..5b09e27 100755
--- a/libobjc/configure
+++ b/libobjc/configure
@@ -1612,14 +1612,7 @@ irix5* | irix6*)
 
 # This must be Linux ELF.
 linux-gnu*)
-  case $host_cpu in
-  alpha* | mips* | hppa* | i*86 | powerpc* | sparc* | ia64* | sh* )
-    lt_cv_deplibs_check_method=pass_all ;;
-  *)
-    # glibc up to 2.1.1 does not perform some relocations on ARM
-    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )' ;;
-  esac
-  lt_cv_file_magic_test_file=`echo /lib/libc.so* /lib/libc-*.so`
+  lt_cv_deplibs_check_method=pass_all
   ;;
 
 netbsd*)
diff --git a/libstdc++-v3/acinclude.m4 b/libstdc++-v3/acinclude.m4
index cf541ed..44c7559 100644
--- a/libstdc++-v3/acinclude.m4
+++ b/libstdc++-v3/acinclude.m4
@@ -274,7 +274,7 @@ AC_DEFUN([GLIBCXX_CHECK_LINKER_FEATURES], [
   # does some of this, but throws away the result.
   changequote(,)
   ldver=`$LD --version 2>/dev/null | head -1 | \
-         sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
+         sed -e 's/GNU ld \(version \)\{0,1\}\(([^)]*) \)\{0,1\}\([0-9.][0-9.]*\).*/\3/'`
   changequote([,])
   glibcxx_gnu_ld_version=`echo $ldver | \
          $AWK -F. '{ if (NF<3) [$]3=0; print ([$]1*100+[$]2)*100+[$]3 }'`
diff --git a/libstdc++-v3/configure b/libstdc++-v3/configure
index 4bb1ed3..b18c300 100755
--- a/libstdc++-v3/configure
+++ b/libstdc++-v3/configure
@@ -4002,14 +4002,7 @@ irix5* | irix6*)
 
 # This must be Linux ELF.
 linux-gnu*)
-  case $host_cpu in
-  alpha* | mips* | hppa* | i*86 | powerpc* | sparc* | ia64* | sh* )
-    lt_cv_deplibs_check_method=pass_all ;;
-  *)
-    # glibc up to 2.1.1 does not perform some relocations on ARM
-    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )' ;;
-  esac
-  lt_cv_file_magic_test_file=`echo /lib/libc.so* /lib/libc-*.so`
+  lt_cv_deplibs_check_method=pass_all
   ;;
 
 netbsd*)
@@ -8169,7 +8162,7 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
   # does some of this, but throws away the result.
 
   ldver=`$LD --version 2>/dev/null | head -1 | \
-         sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
+         sed -e 's/GNU ld \(version \)\{0,1\}\(([^)]*) \)\{0,1\}\([0-9.][0-9.]*\).*/\3/'`
 
   glibcxx_gnu_ld_version=`echo $ldver | \
          $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`
@@ -53532,7 +53525,7 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
   # does some of this, but throws away the result.
 
   ldver=`$LD --version 2>/dev/null | head -1 | \
-         sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
+         sed -e 's/GNU ld \(version \)\{0,1\}\(([^)]*) \)\{0,1\}\([0-9.][0-9.]*\).*/\3/'`
 
   glibcxx_gnu_ld_version=`echo $ldver | \
          $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`
@@ -75202,7 +75195,7 @@ done
   # does some of this, but throws away the result.
 
   ldver=`$LD --version 2>/dev/null | head -1 | \
-         sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
+         sed -e 's/GNU ld \(version \)\{0,1\}\(([^)]*) \)\{0,1\}\([0-9.][0-9.]*\).*/\3/'`
 
   glibcxx_gnu_ld_version=`echo $ldver | \
          $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`
@@ -77570,7 +77563,7 @@ done
   # does some of this, but throws away the result.
 
   ldver=`$LD --version 2>/dev/null | head -1 | \
-         sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
+         sed -e 's/GNU ld \(version \)\{0,1\}\(([^)]*) \)\{0,1\}\([0-9.][0-9.]*\).*/\3/'`
 
   glibcxx_gnu_ld_version=`echo $ldver | \
          $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`
@@ -79814,7 +79807,7 @@ done
   # does some of this, but throws away the result.
 
   ldver=`$LD --version 2>/dev/null | head -1 | \
-         sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
+         sed -e 's/GNU ld \(version \)\{0,1\}\(([^)]*) \)\{0,1\}\([0-9.][0-9.]*\).*/\3/'`
 
   glibcxx_gnu_ld_version=`echo $ldver | \
          $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`
@@ -82826,7 +82819,7 @@ done
   # does some of this, but throws away the result.
 
   ldver=`$LD --version 2>/dev/null | head -1 | \
-         sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
+         sed -e 's/GNU ld \(version \)\{0,1\}\(([^)]*) \)\{0,1\}\([0-9.][0-9.]*\).*/\3/'`
 
   glibcxx_gnu_ld_version=`echo $ldver | \
          $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`
@@ -85023,7 +85016,7 @@ done
   # does some of this, but throws away the result.
 
   ldver=`$LD --version 2>/dev/null | head -1 | \
-         sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
+         sed -e 's/GNU ld \(version \)\{0,1\}\(([^)]*) \)\{0,1\}\([0-9.][0-9.]*\).*/\3/'`
 
   glibcxx_gnu_ld_version=`echo $ldver | \
          $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`
@@ -87111,7 +87104,7 @@ _ACEOF
   # does some of this, but throws away the result.
 
   ldver=`$LD --version 2>/dev/null | head -1 | \
-         sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
+         sed -e 's/GNU ld \(version \)\{0,1\}\(([^)]*) \)\{0,1\}\([0-9.][0-9.]*\).*/\3/'`
 
   glibcxx_gnu_ld_version=`echo $ldver | \
          $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`
@@ -91166,7 +91159,7 @@ done
   # does some of this, but throws away the result.
 
   ldver=`$LD --version 2>/dev/null | head -1 | \
-         sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
+         sed -e 's/GNU ld \(version \)\{0,1\}\(([^)]*) \)\{0,1\}\([0-9.][0-9.]*\).*/\3/'`
 
   glibcxx_gnu_ld_version=`echo $ldver | \
          $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`
diff --git a/libstdc++-v3/docs/doxygen/filter b/libstdc++-v3/docs/doxygen/filter
index 4ea2d41..9ef4e6c 100755
--- a/libstdc++-v3/docs/doxygen/filter
+++ b/libstdc++-v3/docs/doxygen/filter
@@ -1,5 +1,7 @@
 #!/bin/sh
 
+export LC_ALL=C
+
 script=$1
 file=$2
 
diff --git a/libstdc++-v3/include/bits/allocator.h b/libstdc++-v3/include/bits/allocator.h
index c9200ec..c23b544 100644
--- a/libstdc++-v3/include/bits/allocator.h
+++ b/libstdc++-v3/include/bits/allocator.h
@@ -51,6 +51,8 @@
 // Define the base class to std::allocator.
 #include <bits/c++allocator.h>
 
+#pragma GCC visibility push(default)
+
 namespace std
 {
   template<typename _Tp>
@@ -127,4 +129,6 @@ namespace std
 #undef ___glibcxx_base_allocator
 } // namespace std
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/bits/basic_string.h b/libstdc++-v3/include/bits/basic_string.h
index 04e1500..3d33265 100644
--- a/libstdc++-v3/include/bits/basic_string.h
+++ b/libstdc++-v3/include/bits/basic_string.h
@@ -45,6 +45,8 @@
 #include <bits/atomicity.h>
 #include <debug/debug.h>
 
+#pragma GCC visibility push(default)
+
 namespace std
 {
   /**
@@ -2362,4 +2364,6 @@ namespace std
 	    basic_string<_CharT, _Traits, _Alloc>& __str);
 } // namespace std
 
+#pragma GCC visibility pop
+
 #endif /* _BASIC_STRING_H */
diff --git a/libstdc++-v3/include/std/std_fstream.h b/libstdc++-v3/include/std/std_fstream.h
index 3dec366..ca02160 100644
--- a/libstdc++-v3/include/std/std_fstream.h
+++ b/libstdc++-v3/include/std/std_fstream.h
@@ -49,6 +49,8 @@
 #include <bits/basic_file.h>
 #include <bits/gthr.h>
 
+#pragma GCC visibility push(default)
+
 namespace std
 {
   // [27.8.1.1] template class basic_filebuf
@@ -840,4 +842,6 @@ namespace std
 # include <bits/fstream.tcc>
 #endif
 
+#pragma GCC visibility pop
+
 #endif /* _GLIBCXX_FSTREAM */
diff --git a/libstdc++-v3/include/std/std_istream.h b/libstdc++-v3/include/std/std_istream.h
index a3a53ba..5822ad7 100644
--- a/libstdc++-v3/include/std/std_istream.h
+++ b/libstdc++-v3/include/std/std_istream.h
@@ -45,6 +45,8 @@
 #include <ios>
 #include <limits> // For numeric_limits
 
+#pragma GCC visibility push(default)
+
 namespace std
 {
   // [27.6.1.1] Template class basic_istream
@@ -771,4 +773,6 @@ namespace std
 # include <bits/istream.tcc>
 #endif
 
+#pragma GCC visibility pop
+
 #endif	/* _GLIBCXX_ISTREAM */
diff --git a/libstdc++-v3/include/std/std_ostream.h b/libstdc++-v3/include/std/std_ostream.h
index e3590f2..c8b9e0f 100644
--- a/libstdc++-v3/include/std/std_ostream.h
+++ b/libstdc++-v3/include/std/std_ostream.h
@@ -44,6 +44,8 @@
 
 #include <ios>
 
+#pragma GCC visibility push(default)
+
 namespace std
 {
   // [27.6.2.1] Template class basic_ostream
@@ -545,4 +547,6 @@ namespace std
 # include <bits/ostream.tcc>
 #endif
 
+#pragma GCC visibility pop
+
 #endif	/* _GLIBCXX_OSTREAM */
diff --git a/libstdc++-v3/src/Makefile.am b/libstdc++-v3/src/Makefile.am
index ed4c710..80534b2 100644
--- a/libstdc++-v3/src/Makefile.am
+++ b/libstdc++-v3/src/Makefile.am
@@ -210,6 +210,13 @@ CXXLINK = $(LIBTOOL) --tag CXX --mode=link $(CXX) \
 	  $(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) $(LDFLAGS) -o $@
 
 
+install-exec-local:
+	pic_objs=`sed -n "s:'::g;s:^pic_object=::p" *.lo | grep -v '^none$$'`; \
+	if [ x"$$pic_objs" != x ]; then \
+		$(AR) cru libstdc++_pic.a $$pic_objs $(top_builddir)/libsupc++/*.o || exit 1; \
+		$(INSTALL_DATA) libstdc++_pic.a $(DESTDIR)$(toolexeclibdir) || exit 1; \
+	fi
+
 # Added bits to build debug library.
 if GLIBCXX_BUILD_DEBUG
 all-local: build_debug
diff --git a/libstdc++-v3/src/Makefile.in b/libstdc++-v3/src/Makefile.in
index 1fae145..88970eb 100644
--- a/libstdc++-v3/src/Makefile.in
+++ b/libstdc++-v3/src/Makefile.in
@@ -592,7 +592,7 @@ info-am:
 
 install-data-am: install-data-local
 
-install-exec-am: install-toolexeclibLTLIBRARIES
+install-exec-am: install-toolexeclibLTLIBRARIES install-exec-local
 
 install-info: install-info-am
 
@@ -625,6 +625,7 @@ uninstall-am: uninstall-info-am uninstall-toolexeclibLTLIBRARIES
 	distclean-tags distdir dvi dvi-am info info-am install \
 	install-am install-data install-data-am install-data-local \
 	install-exec install-exec-am install-info install-info-am \
+	install-exec-local \
 	install-man install-strip install-toolexeclibLTLIBRARIES \
 	installcheck installcheck-am installdirs maintainer-clean \
 	maintainer-clean-generic mostlyclean mostlyclean-compile \
@@ -709,6 +710,14 @@ build_debug: stamp-debug
 install_debug:
 	(cd ${debugdir} && $(MAKE) \
 	toolexeclibdir=$(glibcxx_toolexeclibdir)/debug install)
+
+install-exec-local:
+	pic_objs=`sed -n "s:'::g;s:^pic_object=::p" *.lo | grep -v '^none$$'`; \
+	if [ x"$$pic_objs" != x ]; then \
+		$(AR) cru libstdc++_pic.a $$pic_objs $(top_builddir)/libsupc++/*.o || exit 1; \
+		$(INSTALL_DATA) libstdc++_pic.a $(DESTDIR)$(toolexeclibdir) || exit 1; \
+	fi
+
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
 .NOEXPORT:
diff --git a/libtool.m4 b/libtool.m4
index 5afbd02..cfd02b4 100644
--- a/libtool.m4
+++ b/libtool.m4
@@ -679,14 +679,7 @@ irix5* | irix6*)
 
 # This must be Linux ELF.
 linux-gnu*)
-  case $host_cpu in
-  alpha* | mips* | hppa* | i*86 | powerpc* | sparc* | ia64* | sh* )
-    lt_cv_deplibs_check_method=pass_all ;;
-  *)
-    # glibc up to 2.1.1 does not perform some relocations on ARM
-    lt_cv_deplibs_check_method=['file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )'] ;;
-  esac
-  lt_cv_file_magic_test_file=`echo /lib/libc.so* /lib/libc-*.so`
+  lt_cv_deplibs_check_method=pass_all
   ;;
 
 netbsd*)
diff --git a/zlib/configure b/zlib/configure
index 1f87a53..06b517e 100755
--- a/zlib/configure
+++ b/zlib/configure
@@ -1579,14 +1579,7 @@ irix5* | irix6*)
 
 # This must be Linux ELF.
 linux-gnu*)
-  case $host_cpu in
-  alpha* | mips* | hppa* | i*86 | powerpc* | sparc* | ia64* | sh* )
-    lt_cv_deplibs_check_method=pass_all ;;
-  *)
-    # glibc up to 2.1.1 does not perform some relocations on ARM
-    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )' ;;
-  esac
-  lt_cv_file_magic_test_file=`echo /lib/libc.so* /lib/libc-*.so`
+  lt_cv_deplibs_check_method=pass_all
   ;;
 
 netbsd*)
