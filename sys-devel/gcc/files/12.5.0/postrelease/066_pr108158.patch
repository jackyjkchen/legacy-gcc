diff --git a/gcc/cp/constexpr.cc b/gcc/cp/constexpr.cc
index 1c615074a..76d1fb43b 100644
--- a/gcc/cp/constexpr.cc
+++ b/gcc/cp/constexpr.cc
@@ -4032,10 +4032,6 @@ cxx_eval_array_reference (const constexpr_ctx *ctx, tree t,
   if (!SCALAR_TYPE_P (elem_type))
     {
       new_ctx = *ctx;
-      if (ctx->object)
-	/* If there was no object, don't add one: it could confuse us
-	   into thinking we're modifying a const object.  */
-	new_ctx.object = t;
       new_ctx.ctor = build_constructor (elem_type, NULL);
       ctx = &new_ctx;
     }
diff --git a/gcc/testsuite/g++.dg/cpp1y/constexpr-108158.C b/gcc/testsuite/g++.dg/cpp1y/constexpr-108158.C
new file mode 100644
index 000000000..e5f5e9954
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/constexpr-108158.C
@@ -0,0 +1,32 @@
+// PR c++/108158
+// { dg-do compile { target c++14 } }
+
+template <class T, int N> struct carray {
+  T data_[N]{};
+  constexpr T operator[](long index) const { return data_[index]; }
+};
+struct seed_or_index {
+private:
+  long value_ = 0;
+};
+template <int M> struct pmh_tables {
+  carray<seed_or_index, M> first_table_;
+  template <typename KeyType, typename HasherType>
+  constexpr void lookup(KeyType, HasherType) const {
+    first_table_[0];
+  }
+};
+template <int N> struct unordered_set {
+  int equal_;
+  carray<int, N> keys_;
+  pmh_tables<N> tables_;
+  constexpr unordered_set() : equal_{} {}
+  template <class KeyType, class Hasher>
+  constexpr auto lookup(KeyType key, Hasher hash) const {
+    tables_.lookup(key, hash);
+    return keys_;
+  }
+};
+constexpr unordered_set<3> ze_set;
+constexpr auto nocount = ze_set.lookup(4, int());
+constexpr auto nocount2 = unordered_set<3>{}.lookup(4, int());
