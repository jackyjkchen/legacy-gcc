diff --git a/boehm-gc/ia64_save_regs_in_stack.S b/boehm-gc/ia64_save_regs_in_stack.S
new file mode 100644
index 00000000..632913db
--- /dev/null
+++ b/boehm-gc/ia64_save_regs_in_stack.S
@@ -0,0 +1,15 @@
+        .text
+        .align 16
+        .global GC_save_regs_in_stack
+        .proc GC_save_regs_in_stack
+GC_save_regs_in_stack:
+        .body
+        flushrs
+        ;;
+        mov r8=ar.bsp
+        br.ret.sptk.few rp
+        .endp GC_save_regs_in_stack
+
+#ifdef __linux__
+	.section .note.GNU-stack,"",@progbits
+#endif
diff --git a/boehm-gc/ia64_save_regs_in_stack.s b/boehm-gc/ia64_save_regs_in_stack.s
index 3b18c084..e69de29b 100644
--- a/boehm-gc/ia64_save_regs_in_stack.s
+++ b/boehm-gc/ia64_save_regs_in_stack.s
@@ -1,12 +0,0 @@
-        .text
-        .align 16
-        .global GC_save_regs_in_stack
-        .proc GC_save_regs_in_stack
-GC_save_regs_in_stack:
-        .body
-        flushrs
-        ;;
-        mov r8=ar.bsp
-        br.ret.sptk.few rp
-        .endp GC_save_regs_in_stack
-
diff --git a/gcc/Makefile.in b/gcc/Makefile.in
index f50ea07b..43f44c5a 100644
--- a/gcc/Makefile.in
+++ b/gcc/Makefile.in
@@ -3801,7 +3801,7 @@ cpp.pod: cpp.texi cppenv.texi cppopts.texi
 # These next rules exist because the output name is not the same as
 # the input name, so our implicit %.pod rule will not work.
 
-gcc.pod: invoke.texi cppenv.texi cppopts.texi
+gcc.pod: invoke.texi cppenv.texi cppopts.texi gcc-vers.texi
 	$(STAMP) $@
 	-$(TEXI2POD) $< > $@
 gfdl.pod: fdl.texi
diff --git a/gcc/config.gcc b/gcc/config.gcc
index 2e5cf8ee..212e3f82 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -354,7 +354,7 @@ rs6000*-*-*)
 score*-*-*)
 	cpu_type=score
 	;;
-sparc64*-*-*)
+sparc*-*-*)
 	cpu_type=sparc
 	need_64bit_hwint=yes
 	;;
@@ -462,7 +462,7 @@ case ${target} in
   # pleases around the provided core setting.
   gas=yes
   gnu_ld=yes
-  extra_parts="crtbegin.o crtend.o crtbeginS.o crtendS.o"
+  extra_parts="crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o"
   fbsd_major=`echo ${target} | sed -e 's/.*freebsd//g' | sed -e 's/\..*//g'`
   tm_defines="${tm_defines} FBSD_MAJOR=${fbsd_major}"
   tmake_file="t-slibgcc-elf-ver t-freebsd"
@@ -1117,6 +1117,10 @@ i[34567]86-*-beoself* | i[34567]86-*-beos*)
 	;;
 i[34567]86-*-freebsd*)
 	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h ${fbsd_tm_file} i386/freebsd.h"
+	fbsd_major=`echo ${target} | sed -e 's/.*freebsd//g' | sed -e 's/\..*//g'`
+	if test ${fbsd_major} -ge 7; then
+		tmake_file="${tmake_file} t-freebsd-eh"
+	fi
 	;;
 x86_64-*-freebsd*)
 	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h ${fbsd_tm_file} i386/x86-64.h i386/freebsd.h i386/freebsd64.h"
@@ -2277,7 +2281,7 @@ sh-*-symbianelf* | sh[12346l]*-*-symbianelf* | \
 	if test x${sh_multilibs} = x ; then
 		case ${target} in
 		sh64-superh-linux* | \
-		sh[1234]*)	sh_multilibs=${sh_cpu_target} ;;
+		sh[1234]*)	sh_multilibs=`cd ${srcdir}/config/sh ; echo t-mlib-sh[1-4]* | sed 's:t-mlib-sh:,m:g;s: ::g'` ;;
 		sh64* | sh5*)	sh_multilibs=m5-32media,m5-32media-nofpu,m5-compact,m5-compact-nofpu,m5-64media,m5-64media-nofpu ;;
 		sh-superh-*)	sh_multilibs=m4,m4-single,m4-single-only,m4-nofpu ;;
 		sh*-*-linux*)	sh_multilibs=m1,m3e,m4 ;;
@@ -2343,9 +2347,15 @@ sparc-*-elf*)
 	use_fixproto=yes
 	;;
 sparc-*-linux*)		# SPARC's running GNU/Linux, libc6
-	tm_file="${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sparc/gas.h sparc/linux.h"
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sparc/gas.h linux.h"
 	extra_options="${extra_options} sparc/long-double-switch.opt"
-	tmake_file="${tmake_file} sparc/t-linux sparc/t-crtfm"
+	if test x$enable_targets = xall; then
+		tm_file="sparc/biarch64.h ${tm_file} sparc/linux64.h"
+		tmake_file="${tmake_file} sparc/t-linux64 sparc/t-crtfm"
+	else
+		tm_file="${tm_file} sparc/linux.h"
+		tmake_file="${tmake_file} sparc/t-linux sparc/t-crtfm"
+	fi
 	;;
 sparc-*-rtems*)
 	tm_file="${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sparc/sp-elf.h sparc/rtemself.h rtems.h"
@@ -2477,7 +2487,7 @@ sparc64-*-freebsd*|ultrasparc-*-freebsd*)
 	need_64bit_hwint=yes
 	;;
 sparc64-*-linux*)		# 64-bit SPARC's running GNU/Linux
-	tm_file="sparc/biarch64.h ${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sparc/gas.h sparc/linux64.h"
+	tm_file="sparc/biarch64.h ${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sparc/gas.h linux.h sparc/linux64.h"
 	extra_options="${extra_options} sparc/long-double-switch.opt"
 	tmake_file="${tmake_file} sparc/t-linux sparc/t-linux64 sparc/t-crtfm"
 	;;
@@ -2888,8 +2898,9 @@ case "${target}" in
 
 		case "$with_arch" in
 		"" \
-		| armv[23456] | armv2a | armv3m | armv4t | armv5t \
+		| armv[234567] | armv2a | armv3m | armv4t | armv5t \
 		| armv5te | armv6j |armv6k | armv6z | armv6zk \
+		| armv7-a | armv7-m | armv7-r \
 		| iwmmxt | ep9312)
 			# OK
 			;;
@@ -3160,7 +3171,7 @@ case "${target}" in
 		for which in arch tune; do
 			eval "val=\$with_$which"
 			case ${val} in
-			"" | g5 | g6 | z900 | z990 | z9-109 | z9-ec)
+			"" | g5 | g6 | z900 | z990 | z9-109 | z9-ec | z10)
 				# OK
 				;;
 			*)
diff --git a/gcc/config/alpha/alpha.h b/gcc/config/alpha/alpha.h
index b0019bf2..07ccfbb6 100644
--- a/gcc/config/alpha/alpha.h
+++ b/gcc/config/alpha/alpha.h
@@ -95,6 +95,8 @@ along with GCC; see the file COPYING3.  If not see
   while (0)
 #endif
 
+#define CPP_SPEC "%{!no-ieee:-mieee}"
+
 #define WORD_SWITCH_TAKES_ARG(STR)		\
  (!strcmp (STR, "rpath") || DEFAULT_WORD_SWITCH_TAKES_ARG(STR))
 
diff --git a/gcc/config/alpha/alpha.opt b/gcc/config/alpha/alpha.opt
index fb7db377..e1172135 100644
--- a/gcc/config/alpha/alpha.opt
+++ b/gcc/config/alpha/alpha.opt
@@ -39,7 +39,7 @@ Target RejectNegative Mask(IEEE_CONFORMANT)
 Request IEEE-conformant math library routines (OSF/1)
 
 mieee
-Target Report RejectNegative Mask(IEEE)
+Target Report Mask(IEEE)
 Emit IEEE-conformant code, without inexact exceptions
 
 mieee-with-inexact
diff --git a/gcc/config/alpha/elf.h b/gcc/config/alpha/elf.h
index 6588f750..84b63f51 100644
--- a/gcc/config/alpha/elf.h
+++ b/gcc/config/alpha/elf.h
@@ -46,7 +46,7 @@ along with GCC; see the file COPYING3.  If not see
 #define CC1_SPEC  "%{G*}"
 
 #undef  ASM_SPEC
-#define ASM_SPEC  "%{G*} %{relax:-relax} %{!gstabs*:-no-mdebug}%{gstabs*:-mdebug}"
+#define ASM_SPEC  "%{G*} %{relax:-relax} %{!gstabs*:-no-mdebug}%{gstabs*:-mdebug} %{mcpu=*:-m%*}"
 
 #undef  IDENT_ASM_OP
 #define IDENT_ASM_OP "\t.ident\t"
diff --git a/gcc/config/alpha/linux-unwind.h b/gcc/config/alpha/linux-unwind.h
index 23151ad3..c03f2ac9 100644
--- a/gcc/config/alpha/linux-unwind.h
+++ b/gcc/config/alpha/linux-unwind.h
@@ -52,8 +52,8 @@ alpha_fallback_frame_state (struct _Unwind_Context *context,
   else if (pc[1] == 0x201f015f)	/* lda $0,NR_rt_sigreturn */
     {
       struct rt_sigframe {
-	struct siginfo info;
-	struct ucontext uc;
+	siginfo_t info;
+	ucontext_t uc;
       } *rt_ = context->cfa;
       sc = &rt_->uc.uc_mcontext;
     }
diff --git a/gcc/config/arm/arm.c b/gcc/config/arm/arm.c
index 90bbb107..912ec8ab 100644
--- a/gcc/config/arm/arm.c
+++ b/gcc/config/arm/arm.c
@@ -62,6 +62,7 @@ const struct attribute_spec arm_attribute_table[];
 void (*arm_lang_output_object_attributes_hook)(void);
 
 /* Forward function declarations.  */
+static int arm_compute_static_chain_stack_bytes (void);
 static arm_stack_offsets *arm_get_frame_offsets (void);
 static void arm_add_gc_roots (void);
 static int arm_gen_constant (enum rtx_code, enum machine_mode, rtx,
@@ -3372,7 +3373,8 @@ require_pic_register (void)
       gcc_assert (can_create_pseudo_p ());
       if (arm_pic_register != INVALID_REGNUM)
 	{
-	  cfun->machine->pic_reg = gen_rtx_REG (Pmode, arm_pic_register);
+	  if (!cfun->machine->pic_reg)
+	    cfun->machine->pic_reg = gen_rtx_REG (Pmode, arm_pic_register);
 
 	  /* Play games to avoid marking the function as needing pic
 	     if we are being called as part of the cost-estimation
@@ -3384,7 +3386,8 @@ require_pic_register (void)
 	{
 	  rtx seq;
 
-	  cfun->machine->pic_reg = gen_reg_rtx (Pmode);
+	  if (!cfun->machine->pic_reg)
+	    cfun->machine->pic_reg = gen_reg_rtx (Pmode);
 
 	  /* Play games to avoid marking the function as needing pic
 	     if we are being called as part of the cost-estimation
@@ -3769,6 +3772,7 @@ arm_legitimate_address_p (enum machine_mode mode, rtx x, RTX_CODE outer,
       rtx xop1 = XEXP (x, 1);
 
       return ((arm_address_register_rtx_p (xop0, strict_p)
+	       && GET_CODE(xop1) == CONST_INT
 	       && arm_legitimate_index_p (mode, xop1, outer, strict_p))
 	      || (arm_address_register_rtx_p (xop1, strict_p)
 		  && arm_legitimate_index_p (mode, xop0, outer, strict_p)));
@@ -10753,6 +10757,24 @@ arm_compute_save_reg0_reg12_mask (void)
 }
 
 
+/* Compute the number of bytes used to store the static chain register on the 
+   stack, above the stack frame. We need to know this accurately to get the
+   alignment of the rest of the stack frame correct. */
+
+static int arm_compute_static_chain_stack_bytes (void)
+{
+  unsigned long func_type = arm_current_func_type ();
+  int static_chain_stack_bytes = 0;
+
+  if (frame_pointer_needed && TARGET_ARM &&
+      IS_NESTED (func_type) &&
+      df_regs_ever_live_p (3) && current_function_pretend_args_size == 0)
+    static_chain_stack_bytes = 4;
+
+  return static_chain_stack_bytes;
+}
+
+
 /* Compute a bit mask of which registers need to be
    saved on the stack for the current function.  */
 
@@ -10804,7 +10826,9 @@ arm_compute_save_reg_mask (void)
 
   if (TARGET_REALLY_IWMMXT
       && ((bit_count (save_reg_mask)
-	   + ARM_NUM_INTS (current_function_pretend_args_size)) % 2) != 0)
+	   + ARM_NUM_INTS (current_function_pretend_args_size + 
+			   arm_compute_static_chain_stack_bytes())
+	  ) % 2) != 0)
     {
       /* The total number of registers that are going to be pushed
 	 onto the stack is odd.  We need to ensure that the stack
@@ -10889,6 +10913,26 @@ thumb1_compute_save_reg_mask (void)
 	mask |= 1 << reg;
     }
 
+  /* The 504 below is 8 bytes less than 512 because there are two possible
+     alignment words.  We can't tell here if they will be present or not so we
+     have to play it safe and assume that they are. */
+  if ((CALLER_INTERWORKING_SLOT_SIZE +
+       ROUND_UP_WORD (get_frame_size ()) +
+       current_function_outgoing_args_size) >= 504)
+    {
+      /* This is the same as the code in thumb1_expand_prologue() which
+	 determines which register to use for stack decrement. */
+      for (reg = LAST_ARG_REGNUM + 1; reg <= LAST_LO_REGNUM; reg++)
+	if (mask & (1 << reg))
+	  break;
+
+      if (reg > LAST_LO_REGNUM)
+	{
+	  /* Make sure we have a register available for stack decrement. */
+	  mask |= 1 << LAST_LO_REGNUM;
+	}
+    }
+
   return mask;
 }
 
@@ -11926,7 +11970,13 @@ thumb_force_lr_save (void)
   from the soft frame pointer to the hard frame pointer.
 
   SFP may point just inside the local variables block to ensure correct
-  alignment.  */
+  alignment.
+
+  FIXME: Under some circumstances arm_expand_prologue() may save the static
+  chain register on the stack before the normal function prologue.  For 
+  historical reasons all our offsets are wrong in this case, and
+  arm_compute_static_chain_stack_bytes is used to compensate.
+  arm_compute_initial_elimination_offset uses the same correction.  */
 
 
 /* Calculate stack offsets.  These are used to calculate register elimination
@@ -12032,9 +12082,11 @@ arm_get_frame_offsets (void)
   if (ARM_DOUBLEWORD_ALIGN)
     {
       /* Ensure SP remains doubleword aligned.  */
-      if (offsets->outgoing_args & 7)
+      if ((offsets->outgoing_args +
+	   arm_compute_static_chain_stack_bytes()) & 7)
 	offsets->outgoing_args += 4;
-      gcc_assert (!(offsets->outgoing_args & 7));
+      gcc_assert (!((offsets->outgoing_args +
+		     arm_compute_static_chain_stack_bytes()) & 7));
     }
 
   return offsets;
@@ -12069,14 +12121,9 @@ arm_compute_initial_elimination_offset (unsigned int from, unsigned int to)
 	  return offsets->soft_frame - offsets->saved_args;
 
 	case ARM_HARD_FRAME_POINTER_REGNUM:
-	  /* If there is no stack frame then the hard
-	     frame pointer and the arg pointer coincide.  */
-	  if (offsets->frame == offsets->saved_regs)
-	    return 0;
-	  /* FIXME:  Not sure about this.  Maybe we should always return 0 ?  */
-	  return (frame_pointer_needed
-		  && cfun->static_chain_decl != NULL
-		  && ! cfun->machine->uses_anonymous_args) ? 4 : 0;
+	  /* This is only non-zero in the case where the static chain register
+	     is stored above the frame.  */
+	  return arm_compute_static_chain_stack_bytes();
 
 	case STACK_POINTER_REGNUM:
 	  /* If nothing has been pushed on the stack at all
@@ -12347,6 +12394,8 @@ arm_expand_prologue (void)
 	    insn = emit_set_insn (gen_rtx_REG (SImode, 3), ip_rtx);
 	  else if (args_to_push == 0)
 	    {
+	      gcc_assert(arm_compute_static_chain_stack_bytes() == 4);
+
 	      rtx dwarf;
 
 	      insn = gen_rtx_PRE_DEC (SImode, stack_pointer_rtx);
@@ -16827,62 +16876,25 @@ thumb1_expand_prologue (void)
 	     been pushed at the start of the prologue and so we can corrupt
 	     it now.  */
 	  for (regno = LAST_ARG_REGNUM + 1; regno <= LAST_LO_REGNUM; regno++)
-	    if (live_regs_mask & (1 << regno)
-		&& !(frame_pointer_needed
-		     && (regno == THUMB_HARD_FRAME_POINTER_REGNUM)))
+	    if (live_regs_mask & (1 << regno))
 	      break;
 
-	  if (regno > LAST_LO_REGNUM) /* Very unlikely.  */
-	    {
-	      rtx spare = gen_rtx_REG (SImode, IP_REGNUM);
-
-	      /* Choose an arbitrary, non-argument low register.  */
-	      reg = gen_rtx_REG (SImode, LAST_LO_REGNUM);
-
-	      /* Save it by copying it into a high, scratch register.  */
-	      emit_insn (gen_movsi (spare, reg));
-	      /* Add a USE to stop propagate_one_insn() from barfing.  */
-	      emit_insn (gen_prologue_use (spare));
+	  gcc_assert(regno <= LAST_LO_REGNUM);
 
-	      /* Decrement the stack.  */
-	      emit_insn (gen_movsi (reg, GEN_INT (- amount)));
-	      insn = emit_insn (gen_addsi3 (stack_pointer_rtx,
-					    stack_pointer_rtx, reg));
-	      RTX_FRAME_RELATED_P (insn) = 1;
-	      dwarf = gen_rtx_SET (VOIDmode, stack_pointer_rtx,
-				   plus_constant (stack_pointer_rtx,
-						  -amount));
-	      RTX_FRAME_RELATED_P (dwarf) = 1;
-	      REG_NOTES (insn)
-		= gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, dwarf,
-				     REG_NOTES (insn));
-
-	      /* Restore the low register's original value.  */
-	      emit_insn (gen_movsi (reg, spare));
-
-	      /* Emit a USE of the restored scratch register, so that flow
-		 analysis will not consider the restore redundant.  The
-		 register won't be used again in this function and isn't
-		 restored by the epilogue.  */
-	      emit_insn (gen_prologue_use (reg));
-	    }
-	  else
-	    {
-	      reg = gen_rtx_REG (SImode, regno);
+	  reg = gen_rtx_REG (SImode, regno);
 
-	      emit_insn (gen_movsi (reg, GEN_INT (- amount)));
+	  emit_insn (gen_movsi (reg, GEN_INT (- amount)));
 
-	      insn = emit_insn (gen_addsi3 (stack_pointer_rtx,
-					    stack_pointer_rtx, reg));
-	      RTX_FRAME_RELATED_P (insn) = 1;
-	      dwarf = gen_rtx_SET (VOIDmode, stack_pointer_rtx,
-				   plus_constant (stack_pointer_rtx,
-						  -amount));
-	      RTX_FRAME_RELATED_P (dwarf) = 1;
-	      REG_NOTES (insn)
-		= gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, dwarf,
-				     REG_NOTES (insn));
-	    }
+	  insn = emit_insn (gen_addsi3 (stack_pointer_rtx,
+					stack_pointer_rtx, reg));
+	  RTX_FRAME_RELATED_P (insn) = 1;
+	  dwarf = gen_rtx_SET (VOIDmode, stack_pointer_rtx,
+			       plus_constant (stack_pointer_rtx,
+					      -amount));
+	  RTX_FRAME_RELATED_P (dwarf) = 1;
+	  REG_NOTES (insn)
+	    = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, dwarf,
+				 REG_NOTES (insn));
 	}
     }
 
diff --git a/gcc/config/arm/arm.h b/gcc/config/arm/arm.h
index 2b83335c..ad48cf36 100644
--- a/gcc/config/arm/arm.h
+++ b/gcc/config/arm/arm.h
@@ -1103,6 +1103,7 @@ enum reg_class
   STACK_REG,
   BASE_REGS,
   HI_REGS,
+  HILO_REGS,
   CC_REG,
   VFPCC_REG,
   GENERAL_REGS,
@@ -1128,6 +1129,7 @@ enum reg_class
   "STACK_REG",		\
   "BASE_REGS",		\
   "HI_REGS",		\
+  "HILO_REGS",		\
   "CC_REG",		\
   "VFPCC_REG",		\
   "GENERAL_REGS",	\
@@ -1152,6 +1154,7 @@ enum reg_class
   { 0x00002000, 0x00000000, 0x00000000, 0x00000000 }, /* STACK_REG */	\
   { 0x000020FF, 0x00000000, 0x00000000, 0x00000000 }, /* BASE_REGS */	\
   { 0x0000FF00, 0x00000000, 0x00000000, 0x00000000 }, /* HI_REGS */	\
+  { 0x0000FFFF, 0x00000000, 0x00000000, 0x00000000 }, /* HILO_REGS */	\
   { 0x01000000, 0x00000000, 0x00000000, 0x00000000 }, /* CC_REG */	\
   { 0x00000000, 0x00000000, 0x00000000, 0x80000000 }, /* VFPCC_REG */	\
   { 0x0200FFFF, 0x00000000, 0x00000000, 0x00000000 }, /* GENERAL_REGS */ \
@@ -1213,7 +1216,8 @@ enum reg_class
 #define PREFERRED_RELOAD_CLASS(X, CLASS)		\
   (TARGET_ARM ? (CLASS) :				\
    ((CLASS) == GENERAL_REGS || (CLASS) == HI_REGS	\
-    || (CLASS) == NO_REGS ? LO_REGS : (CLASS)))
+    || (CLASS) == HILO_REGS || (CLASS) == NO_REGS	\
+    ? LO_REGS : (CLASS)))
 
 /* Must leave BASE_REGS reloads alone */
 #define THUMB_SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, X)		\
diff --git a/gcc/config/arm/arm.md b/gcc/config/arm/arm.md
index e6ae5439..3cdce968 100644
--- a/gcc/config/arm/arm.md
+++ b/gcc/config/arm/arm.md
@@ -4199,7 +4199,7 @@
 
 (define_expand "extendqihi2"
   [(set (match_dup 2)
-	(ashift:SI (match_operand:QI 1 "general_operand" "")
+	(ashift:SI (match_operand:QI 1 "arm_reg_or_extendqisi_mem_op" "")
 		   (const_int 24)))
    (set (match_operand:HI 0 "s_register_operand" "")
 	(ashiftrt:SI (match_dup 2)
@@ -4224,7 +4224,7 @@
 
 (define_insn "*arm_extendqihi_insn"
   [(set (match_operand:HI 0 "s_register_operand" "=r")
-	(sign_extend:HI (match_operand:QI 1 "memory_operand" "Uq")))]
+	(sign_extend:HI (match_operand:QI 1 "arm_extendqisi_mem_op" "Uq")))]
   "TARGET_ARM && arm_arch4"
   "ldr%(sb%)\\t%0, %1"
   [(set_attr "type" "load_byte")
@@ -4235,7 +4235,7 @@
 
 (define_expand "extendqisi2"
   [(set (match_dup 2)
-	(ashift:SI (match_operand:QI 1 "general_operand" "")
+	(ashift:SI (match_operand:QI 1 "arm_reg_or_extendqisi_mem_op" "")
 		   (const_int 24)))
    (set (match_operand:SI 0 "s_register_operand" "")
 	(ashiftrt:SI (match_dup 2)
@@ -4267,7 +4267,7 @@
 
 (define_insn "*arm_extendqisi"
   [(set (match_operand:SI 0 "s_register_operand" "=r")
-	(sign_extend:SI (match_operand:QI 1 "memory_operand" "Uq")))]
+	(sign_extend:SI (match_operand:QI 1 "arm_extendqisi_mem_op" "Uq")))]
   "TARGET_ARM && arm_arch4 && !arm_arch6"
   "ldr%(sb%)\\t%0, %1"
   [(set_attr "type" "load_byte")
@@ -4278,7 +4278,8 @@
 
 (define_insn "*arm_extendqisi_v6"
   [(set (match_operand:SI 0 "s_register_operand" "=r,r")
-	(sign_extend:SI (match_operand:QI 1 "nonimmediate_operand" "r,Uq")))]
+	(sign_extend:SI
+	 (match_operand:QI 1 "arm_reg_or_extendqisi_mem_op" "r,Uq")))]
   "TARGET_ARM && arm_arch6"
   "@
    sxtb%?\\t%0, %1
@@ -4823,7 +4824,30 @@
 	(match_operand:SI 1 "general_operand"      "l, I,J,K,>,l,mi,l,*lh"))]
   "TARGET_THUMB1
    && (   register_operand (operands[0], SImode) 
-       || register_operand (operands[1], SImode))"
+       || register_operand (operands[1], SImode))
+   && !optimize_size"
+  "@
+   mov	%0, %1
+   mov	%0, %1
+   #
+   #
+   ldmia\\t%1, {%0}
+   stmia\\t%0, {%1}
+   ldr\\t%0, %1
+   str\\t%1, %0
+   mov\\t%0, %1"
+  [(set_attr "length" "2,2,4,4,2,2,2,2,2")
+   (set_attr "type" "*,*,*,*,load1,store1,load1,store1,*")
+   (set_attr "pool_range" "*,*,*,*,*,*,1020,*,*")]
+)
+
+(define_insn "*thumb1_movsi_insn_osize"
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=l,l,l,l,l,>,l, m,*l*h")
+	(match_operand:SI 1 "general_operand"      "l, I,J,K,>,l,mi,l,*l*h"))]
+  "TARGET_THUMB1
+   && (   register_operand (operands[0], SImode) 
+       || register_operand (operands[1], SImode))
+   && optimize_size"
   "@
    mov	%0, %1
    mov	%0, %1
diff --git a/gcc/config/arm/linux-eabi.h b/gcc/config/arm/linux-eabi.h
index 4174d70d..62b0490e 100644
--- a/gcc/config/arm/linux-eabi.h
+++ b/gcc/config/arm/linux-eabi.h
@@ -44,7 +44,7 @@
    The ARM10TDMI core is the default for armv5t, so set
    SUBTARGET_CPU_DEFAULT to achieve this.  */
 #undef  SUBTARGET_CPU_DEFAULT
-#define SUBTARGET_CPU_DEFAULT TARGET_CPU_arm10tdmi
+#define SUBTARGET_CPU_DEFAULT TARGET_CPU_arm9tdmi
 
 /* TARGET_BIG_ENDIAN_DEFAULT is set in
    config.gcc for big endian configurations.  */
diff --git a/gcc/config/arm/predicates.md b/gcc/config/arm/predicates.md
index 388790db..48e697fa 100644
--- a/gcc/config/arm/predicates.md
+++ b/gcc/config/arm/predicates.md
@@ -234,6 +234,10 @@
        (match_test "arm_legitimate_address_p (mode, XEXP (op, 0), SIGN_EXTEND,
 					      0)")))
 
+(define_special_predicate "arm_reg_or_extendqisi_mem_op"
+  (ior (match_operand 0 "arm_extendqisi_mem_op")
+       (match_operand 0 "s_register_operand")))
+
 (define_predicate "power_of_two_operand"
   (match_code "const_int")
 {
diff --git a/gcc/config/bfin/linux-unwind.h b/gcc/config/bfin/linux-unwind.h
index c3697114..afb3da3b 100644
--- a/gcc/config/bfin/linux-unwind.h
+++ b/gcc/config/bfin/linux-unwind.h
@@ -52,11 +52,11 @@ bfin_fallback_frame_state (struct _Unwind_Context *context,
     {
       struct rt_sigframe {
 	int sig;
-	struct siginfo *pinfo;
+	siginfo_t *pinfo;
 	void *puc;
 	char retcode[8];
-	struct siginfo info;
-	struct ucontext uc;
+	siginfo_t info;
+	ucontext_t uc;
       } *rt_ = context->cfa;
 
       /* The void * cast is necessary to avoid an aliasing warning.
diff --git a/gcc/config/freebsd-spec.h b/gcc/config/freebsd-spec.h
index 352c6182..94b2767f 100644
--- a/gcc/config/freebsd-spec.h
+++ b/gcc/config/freebsd-spec.h
@@ -56,6 +56,8 @@ along with GCC; see the file COPYING3.  If not see
 	builtin_assert ("system=unix");					\
 	builtin_assert ("system=bsd");					\
 	builtin_assert ("system=FreeBSD");				\
+	if(!(flag_iso && (c_dialect_cxx () ? cxx_dialect == cxx98 : !flag_isoc99)))	\
+		builtin_define("_LONGLONG");				\
 	FBSD_TARGET_CPU_CPP_BUILTINS();					\
     }									\
   while (0)
@@ -79,9 +81,10 @@ along with GCC; see the file COPYING3.  If not see
 #define FBSD_STARTFILE_SPEC \
   "%{!shared: \
      %{pg:gcrt1.o%s} %{!pg:%{p:gcrt1.o%s} \
-		       %{!p:%{profile:gcrt1.o%s} \
-			 %{!profile:crt1.o%s}}}} \
-   crti.o%s %{!shared:crtbegin.o%s} %{shared:crtbeginS.o%s}"
+	%{!p:%{profile:gcrt1.o%s} \
+	 %{!profile:crt1.o%s}}}} \
+   crti.o%s \
+   %{static:crtbeginT.o%s;shared:crtbeginS.o%s;:crtbegin.o%s}"
 
 /* Provide a ENDFILE_SPEC appropriate for FreeBSD.  Here we tack on
    the magical crtend.o file (see crtstuff.c) which provides part of 
@@ -119,7 +122,8 @@ is built with the --enable-threads configure-time option.}		\
     %{pg:  -lc_p}							\
   }"
 #else
-#if FBSD_MAJOR < 5
+#include <sys/param.h>
+#if __FreeBSD_version < 500016
 #define FBSD_LIB_SPEC "							\
   %{!shared:								\
     %{!pg:								\
@@ -129,17 +133,34 @@ is built with the --enable-threads configure-time option.}		\
       %{!pthread:-lc_p}							\
       %{pthread:-lc_r_p}}						\
   }"
-#else
+#elif __FreeBSD_version < 700022
 #define FBSD_LIB_SPEC "							\
   %{!shared:								\
     %{!pg: %{pthread:-lpthread} -lc}					\
     %{pg:  %{pthread:-lpthread_p} -lc_p}				\
   }"
+#else
+#define FBSD_LIB_SPEC "							\
+  %{!shared:								\
+    %{!pg: %{pthread:-lpthread} -lc}					\
+    %{pg:  %{pthread:-lpthread_p} -lc_p}}				\
+  %{shared:								\
+    %{pthread:-lpthread} -lc}						\
+  "
 #endif
 #endif
 
-#if FBSD_MAJOR < 6
+#if FBSD_MAJOR < 5
 #define FBSD_DYNAMIC_LINKER "/usr/libexec/ld-elf.so.1"
 #else
 #define FBSD_DYNAMIC_LINKER "/libexec/ld-elf.so.1"
 #endif
+
+#if defined(HAVE_LD_EH_FRAME_HDR)
+#define LINK_EH_SPEC "%{!static:--eh-frame-hdr} "
+#endif
+
+/* Use --as-needed -lgcc_s for eh support.  */
+#ifdef HAVE_LD_AS_NEEDED
+#define USE_LD_AS_NEEDED 1
+#endif
diff --git a/gcc/config/host-linux.c b/gcc/config/host-linux.c
index f0666173..c94f822f 100644
--- a/gcc/config/host-linux.c
+++ b/gcc/config/host-linux.c
@@ -84,6 +84,8 @@
 # define TRY_EMPTY_VM_SPACE	0x8000000000
 #elif defined(__sparc__)
 # define TRY_EMPTY_VM_SPACE	0x60000000
+#elif defined(__mc68000__)
+# define TRY_EMPTY_VM_SPACE	0x40000000
 #else
 # define TRY_EMPTY_VM_SPACE	0
 #endif
diff --git a/gcc/config/i386/linux-unwind.h b/gcc/config/i386/linux-unwind.h
index 58eb7333..67ff04bd 100644
--- a/gcc/config/i386/linux-unwind.h
+++ b/gcc/config/i386/linux-unwind.h
@@ -51,7 +51,7 @@ x86_64_fallback_frame_state (struct _Unwind_Context *context,
   if (*(unsigned char *)(pc+0) == 0x48
       && *(unsigned long *)(pc+1) == 0x050f0000000fc0c7)
     {
-      struct ucontext *uc_ = context->cfa;
+      ucontext_t *uc_ = context->cfa;
       /* The void * cast is necessary to avoid an aliasing warning.
          The aliasing warning is correct, but should not be a problem
          because it does not alias anything.  */
@@ -137,10 +137,10 @@ x86_fallback_frame_state (struct _Unwind_Context *context,
     {
       struct rt_sigframe {
 	int sig;
-	struct siginfo *pinfo;
+	siginfo_t *pinfo;
 	void *puc;
-	struct siginfo info;
-	struct ucontext uc;
+	siginfo_t info;
+	ucontext_t uc;
       } *rt_ = context->cfa;
       /* The void * cast is necessary to avoid an aliasing warning.
          The aliasing warning is correct, but should not be a problem
diff --git a/gcc/config/ia64/crtbegin.asm b/gcc/config/ia64/crtbegin.asm
index e040916b..c17ecb86 100644
--- a/gcc/config/ia64/crtbegin.asm
+++ b/gcc/config/ia64/crtbegin.asm
@@ -255,3 +255,7 @@ __do_jv_register_classes:
 .weak __cxa_finalize
 #endif
 .weak _Jv_RegisterClasses
+
+#ifdef __linux__
+.section .note.GNU-stack; .previous
+#endif
diff --git a/gcc/config/ia64/crtend.asm b/gcc/config/ia64/crtend.asm
index 66eaa01b..1068af70 100644
--- a/gcc/config/ia64/crtend.asm
+++ b/gcc/config/ia64/crtend.asm
@@ -122,3 +122,7 @@ __do_global_ctors_aux:
 
 	br.ret.sptk.many rp
 	.endp __do_global_ctors_aux
+
+#ifdef __linux__
+.section .note.GNU-stack; .previous
+#endif
diff --git a/gcc/config/ia64/crti.asm b/gcc/config/ia64/crti.asm
index a2d1e122..d44fec8e 100644
--- a/gcc/config/ia64/crti.asm
+++ b/gcc/config/ia64/crti.asm
@@ -64,3 +64,7 @@ _fini:
 	.body
 
 # end of crti.asm
+
+#ifdef __linux__
+.section .note.GNU-stack; .previous
+#endif
diff --git a/gcc/config/ia64/crtn.asm b/gcc/config/ia64/crtn.asm
index 52ec47c5..badc56a1 100644
--- a/gcc/config/ia64/crtn.asm
+++ b/gcc/config/ia64/crtn.asm
@@ -54,3 +54,7 @@
 	br.ret.sptk.many b0
 
 # end of crtn.asm
+
+#ifdef __linux__
+.section .note.GNU-stack; .previous
+#endif
diff --git a/gcc/config/ia64/lib1funcs.asm b/gcc/config/ia64/lib1funcs.asm
index 245a8bb1..f3af11bd 100644
--- a/gcc/config/ia64/lib1funcs.asm
+++ b/gcc/config/ia64/lib1funcs.asm
@@ -792,3 +792,7 @@ __floattitf:
 	}
 	.endp __floattitf
 #endif
+
+#ifdef __linux__
+.section .note.GNU-stack; .previous
+#endif
diff --git a/gcc/config/ia64/linux-unwind.h b/gcc/config/ia64/linux-unwind.h
index 8b2878e9..bbc77e6f 100644
--- a/gcc/config/ia64/linux-unwind.h
+++ b/gcc/config/ia64/linux-unwind.h
@@ -51,7 +51,7 @@ ia64_fallback_frame_state (struct _Unwind_Context *context,
       struct sigframe {
 	char scratch[16];
 	unsigned long sig_number;
-	struct siginfo *info;
+	siginfo_t *info;
 	struct sigcontext *sc;
       } *frame_ = (struct sigframe *)context->psp;
       struct sigcontext *sc = frame_->sc;
@@ -130,7 +130,7 @@ ia64_handle_unwabi (struct _Unwind_Context *context, _Unwind_FrameState *fs)
       struct sigframe {
 	char scratch[16];
 	unsigned long sig_number;
-	struct siginfo *info;
+	siginfo_t *info;
 	struct sigcontext *sc;
       } *frame = (struct sigframe *)context->psp;
       struct sigcontext *sc = frame->sc;
diff --git a/gcc/config/ia64/linux.h b/gcc/config/ia64/linux.h
index cecae0df..dd5f5b34 100644
--- a/gcc/config/ia64/linux.h
+++ b/gcc/config/ia64/linux.h
@@ -5,6 +5,8 @@
 
 #define TARGET_VERSION fprintf (stderr, " (IA-64) Linux");
 
+#define TARGET_ASM_FILE_END file_end_indicate_exec_stack
+
 /* This is for -profile to use -lc_p instead of -lc.  */
 #undef CC1_SPEC
 #define CC1_SPEC "%{profile:-p} %{G*}"
diff --git a/gcc/config/m68k/linux-unwind.h b/gcc/config/m68k/linux-unwind.h
index dffde3b2..57ff5cda 100644
--- a/gcc/config/m68k/linux-unwind.h
+++ b/gcc/config/m68k/linux-unwind.h
@@ -37,7 +37,7 @@ Boston, MA 02110-1301, USA.  */
 /* <sys/ucontext.h> is unfortunately broken right now.  */
 struct uw_ucontext {
 	unsigned long	  uc_flags;
-	struct ucontext  *uc_link;
+	ucontext_t	 *uc_link;
 	stack_t		  uc_stack;
 	mcontext_t	  uc_mcontext;
 	unsigned long	  uc_filler[80];
diff --git a/gcc/config/mips/10000.md b/gcc/config/mips/10000.md
new file mode 100644
index 00000000..59fd0f64
--- /dev/null
+++ b/gcc/config/mips/10000.md
@@ -0,0 +1,254 @@
+;; DFA-based pipeline description for the VR1x000.
+;;   Copyright (C) 2005, 2006, 2008 Free Software Foundation, Inc.
+;;
+;; This file is part of GCC.
+
+;; GCC is free software; you can redistribute it and/or modify it
+;; under the terms of the GNU General Public License as published
+;; by the Free Software Foundation; either version 3, or (at your
+;; option) any later version.
+
+;; GCC is distributed in the hope that it will be useful, but WITHOUT
+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+;; License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+
+;; R12K/R14K/R16K are derivatives of R10K, thus copy its description
+;; until specific tuning for each is added.
+
+;; R10000 has an int queue, fp queue, address queue.
+;; The int queue feeds ALU1 and ALU2.
+;; The fp queue feeds the fp-adder and fp-multiplier.
+;; The addr queue feeds the Load/Store unit.
+;;
+;; However, we define the fp-adder and fp-multiplier as
+;; separate automatons, because the fp-multiplier is
+;; divided into fp-multiplier, fp-division, and
+;; fp-squareroot units, all of which share the same
+;; issue and completion logic, yet can operate in
+;; parallel.
+;;
+;; This is based on the model described in the R10K Manual
+;; and it helps to reduce the size of the automata.
+(define_automaton "r10k_a_int, r10k_a_fpadder, r10k_a_addr,
+                   r10k_a_fpmpy, r10k_a_fpdiv, r10k_a_fpsqrt")
+
+(define_cpu_unit "r10k_alu1" "r10k_a_int")
+(define_cpu_unit "r10k_alu2" "r10k_a_int")
+(define_cpu_unit "r10k_fpadd" "r10k_a_fpadder")
+(define_cpu_unit "r10k_fpmpy" "r10k_a_fpmpy")
+(define_cpu_unit "r10k_fpdiv" "r10k_a_fpdiv")
+(define_cpu_unit "r10k_fpsqrt" "r10k_a_fpsqrt")
+(define_cpu_unit "r10k_loadstore" "r10k_a_addr")
+
+
+;; R10k Loads and Stores.
+(define_insn_reservation "r10k_load" 2
+  (and (eq_attr "cpu" "r10000")
+       (eq_attr "type" "load,prefetch,prefetchx"))
+  "r10k_loadstore")
+
+(define_insn_reservation "r10k_store" 0
+  (and (eq_attr "cpu" "r10000")
+       (eq_attr "type" "store,fpstore,fpidxstore"))
+  "r10k_loadstore")
+
+(define_insn_reservation "r10k_fpload" 3
+  (and (eq_attr "cpu" "r10000")
+       (eq_attr "type" "fpload,fpidxload"))
+  "r10k_loadstore")
+
+
+;; Integer add/sub + logic ops, and mt hi/lo can be done by alu1 or alu2.
+;; Miscellaneous arith goes here too (this is a guess).
+(define_insn_reservation "r10k_arith" 1
+  (and (eq_attr "cpu" "r10000")
+       (eq_attr "type" "arith,mthilo,slt,clz,const,nop,trap,logical"))
+  "r10k_alu1 | r10k_alu2")
+
+;; We treat mfhilo differently, because we need to know when
+;; it's HI and when it's LO.
+(define_insn_reservation "r10k_mfhi" 1
+  (and (eq_attr "cpu" "r10000")
+       (and (eq_attr "type" "mfhilo")
+            (not (match_operand 1 "lo_operand"))))
+  "r10k_alu1 | r10k_alu2")
+
+(define_insn_reservation "r10k_mflo" 1
+  (and (eq_attr "cpu" "r10000")
+       (and (eq_attr "type" "mfhilo")
+            (match_operand 1 "lo_operand")))
+  "r10k_alu1 | r10k_alu2")
+
+
+;; ALU1 handles shifts, branch eval, and condmove.
+;;
+;; Brancher is separate, but part of ALU1, but can only
+;; do one branch per cycle (is this even implementable?).
+;;
+;; Unsure if the brancher handles jumps and calls as well, but since
+;; they're related, we'll add them here for now.
+(define_insn_reservation "r10k_brancher" 1
+  (and (eq_attr "cpu" "r10000")
+       (eq_attr "type" "shift,branch,jump,call"))
+  "r10k_alu1")
+
+(define_insn_reservation "r10k_int_cmove" 1
+  (and (eq_attr "cpu" "r10000")
+       (and (eq_attr "type" "condmove")
+            (eq_attr "mode" "SI,DI")))
+  "r10k_alu1")
+
+
+;; Coprocessor Moves.
+;; mtc1/dmtc1 are handled by ALU1.
+;; mfc1/dmfc1 are handled by the fp-multiplier.
+(define_insn_reservation "r10k_mt_xfer" 3
+  (and (eq_attr "cpu" "r10000")
+       (eq_attr "type" "mtc"))
+  "r10k_alu1")
+
+(define_insn_reservation "r10k_mf_xfer" 2
+  (and (eq_attr "cpu" "r10000")
+       (eq_attr "type" "mfc"))
+  "r10k_fpmpy")
+
+
+;; Only ALU2 does int multiplications and divisions.
+;;
+;; According to the Vr10000 series user manual,
+;; integer mult and div insns can be issued one
+;; cycle earlier if using register Lo.  We model
+;; this by using the Lo value by default, as it
+;; is the more common value, and use a bypass
+;; for the Hi value when needed.
+;;
+;; Also of note, There are different latencies
+;; for MULT/DMULT (Lo 5/Hi 6) and MULTU/DMULTU (Lo 6/Hi 7).
+;; However, gcc does not have separate types
+;; for these insns.  Thus to strike a balance,
+;; we use the Hi latency value for imul
+;; operations until the imul type can be split.
+(define_insn_reservation "r10k_imul_single" 6
+  (and (eq_attr "cpu" "r10000")
+       (and (eq_attr "type" "imul,imul3")
+            (eq_attr "mode" "SI")))
+  "r10k_alu2 * 6")
+
+(define_insn_reservation "r10k_imul_double" 10
+  (and (eq_attr "cpu" "r10000")
+       (and (eq_attr "type" "imul,imul3")
+            (eq_attr "mode" "DI")))
+  "r10k_alu2 * 10")
+
+;; Divides keep ALU2 busy.
+(define_insn_reservation "r10k_idiv_single" 34
+  (and (eq_attr "cpu" "r10000")
+       (and (eq_attr "type" "idiv")
+            (eq_attr "mode" "SI")))
+  "r10k_alu2 * 35")
+
+(define_insn_reservation "r10k_idiv_double" 66
+  (and (eq_attr "cpu" "r10000")
+       (and (eq_attr "type" "idiv")
+            (eq_attr "mode" "DI")))
+  "r10k_alu2 * 67")
+
+(define_bypass 35 "r10k_idiv_single" "r10k_mfhi")
+(define_bypass 67 "r10k_idiv_double" "r10k_mfhi")
+
+
+;; Floating point add/sub, mul, abs value, neg, comp, & moves.
+(define_insn_reservation "r10k_fp_miscadd" 2
+  (and (eq_attr "cpu" "r10000")
+       (eq_attr "type" "fadd,fabs,fneg,fcmp"))
+  "r10k_fpadd")
+
+(define_insn_reservation "r10k_fp_miscmul" 2
+  (and (eq_attr "cpu" "r10000")
+       (eq_attr "type" "fmul,fmove"))
+  "r10k_fpmpy")
+
+(define_insn_reservation "r10k_fp_cmove" 2
+  (and (eq_attr "cpu" "r10000")
+       (and (eq_attr "type" "condmove")
+            (eq_attr "mode" "SF,DF")))
+  "r10k_fpmpy")
+
+
+;; The fcvt.s.[wl] insn has latency 4, repeat 2.
+;; All other fcvt insns have latency 2, repeat 1.
+(define_insn_reservation "r10k_fcvt_single" 4
+  (and (eq_attr "cpu" "r10000")
+       (and (eq_attr "type" "fcvt")
+            (eq_attr "cnv_mode" "I2S")))
+  "r10k_fpadd * 2")
+
+(define_insn_reservation "r10k_fcvt_other" 2
+  (and (eq_attr "cpu" "r10000")
+       (and (eq_attr "type" "fcvt")
+            (eq_attr "cnv_mode" "!I2S")))
+  "r10k_fpadd")
+
+
+;; Run the fmadd insn through fp-adder first, then fp-multiplier.
+;;
+;; The latency for fmadd is 2 cycles if the result is used
+;; by another fmadd instruction.
+(define_insn_reservation "r10k_fmadd" 4
+  (and (eq_attr "cpu" "r10000")
+       (eq_attr "type" "fmadd"))
+  "r10k_fpadd, r10k_fpmpy")
+
+(define_bypass 2 "r10k_fmadd" "r10k_fmadd")
+
+
+;; Floating point Divisions & square roots.
+(define_insn_reservation "r10k_fdiv_single" 12
+  (and (eq_attr "cpu" "r10000")
+       (and (eq_attr "type" "fdiv,frdiv")
+            (eq_attr "mode" "SF")))
+  "r10k_fpdiv * 14")
+
+(define_insn_reservation "r10k_fdiv_double" 19
+  (and (eq_attr "cpu" "r10000")
+       (and (eq_attr "type" "fdiv,frdiv")
+            (eq_attr "mode" "DF")))
+  "r10k_fpdiv * 21")
+
+(define_insn_reservation "r10k_fsqrt_single" 18
+  (and (eq_attr "cpu" "r10000")
+       (and (eq_attr "type" "fsqrt")
+            (eq_attr "mode" "SF")))
+  "r10k_fpsqrt * 20")
+
+(define_insn_reservation "r10k_fsqrt_double" 33
+  (and (eq_attr "cpu" "r10000")
+       (and (eq_attr "type" "fsqrt")
+            (eq_attr "mode" "DF")))
+  "r10k_fpsqrt * 35")
+
+(define_insn_reservation "r10k_frsqrt_single" 30
+  (and (eq_attr "cpu" "r10000")
+       (and (eq_attr "type" "frsqrt")
+            (eq_attr "mode" "SF")))
+  "r10k_fpsqrt * 20")
+
+(define_insn_reservation "r10k_frsqrt_double" 52
+  (and (eq_attr "cpu" "r10000")
+       (and (eq_attr "type" "frsqrt")
+            (eq_attr "mode" "DF")))
+  "r10k_fpsqrt * 35")
+
+
+;; Handle unknown/multi insns here (this is a guess).
+(define_insn_reservation "r10k_unknown" 1
+  (and (eq_attr "cpu" "r10000")
+       (eq_attr "type" "unknown,multi"))
+  "r10k_alu1 + r10k_alu2")
+
diff --git a/gcc/config/mips/linux-unwind.h b/gcc/config/mips/linux-unwind.h
index 4e71182f..86d47117 100644
--- a/gcc/config/mips/linux-unwind.h
+++ b/gcc/config/mips/linux-unwind.h
@@ -79,7 +79,7 @@ mips_fallback_frame_state (struct _Unwind_Context *context,
       struct rt_sigframe {
 	u_int32_t ass[4];  /* Argument save space for o32.  */
 	u_int32_t trampoline[2];
-	struct siginfo info;
+	siginfo_t info;
 	_sig_ucontext_t uc;
       } *rt_ = context->cfa;
       sc = &rt_->uc.uc_mcontext;
diff --git a/gcc/config/mips/mips-ftypes.def b/gcc/config/mips/mips-ftypes.def
index 9d46f8c2..38503a83 100644
--- a/gcc/config/mips/mips-ftypes.def
+++ b/gcc/config/mips/mips-ftypes.def
@@ -87,6 +87,7 @@ DEF_MIPS_FTYPE (1, (V4QI, V4QI))
 DEF_MIPS_FTYPE (2, (V4QI, V4QI, SI))
 DEF_MIPS_FTYPE (2, (V4QI, V4QI, V4QI))
 
+DEF_MIPS_FTYPE (2, (VOID, SI, CVPOINTER))
 DEF_MIPS_FTYPE (2, (VOID, SI, SI))
 DEF_MIPS_FTYPE (2, (VOID, V2HI, V2HI))
 DEF_MIPS_FTYPE (2, (VOID, V4QI, V4QI))
diff --git a/gcc/config/mips/mips-protos.h b/gcc/config/mips/mips-protos.h
index deb99a08..761da5bd 100644
--- a/gcc/config/mips/mips-protos.h
+++ b/gcc/config/mips/mips-protos.h
@@ -278,6 +278,7 @@ extern const char *mips_output_load_label (void);
 extern const char *mips_output_conditional_branch (rtx, rtx *, const char *,
 						   const char *);
 extern const char *mips_output_order_conditional_branch (rtx, rtx *, bool);
+extern const char *mips_output_sync_loop (const char *);
 extern const char *mips_output_division (const char *, rtx *);
 extern unsigned int mips_hard_regno_nregs (int, enum machine_mode);
 extern bool mips_linked_madd_p (rtx, rtx);
diff --git a/gcc/config/mips/mips.c b/gcc/config/mips/mips.c
index 71bb592b..a47df126 100644
--- a/gcc/config/mips/mips.c
+++ b/gcc/config/mips/mips.c
@@ -147,6 +147,13 @@ enum mips_address_type {
   ADDRESS_SYMBOLIC
 };
 
+/* Enumerates the setting of the -mr10k-cache-barrier option.  */
+enum mips_r10k_cache_barrier_setting {
+  R10K_CACHE_BARRIER_NONE,
+  R10K_CACHE_BARRIER_STORE,
+  R10K_CACHE_BARRIER_LOAD_STORE
+};
+
 /* Macros to create an enumeration identifier for a function prototype.  */
 #define MIPS_FTYPE_NAME1(A, B) MIPS_##A##_FTYPE_##B
 #define MIPS_FTYPE_NAME2(A, B, C) MIPS_##A##_FTYPE_##B##_##C
@@ -455,6 +462,9 @@ static int mips_base_align_functions; /* align_functions */
 /* The -mcode-readable setting.  */
 enum mips_code_readable_setting mips_code_readable = CODE_READABLE_YES;
 
+/* The -mr10k-cache-barrier setting.  */
+static enum mips_r10k_cache_barrier_setting mips_r10k_cache_barrier;
+
 /* Index [M][R] is true if register R is allowed to hold a value of mode M.  */
 bool mips_hard_regno_mode_ok[(int) MAX_MACHINE_MODE][FIRST_PSEUDO_REGISTER];
 
@@ -587,6 +597,10 @@ static const struct mips_cpu_info mips_cpu_info_table[] = {
 
   /* MIPS IV processors. */
   { "r8000", PROCESSOR_R8000, 4, 0 },
+  { "r10000", PROCESSOR_R10000, 4, 0 },
+  { "r12000", PROCESSOR_R10000, 4, 0 },
+  { "r14000", PROCESSOR_R10000, 4, 0 },
+  { "r16000", PROCESSOR_R10000, 4, 0 },
   { "vr5000", PROCESSOR_R5000, 4, 0 },
   { "vr5400", PROCESSOR_R5400, 4, 0 },
   { "vr5500", PROCESSOR_R5500, 4, PTF_AVOID_BRANCHLIKELY },
@@ -975,6 +989,19 @@ static const struct mips_rtx_cost_data mips_rtx_cost_data[PROCESSOR_MAX] = {
 		     1,           /* branch_cost */
 		     4            /* memory_latency */
   },
+  { /* R1x000 */
+    COSTS_N_INSNS (2),            /* fp_add */
+    COSTS_N_INSNS (2),            /* fp_mult_sf */
+    COSTS_N_INSNS (2),            /* fp_mult_df */
+    COSTS_N_INSNS (12),           /* fp_div_sf */
+    COSTS_N_INSNS (19),           /* fp_div_df */
+    COSTS_N_INSNS (5),            /* int_mult_si */
+    COSTS_N_INSNS (9),            /* int_mult_di */
+    COSTS_N_INSNS (34),           /* int_div_si */
+    COSTS_N_INSNS (66),           /* int_div_di */
+		     1,           /* branch_cost */
+		     4            /* memory_latency */
+  },
   { /* SB1 */
     /* These costs are the same as the SB-1A below.  */
     COSTS_N_INSNS (4),            /* fp_add */
@@ -2454,7 +2481,26 @@ mips_legitimize_tls_address (rtx loc)
     }
   return dest;
 }
-
+
+/* Return true if, for every base register BASE_REG, (plus BASE_REG X)
+   can address a value of mode MODE.  */
+
+static bool
+mips_valid_offset_p (rtx x, enum machine_mode mode)
+{
+  /* Check that X is a signed 16-bit number.  */
+  if (!const_arith_operand (x, Pmode))
+    return false;
+
+  /* We may need to split multiword moves, so make sure that every word
+     is accessible.  */
+  if (GET_MODE_SIZE (mode) > UNITS_PER_WORD
+      && !SMALL_OPERAND (INTVAL (x) + GET_MODE_SIZE (mode) - UNITS_PER_WORD))
+    return false;
+
+  return true;
+}
+
 /* This function is used to implement LEGITIMIZE_ADDRESS.  If *XLOC can
    be legitimized in a way that the generic machinery might not expect,
    put the new address in *XLOC and return true.  MODE is the mode of
@@ -2464,7 +2510,7 @@ bool
 mips_legitimize_address (rtx *xloc, enum machine_mode mode)
 {
   rtx base;
-  HOST_WIDE_INT offset;
+  HOST_WIDE_INT intval, high, offset;
 
   if (mips_tls_symbol_p (*xloc))
     {
@@ -2485,6 +2531,33 @@ mips_legitimize_address (rtx *xloc, enum machine_mode mode)
       *xloc = mips_add_offset (NULL, base, offset);
       return true;
     }
+
+  /* Handle references to constant addresses by loading the high part
+     into a register and using an offset for the low part.  */
+  if (GET_CODE (base) == CONST_INT)
+    {
+      intval = INTVAL (base);
+      high = trunc_int_for_mode (CONST_HIGH_PART (intval), Pmode);
+      offset = CONST_LOW_PART (intval);
+      /* Ignore cases in which a positive address would be accessed by a
+	 negative offset from a negative address.  The required wraparound
+	 does not occur for 32-bit addresses on 64-bit targets, and it is
+	 very unlikely that such an access would occur in real code anyway.
+
+	 If the low offset is not legitimate for MODE, prefer to load
+	 the constant normally, instead of using mips_force_address on
+	 the legitimized address.  The latter option would cause us to
+	 use (D)ADDIU unconditionally, but LUI/ORI is more efficient
+	 than LUI/ADDIU on some targets.  */
+      if ((intval < 0 || high > 0)
+	  && mips_valid_offset_p (GEN_INT (offset), mode))
+	{
+	  base = mips_force_temporary (NULL, GEN_INT (high));
+	  *xloc = plus_constant (base, offset);
+	  return true;
+	}
+    }
+
   return false;
 }
 
@@ -6226,6 +6299,7 @@ mips_print_operand_reloc (FILE *file, rtx op, enum mips_symbol_context context,
    '#'	Print a nop if in a ".set noreorder" block.
    '/'	Like '#', but do nothing within a delayed-branch sequence.
    '?'	Print "l" if mips_branch_likely is true
+   '~'	Print a nop if mips_branch_likely is true
    '.'	Print the name of the register with a hard-wired zero (zero or $0).
    '@'	Print the name of the assembler temporary register (at or $1).
    '^'	Print the name of the pic call-through register (t9 or $25).
@@ -6300,6 +6374,11 @@ mips_print_operand_punctuation (FILE *file, int ch)
 	putc ('l', file);
       break;
 
+    case '~':
+      if (mips_branch_likely)
+	fputs ("\n\tnop", file);
+      break;
+
     case '.':
       fputs (reg_names[GP_REG_FIRST + 0], file);
       break;
@@ -6343,7 +6422,7 @@ mips_init_print_operand_punct (void)
 {
   const char *p;
 
-  for (p = "()[]<>*#/?.@^+$|-"; *p; p++)
+  for (p = "()[]<>*#/?~.@^+$|-"; *p; p++)
     mips_print_operand_punct[(unsigned char) *p] = true;
 }
 
@@ -9348,6 +9427,17 @@ mips_output_order_conditional_branch (rtx insn, rtx *operands, bool inverted_p)
   return mips_output_conditional_branch (insn, operands, branch[1], branch[0]);
 }
 
+/* Return the assembly code for __sync_*() loop LOOP.  The loop should support
+   both normal and likely branches, using %? and %~ where appropriate.  */
+
+const char *
+mips_output_sync_loop (const char *loop)
+{
+    /* Use branch-likely instructions to work around the LL/SC R10000 errata.  */
+    mips_branch_likely = TARGET_FIX_R10000;
+    return loop;
+}
+
 /* Return the assembly code for DIV or DDIV instruction DIVISION, which has
    the operands given by OPERANDS.  Add in a divide-by-zero check if needed.
 
@@ -9544,7 +9634,10 @@ mips_issue_rate (void)
 	 but in reality only a maximum of 3 insns can be issued as
 	 floating-point loads and stores also require a slot in the
 	 AGEN pipe.  */
-     return 4;
+    case PROCESSOR_R10000:
+      /* All R10K Processors are quad-issue (being the first MIPS
+         processors to support this feature). */
+      return 4;
 
     case PROCESSOR_20KC:
     case PROCESSOR_R4130:
@@ -9899,6 +9992,23 @@ mips_prefetch_cookie (rtx write, rtx locality)
   return GEN_INT (INTVAL (write) + 6);
 }
 
+/* Flags that indicate when a built-in function is available.
+
+   BUILTIN_AVAIL_NON_MIPS16
+	The function is available on the current target, but only
+	in non-MIPS16 mode.  */
+#define BUILTIN_AVAIL_NON_MIPS16 1
+
+/* Declare an availability predicate for built-in functions that
+   require non-MIPS16 mode and also require COND to be true.
+   NAME is the main part of the predicate's name.  */
+#define AVAIL_NON_MIPS16(NAME, COND)					\
+static unsigned int							\
+mips_builtin_avail_##NAME (void)					\
+{									\
+  return (COND) ? BUILTIN_AVAIL_NON_MIPS16 : 0;				\
+}
+
 /* This structure describes a single built-in function.  */
 struct mips_builtin_description {
   /* The code of the main .md file instruction.  See mips_builtin_type
@@ -9917,309 +10027,301 @@ struct mips_builtin_description {
   /* The function's prototype.  */
   enum mips_function_type function_type;
 
-  /* The target flags required for this function.  */
-  int target_flags;
+  /* Whether the function is available.  */
+  unsigned int (*avail) (void);
 };
 
-/* Define a MIPS_BUILTIN_DIRECT function for instruction CODE_FOR_mips_<INSN>.
-   FUNCTION_TYPE and TARGET_FLAGS are mips_builtin_description fields.  */
-#define DIRECT_BUILTIN(INSN, FUNCTION_TYPE, TARGET_FLAGS)		\
-  { CODE_FOR_mips_ ## INSN, 0, "__builtin_mips_" #INSN,			\
-    MIPS_BUILTIN_DIRECT, FUNCTION_TYPE, TARGET_FLAGS }
+AVAIL_NON_MIPS16 (paired_single, TARGET_PAIRED_SINGLE_FLOAT)
+AVAIL_NON_MIPS16 (sb1_paired_single, TARGET_SB1 && TARGET_PAIRED_SINGLE_FLOAT)
+AVAIL_NON_MIPS16 (mips3d, TARGET_MIPS3D)
+AVAIL_NON_MIPS16 (dsp, TARGET_DSP)
+AVAIL_NON_MIPS16 (dspr2, TARGET_DSPR2)
+AVAIL_NON_MIPS16 (dsp_32, !TARGET_64BIT && TARGET_DSP)
+AVAIL_NON_MIPS16 (dspr2_32, !TARGET_64BIT && TARGET_DSPR2)
+AVAIL_NON_MIPS16 (cache, TARGET_CACHE_BUILTIN)
+
+/* Construct a mips_builtin_description from the given arguments.
+
+   INSN is the name of the associated instruction pattern, without the
+   leading CODE_FOR_mips_.
+
+   CODE is the floating-point condition code associated with the
+   function.  It can be 'f' if the field is not applicable.
+
+   NAME is the name of the function itself, without the leading
+   "__builtin_mips_".
+
+   BUILTIN_TYPE and FUNCTION_TYPE are mips_builtin_description fields.
+
+   AVAIL is the name of the availability predicate, without the leading
+   mips_builtin_avail_.  */
+#define MIPS_BUILTIN(INSN, COND, NAME, BUILTIN_TYPE,			\
+		     FUNCTION_TYPE, AVAIL)				\
+  { CODE_FOR_mips_ ## INSN, MIPS_FP_COND_ ## COND,			\
+    "__builtin_mips_" NAME, BUILTIN_TYPE, FUNCTION_TYPE,		\
+    mips_builtin_avail_ ## AVAIL }
+
+/* Define __builtin_mips_<INSN>, which is a MIPS_BUILTIN_DIRECT function
+   mapped to instruction CODE_FOR_mips_<INSN>,  FUNCTION_TYPE and AVAIL
+   are as for MIPS_BUILTIN.  */
+#define DIRECT_BUILTIN(INSN, FUNCTION_TYPE, AVAIL)			\
+  MIPS_BUILTIN (INSN, f, #INSN, MIPS_BUILTIN_DIRECT, FUNCTION_TYPE, AVAIL)
 
 /* Define __builtin_mips_<INSN>_<COND>_{s,d} functions, both of which
-   require TARGET_FLAGS.  */
-#define CMP_SCALAR_BUILTINS(INSN, COND, TARGET_FLAGS)			\
-  { CODE_FOR_mips_ ## INSN ## _cond_s, MIPS_FP_COND_ ## COND,		\
-    "__builtin_mips_" #INSN "_" #COND "_s",				\
-    MIPS_BUILTIN_CMP_SINGLE, MIPS_INT_FTYPE_SF_SF, TARGET_FLAGS },	\
-  { CODE_FOR_mips_ ## INSN ## _cond_d, MIPS_FP_COND_ ## COND,		\
-    "__builtin_mips_" #INSN "_" #COND "_d",				\
-    MIPS_BUILTIN_CMP_SINGLE, MIPS_INT_FTYPE_DF_DF, TARGET_FLAGS }
+   are subject to mips_builtin_avail_<AVAIL>.  */
+#define CMP_SCALAR_BUILTINS(INSN, COND, AVAIL)				\
+  MIPS_BUILTIN (INSN ## _cond_s, COND, #INSN "_" #COND "_s",		\
+		MIPS_BUILTIN_CMP_SINGLE, MIPS_INT_FTYPE_SF_SF, AVAIL),	\
+  MIPS_BUILTIN (INSN ## _cond_d, COND, #INSN "_" #COND "_d",		\
+		MIPS_BUILTIN_CMP_SINGLE, MIPS_INT_FTYPE_DF_DF, AVAIL)
 
 /* Define __builtin_mips_{any,all,upper,lower}_<INSN>_<COND>_ps.
-   The lower and upper forms require TARGET_FLAGS while the any and all
-   forms require MASK_MIPS3D.  */
-#define CMP_PS_BUILTINS(INSN, COND, TARGET_FLAGS)			\
-  { CODE_FOR_mips_ ## INSN ## _cond_ps, MIPS_FP_COND_ ## COND,		\
-    "__builtin_mips_any_" #INSN "_" #COND "_ps",			\
-    MIPS_BUILTIN_CMP_ANY, MIPS_INT_FTYPE_V2SF_V2SF, MASK_MIPS3D },	\
-  { CODE_FOR_mips_ ## INSN ## _cond_ps, MIPS_FP_COND_ ## COND,		\
-    "__builtin_mips_all_" #INSN "_" #COND "_ps",			\
-    MIPS_BUILTIN_CMP_ALL, MIPS_INT_FTYPE_V2SF_V2SF, MASK_MIPS3D },	\
-  { CODE_FOR_mips_ ## INSN ## _cond_ps, MIPS_FP_COND_ ## COND,		\
-    "__builtin_mips_lower_" #INSN "_" #COND "_ps",			\
-    MIPS_BUILTIN_CMP_LOWER, MIPS_INT_FTYPE_V2SF_V2SF, TARGET_FLAGS },	\
-  { CODE_FOR_mips_ ## INSN ## _cond_ps, MIPS_FP_COND_ ## COND,		\
-    "__builtin_mips_upper_" #INSN "_" #COND "_ps",			\
-    MIPS_BUILTIN_CMP_UPPER, MIPS_INT_FTYPE_V2SF_V2SF, TARGET_FLAGS }
+   The lower and upper forms are subject to mips_builtin_avail_<AVAIL>
+   while the any and all forms are subject to mips_builtin_avail_mips3d.  */
+#define CMP_PS_BUILTINS(INSN, COND, AVAIL)				\
+  MIPS_BUILTIN (INSN ## _cond_ps, COND, "any_" #INSN "_" #COND "_ps",	\
+		MIPS_BUILTIN_CMP_ANY, MIPS_INT_FTYPE_V2SF_V2SF,		\
+		mips3d),						\
+  MIPS_BUILTIN (INSN ## _cond_ps, COND, "all_" #INSN "_" #COND "_ps",	\
+		MIPS_BUILTIN_CMP_ALL, MIPS_INT_FTYPE_V2SF_V2SF,		\
+		mips3d),						\
+  MIPS_BUILTIN (INSN ## _cond_ps, COND, "lower_" #INSN "_" #COND "_ps",	\
+		MIPS_BUILTIN_CMP_LOWER, MIPS_INT_FTYPE_V2SF_V2SF,	\
+		AVAIL),							\
+  MIPS_BUILTIN (INSN ## _cond_ps, COND, "upper_" #INSN "_" #COND "_ps",	\
+		MIPS_BUILTIN_CMP_UPPER, MIPS_INT_FTYPE_V2SF_V2SF,	\
+		AVAIL)
 
 /* Define __builtin_mips_{any,all}_<INSN>_<COND>_4s.  The functions
-   require MASK_MIPS3D.  */
+   are subject to mips_builtin_avail_mips3d.  */
 #define CMP_4S_BUILTINS(INSN, COND)					\
-  { CODE_FOR_mips_ ## INSN ## _cond_4s, MIPS_FP_COND_ ## COND,		\
-    "__builtin_mips_any_" #INSN "_" #COND "_4s",			\
-    MIPS_BUILTIN_CMP_ANY, MIPS_INT_FTYPE_V2SF_V2SF_V2SF_V2SF,		\
-    MASK_MIPS3D },							\
-  { CODE_FOR_mips_ ## INSN ## _cond_4s, MIPS_FP_COND_ ## COND,		\
-    "__builtin_mips_all_" #INSN "_" #COND "_4s",			\
-    MIPS_BUILTIN_CMP_ALL, MIPS_INT_FTYPE_V2SF_V2SF_V2SF_V2SF,		\
-    MASK_MIPS3D }
+  MIPS_BUILTIN (INSN ## _cond_4s, COND, "any_" #INSN "_" #COND "_4s",	\
+		MIPS_BUILTIN_CMP_ANY,					\
+		MIPS_INT_FTYPE_V2SF_V2SF_V2SF_V2SF, mips3d),		\
+  MIPS_BUILTIN (INSN ## _cond_4s, COND, "all_" #INSN "_" #COND "_4s",	\
+		MIPS_BUILTIN_CMP_ALL,					\
+		MIPS_INT_FTYPE_V2SF_V2SF_V2SF_V2SF, mips3d)
 
 /* Define __builtin_mips_mov{t,f}_<INSN>_<COND>_ps.  The comparison
-   instruction requires TARGET_FLAGS.  */
-#define MOVTF_BUILTINS(INSN, COND, TARGET_FLAGS)			\
-  { CODE_FOR_mips_ ## INSN ## _cond_ps, MIPS_FP_COND_ ## COND,		\
-    "__builtin_mips_movt_" #INSN "_" #COND "_ps",			\
-    MIPS_BUILTIN_MOVT, MIPS_V2SF_FTYPE_V2SF_V2SF_V2SF_V2SF,		\
-    TARGET_FLAGS },							\
-  { CODE_FOR_mips_ ## INSN ## _cond_ps, MIPS_FP_COND_ ## COND,		\
-    "__builtin_mips_movf_" #INSN "_" #COND "_ps",			\
-    MIPS_BUILTIN_MOVF, MIPS_V2SF_FTYPE_V2SF_V2SF_V2SF_V2SF,		\
-    TARGET_FLAGS }
+   instruction requires mips_builtin_avail_<AVAIL>.  */
+#define MOVTF_BUILTINS(INSN, COND, AVAIL)				\
+  MIPS_BUILTIN (INSN ## _cond_ps, COND, "movt_" #INSN "_" #COND "_ps",	\
+		MIPS_BUILTIN_MOVT, MIPS_V2SF_FTYPE_V2SF_V2SF_V2SF_V2SF,	\
+		AVAIL),							\
+  MIPS_BUILTIN (INSN ## _cond_ps, COND, "movf_" #INSN "_" #COND "_ps",	\
+		MIPS_BUILTIN_MOVF, MIPS_V2SF_FTYPE_V2SF_V2SF_V2SF_V2SF,	\
+		AVAIL)
 
 /* Define all the built-in functions related to C.cond.fmt condition COND.  */
 #define CMP_BUILTINS(COND)						\
-  MOVTF_BUILTINS (c, COND, MASK_PAIRED_SINGLE_FLOAT),			\
-  MOVTF_BUILTINS (cabs, COND, MASK_MIPS3D),				\
-  CMP_SCALAR_BUILTINS (cabs, COND, MASK_MIPS3D),			\
-  CMP_PS_BUILTINS (c, COND, MASK_PAIRED_SINGLE_FLOAT),			\
-  CMP_PS_BUILTINS (cabs, COND, MASK_MIPS3D),				\
+  MOVTF_BUILTINS (c, COND, paired_single),				\
+  MOVTF_BUILTINS (cabs, COND, mips3d),					\
+  CMP_SCALAR_BUILTINS (cabs, COND, mips3d),				\
+  CMP_PS_BUILTINS (c, COND, paired_single),				\
+  CMP_PS_BUILTINS (cabs, COND, mips3d),					\
   CMP_4S_BUILTINS (c, COND),						\
   CMP_4S_BUILTINS (cabs, COND)
 
-static const struct mips_builtin_description mips_ps_bdesc[] = {
-  DIRECT_BUILTIN (pll_ps, MIPS_V2SF_FTYPE_V2SF_V2SF, MASK_PAIRED_SINGLE_FLOAT),
-  DIRECT_BUILTIN (pul_ps, MIPS_V2SF_FTYPE_V2SF_V2SF, MASK_PAIRED_SINGLE_FLOAT),
-  DIRECT_BUILTIN (plu_ps, MIPS_V2SF_FTYPE_V2SF_V2SF, MASK_PAIRED_SINGLE_FLOAT),
-  DIRECT_BUILTIN (puu_ps, MIPS_V2SF_FTYPE_V2SF_V2SF, MASK_PAIRED_SINGLE_FLOAT),
-  DIRECT_BUILTIN (cvt_ps_s, MIPS_V2SF_FTYPE_SF_SF, MASK_PAIRED_SINGLE_FLOAT),
-  DIRECT_BUILTIN (cvt_s_pl, MIPS_SF_FTYPE_V2SF, MASK_PAIRED_SINGLE_FLOAT),
-  DIRECT_BUILTIN (cvt_s_pu, MIPS_SF_FTYPE_V2SF, MASK_PAIRED_SINGLE_FLOAT),
-  DIRECT_BUILTIN (abs_ps, MIPS_V2SF_FTYPE_V2SF, MASK_PAIRED_SINGLE_FLOAT),
-
-  DIRECT_BUILTIN (alnv_ps, MIPS_V2SF_FTYPE_V2SF_V2SF_INT,
-		  MASK_PAIRED_SINGLE_FLOAT),
-  DIRECT_BUILTIN (addr_ps, MIPS_V2SF_FTYPE_V2SF_V2SF, MASK_MIPS3D),
-  DIRECT_BUILTIN (mulr_ps, MIPS_V2SF_FTYPE_V2SF_V2SF, MASK_MIPS3D),
-  DIRECT_BUILTIN (cvt_pw_ps, MIPS_V2SF_FTYPE_V2SF, MASK_MIPS3D),
-  DIRECT_BUILTIN (cvt_ps_pw, MIPS_V2SF_FTYPE_V2SF, MASK_MIPS3D),
-
-  DIRECT_BUILTIN (recip1_s, MIPS_SF_FTYPE_SF, MASK_MIPS3D),
-  DIRECT_BUILTIN (recip1_d, MIPS_DF_FTYPE_DF, MASK_MIPS3D),
-  DIRECT_BUILTIN (recip1_ps, MIPS_V2SF_FTYPE_V2SF, MASK_MIPS3D),
-  DIRECT_BUILTIN (recip2_s, MIPS_SF_FTYPE_SF_SF, MASK_MIPS3D),
-  DIRECT_BUILTIN (recip2_d, MIPS_DF_FTYPE_DF_DF, MASK_MIPS3D),
-  DIRECT_BUILTIN (recip2_ps, MIPS_V2SF_FTYPE_V2SF_V2SF, MASK_MIPS3D),
-
-  DIRECT_BUILTIN (rsqrt1_s, MIPS_SF_FTYPE_SF, MASK_MIPS3D),
-  DIRECT_BUILTIN (rsqrt1_d, MIPS_DF_FTYPE_DF, MASK_MIPS3D),
-  DIRECT_BUILTIN (rsqrt1_ps, MIPS_V2SF_FTYPE_V2SF, MASK_MIPS3D),
-  DIRECT_BUILTIN (rsqrt2_s, MIPS_SF_FTYPE_SF_SF, MASK_MIPS3D),
-  DIRECT_BUILTIN (rsqrt2_d, MIPS_DF_FTYPE_DF_DF, MASK_MIPS3D),
-  DIRECT_BUILTIN (rsqrt2_ps, MIPS_V2SF_FTYPE_V2SF_V2SF, MASK_MIPS3D),
-
-  MIPS_FP_CONDITIONS (CMP_BUILTINS)
-};
+/* Define __builtin_mips_<INSN>, which is a MIPS_BUILTIN_DIRECT_NO_TARGET
+   function mapped to instruction CODE_FOR_mips_<INSN>,  FUNCTION_TYPE
+   and AVAIL are as for MIPS_BUILTIN.  */
+#define DIRECT_NO_TARGET_BUILTIN(INSN, FUNCTION_TYPE, AVAIL)		\
+  MIPS_BUILTIN (INSN, f, #INSN,	MIPS_BUILTIN_DIRECT_NO_TARGET,		\
+		FUNCTION_TYPE, AVAIL)
 
-/* Built-in functions for the SB-1 processor.  */
+/* Define __builtin_mips_bposge<VALUE>.  <VALUE> is 32 for the MIPS32 DSP
+   branch instruction.  AVAIL is as for MIPS_BUILTIN.  */
+#define BPOSGE_BUILTIN(VALUE, AVAIL)					\
+  MIPS_BUILTIN (bposge, f, "bposge" #VALUE,				\
+		MIPS_BUILTIN_BPOSGE ## VALUE, MIPS_SI_FTYPE_VOID, AVAIL)
 
 #define CODE_FOR_mips_sqrt_ps CODE_FOR_sqrtv2sf2
-
-static const struct mips_builtin_description mips_sb1_bdesc[] = {
-  DIRECT_BUILTIN (sqrt_ps, MIPS_V2SF_FTYPE_V2SF, MASK_PAIRED_SINGLE_FLOAT)
-};
-
-/* Built-in functions for the DSP ASE.  */
-
 #define CODE_FOR_mips_addq_ph CODE_FOR_addv2hi3
 #define CODE_FOR_mips_addu_qb CODE_FOR_addv4qi3
 #define CODE_FOR_mips_subq_ph CODE_FOR_subv2hi3
 #define CODE_FOR_mips_subu_qb CODE_FOR_subv4qi3
 #define CODE_FOR_mips_mul_ph CODE_FOR_mulv2hi3
 
-/* Define a MIPS_BUILTIN_DIRECT_NO_TARGET function for instruction
-   CODE_FOR_mips_<INSN>.  FUNCTION_TYPE and TARGET_FLAGS are
-   mips_builtin_description fields.  */
-#define DIRECT_NO_TARGET_BUILTIN(INSN, FUNCTION_TYPE, TARGET_FLAGS)	\
-  { CODE_FOR_mips_ ## INSN, 0, "__builtin_mips_" #INSN,			\
-    MIPS_BUILTIN_DIRECT_NO_TARGET, FUNCTION_TYPE, TARGET_FLAGS }
-
-/* Define __builtin_mips_bposge<VALUE>.  <VALUE> is 32 for the MIPS32 DSP
-   branch instruction.  TARGET_FLAGS is a mips_builtin_description field.  */
-#define BPOSGE_BUILTIN(VALUE, TARGET_FLAGS)				\
-  { CODE_FOR_mips_bposge, 0, "__builtin_mips_bposge" #VALUE,		\
-    MIPS_BUILTIN_BPOSGE ## VALUE, MIPS_SI_FTYPE_VOID, TARGET_FLAGS }
-
-static const struct mips_builtin_description mips_dsp_bdesc[] = {
-  DIRECT_BUILTIN (addq_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, MASK_DSP),
-  DIRECT_BUILTIN (addq_s_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, MASK_DSP),
-  DIRECT_BUILTIN (addq_s_w, MIPS_SI_FTYPE_SI_SI, MASK_DSP),
-  DIRECT_BUILTIN (addu_qb, MIPS_V4QI_FTYPE_V4QI_V4QI, MASK_DSP),
-  DIRECT_BUILTIN (addu_s_qb, MIPS_V4QI_FTYPE_V4QI_V4QI, MASK_DSP),
-  DIRECT_BUILTIN (subq_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, MASK_DSP),
-  DIRECT_BUILTIN (subq_s_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, MASK_DSP),
-  DIRECT_BUILTIN (subq_s_w, MIPS_SI_FTYPE_SI_SI, MASK_DSP),
-  DIRECT_BUILTIN (subu_qb, MIPS_V4QI_FTYPE_V4QI_V4QI, MASK_DSP),
-  DIRECT_BUILTIN (subu_s_qb, MIPS_V4QI_FTYPE_V4QI_V4QI, MASK_DSP),
-  DIRECT_BUILTIN (addsc, MIPS_SI_FTYPE_SI_SI, MASK_DSP),
-  DIRECT_BUILTIN (addwc, MIPS_SI_FTYPE_SI_SI, MASK_DSP),
-  DIRECT_BUILTIN (modsub, MIPS_SI_FTYPE_SI_SI, MASK_DSP),
-  DIRECT_BUILTIN (raddu_w_qb, MIPS_SI_FTYPE_V4QI, MASK_DSP),
-  DIRECT_BUILTIN (absq_s_ph, MIPS_V2HI_FTYPE_V2HI, MASK_DSP),
-  DIRECT_BUILTIN (absq_s_w, MIPS_SI_FTYPE_SI, MASK_DSP),
-  DIRECT_BUILTIN (precrq_qb_ph, MIPS_V4QI_FTYPE_V2HI_V2HI, MASK_DSP),
-  DIRECT_BUILTIN (precrq_ph_w, MIPS_V2HI_FTYPE_SI_SI, MASK_DSP),
-  DIRECT_BUILTIN (precrq_rs_ph_w, MIPS_V2HI_FTYPE_SI_SI, MASK_DSP),
-  DIRECT_BUILTIN (precrqu_s_qb_ph, MIPS_V4QI_FTYPE_V2HI_V2HI, MASK_DSP),
-  DIRECT_BUILTIN (preceq_w_phl, MIPS_SI_FTYPE_V2HI, MASK_DSP),
-  DIRECT_BUILTIN (preceq_w_phr, MIPS_SI_FTYPE_V2HI, MASK_DSP),
-  DIRECT_BUILTIN (precequ_ph_qbl, MIPS_V2HI_FTYPE_V4QI, MASK_DSP),
-  DIRECT_BUILTIN (precequ_ph_qbr, MIPS_V2HI_FTYPE_V4QI, MASK_DSP),
-  DIRECT_BUILTIN (precequ_ph_qbla, MIPS_V2HI_FTYPE_V4QI, MASK_DSP),
-  DIRECT_BUILTIN (precequ_ph_qbra, MIPS_V2HI_FTYPE_V4QI, MASK_DSP),
-  DIRECT_BUILTIN (preceu_ph_qbl, MIPS_V2HI_FTYPE_V4QI, MASK_DSP),
-  DIRECT_BUILTIN (preceu_ph_qbr, MIPS_V2HI_FTYPE_V4QI, MASK_DSP),
-  DIRECT_BUILTIN (preceu_ph_qbla, MIPS_V2HI_FTYPE_V4QI, MASK_DSP),
-  DIRECT_BUILTIN (preceu_ph_qbra, MIPS_V2HI_FTYPE_V4QI, MASK_DSP),
-  DIRECT_BUILTIN (shll_qb, MIPS_V4QI_FTYPE_V4QI_SI, MASK_DSP),
-  DIRECT_BUILTIN (shll_ph, MIPS_V2HI_FTYPE_V2HI_SI, MASK_DSP),
-  DIRECT_BUILTIN (shll_s_ph, MIPS_V2HI_FTYPE_V2HI_SI, MASK_DSP),
-  DIRECT_BUILTIN (shll_s_w, MIPS_SI_FTYPE_SI_SI, MASK_DSP),
-  DIRECT_BUILTIN (shrl_qb, MIPS_V4QI_FTYPE_V4QI_SI, MASK_DSP),
-  DIRECT_BUILTIN (shra_ph, MIPS_V2HI_FTYPE_V2HI_SI, MASK_DSP),
-  DIRECT_BUILTIN (shra_r_ph, MIPS_V2HI_FTYPE_V2HI_SI, MASK_DSP),
-  DIRECT_BUILTIN (shra_r_w, MIPS_SI_FTYPE_SI_SI, MASK_DSP),
-  DIRECT_BUILTIN (muleu_s_ph_qbl, MIPS_V2HI_FTYPE_V4QI_V2HI, MASK_DSP),
-  DIRECT_BUILTIN (muleu_s_ph_qbr, MIPS_V2HI_FTYPE_V4QI_V2HI, MASK_DSP),
-  DIRECT_BUILTIN (mulq_rs_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, MASK_DSP),
-  DIRECT_BUILTIN (muleq_s_w_phl, MIPS_SI_FTYPE_V2HI_V2HI, MASK_DSP),
-  DIRECT_BUILTIN (muleq_s_w_phr, MIPS_SI_FTYPE_V2HI_V2HI, MASK_DSP),
-  DIRECT_BUILTIN (bitrev, MIPS_SI_FTYPE_SI, MASK_DSP),
-  DIRECT_BUILTIN (insv, MIPS_SI_FTYPE_SI_SI, MASK_DSP),
-  DIRECT_BUILTIN (repl_qb, MIPS_V4QI_FTYPE_SI, MASK_DSP),
-  DIRECT_BUILTIN (repl_ph, MIPS_V2HI_FTYPE_SI, MASK_DSP),
-  DIRECT_NO_TARGET_BUILTIN (cmpu_eq_qb, MIPS_VOID_FTYPE_V4QI_V4QI, MASK_DSP),
-  DIRECT_NO_TARGET_BUILTIN (cmpu_lt_qb, MIPS_VOID_FTYPE_V4QI_V4QI, MASK_DSP),
-  DIRECT_NO_TARGET_BUILTIN (cmpu_le_qb, MIPS_VOID_FTYPE_V4QI_V4QI, MASK_DSP),
-  DIRECT_BUILTIN (cmpgu_eq_qb, MIPS_SI_FTYPE_V4QI_V4QI, MASK_DSP),
-  DIRECT_BUILTIN (cmpgu_lt_qb, MIPS_SI_FTYPE_V4QI_V4QI, MASK_DSP),
-  DIRECT_BUILTIN (cmpgu_le_qb, MIPS_SI_FTYPE_V4QI_V4QI, MASK_DSP),
-  DIRECT_NO_TARGET_BUILTIN (cmp_eq_ph, MIPS_VOID_FTYPE_V2HI_V2HI, MASK_DSP),
-  DIRECT_NO_TARGET_BUILTIN (cmp_lt_ph, MIPS_VOID_FTYPE_V2HI_V2HI, MASK_DSP),
-  DIRECT_NO_TARGET_BUILTIN (cmp_le_ph, MIPS_VOID_FTYPE_V2HI_V2HI, MASK_DSP),
-  DIRECT_BUILTIN (pick_qb, MIPS_V4QI_FTYPE_V4QI_V4QI, MASK_DSP),
-  DIRECT_BUILTIN (pick_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, MASK_DSP),
-  DIRECT_BUILTIN (packrl_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, MASK_DSP),
-  DIRECT_NO_TARGET_BUILTIN (wrdsp, MIPS_VOID_FTYPE_SI_SI, MASK_DSP),
-  DIRECT_BUILTIN (rddsp, MIPS_SI_FTYPE_SI, MASK_DSP),
-  DIRECT_BUILTIN (lbux, MIPS_SI_FTYPE_POINTER_SI, MASK_DSP),
-  DIRECT_BUILTIN (lhx, MIPS_SI_FTYPE_POINTER_SI, MASK_DSP),
-  DIRECT_BUILTIN (lwx, MIPS_SI_FTYPE_POINTER_SI, MASK_DSP),
-  BPOSGE_BUILTIN (32, MASK_DSP),
-
-  /* The following are for the MIPS DSP ASE REV 2.  */
-  DIRECT_BUILTIN (absq_s_qb, MIPS_V4QI_FTYPE_V4QI, MASK_DSPR2),
-  DIRECT_BUILTIN (addu_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, MASK_DSPR2),
-  DIRECT_BUILTIN (addu_s_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, MASK_DSPR2),
-  DIRECT_BUILTIN (adduh_qb, MIPS_V4QI_FTYPE_V4QI_V4QI, MASK_DSPR2),
-  DIRECT_BUILTIN (adduh_r_qb, MIPS_V4QI_FTYPE_V4QI_V4QI, MASK_DSPR2),
-  DIRECT_BUILTIN (append, MIPS_SI_FTYPE_SI_SI_SI, MASK_DSPR2),
-  DIRECT_BUILTIN (balign, MIPS_SI_FTYPE_SI_SI_SI, MASK_DSPR2),
-  DIRECT_BUILTIN (cmpgdu_eq_qb, MIPS_SI_FTYPE_V4QI_V4QI, MASK_DSPR2),
-  DIRECT_BUILTIN (cmpgdu_lt_qb, MIPS_SI_FTYPE_V4QI_V4QI, MASK_DSPR2),
-  DIRECT_BUILTIN (cmpgdu_le_qb, MIPS_SI_FTYPE_V4QI_V4QI, MASK_DSPR2),
-  DIRECT_BUILTIN (mul_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, MASK_DSPR2),
-  DIRECT_BUILTIN (mul_s_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, MASK_DSPR2),
-  DIRECT_BUILTIN (mulq_rs_w, MIPS_SI_FTYPE_SI_SI, MASK_DSPR2),
-  DIRECT_BUILTIN (mulq_s_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, MASK_DSPR2),
-  DIRECT_BUILTIN (mulq_s_w, MIPS_SI_FTYPE_SI_SI, MASK_DSPR2),
-  DIRECT_BUILTIN (precr_qb_ph, MIPS_V4QI_FTYPE_V2HI_V2HI, MASK_DSPR2),
-  DIRECT_BUILTIN (precr_sra_ph_w, MIPS_V2HI_FTYPE_SI_SI_SI, MASK_DSPR2),
-  DIRECT_BUILTIN (precr_sra_r_ph_w, MIPS_V2HI_FTYPE_SI_SI_SI, MASK_DSPR2),
-  DIRECT_BUILTIN (prepend, MIPS_SI_FTYPE_SI_SI_SI, MASK_DSPR2),
-  DIRECT_BUILTIN (shra_qb, MIPS_V4QI_FTYPE_V4QI_SI, MASK_DSPR2),
-  DIRECT_BUILTIN (shra_r_qb, MIPS_V4QI_FTYPE_V4QI_SI, MASK_DSPR2),
-  DIRECT_BUILTIN (shrl_ph, MIPS_V2HI_FTYPE_V2HI_SI, MASK_DSPR2),
-  DIRECT_BUILTIN (subu_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, MASK_DSPR2),
-  DIRECT_BUILTIN (subu_s_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, MASK_DSPR2),
-  DIRECT_BUILTIN (subuh_qb, MIPS_V4QI_FTYPE_V4QI_V4QI, MASK_DSPR2),
-  DIRECT_BUILTIN (subuh_r_qb, MIPS_V4QI_FTYPE_V4QI_V4QI, MASK_DSPR2),
-  DIRECT_BUILTIN (addqh_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, MASK_DSPR2),
-  DIRECT_BUILTIN (addqh_r_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, MASK_DSPR2),
-  DIRECT_BUILTIN (addqh_w, MIPS_SI_FTYPE_SI_SI, MASK_DSPR2),
-  DIRECT_BUILTIN (addqh_r_w, MIPS_SI_FTYPE_SI_SI, MASK_DSPR2),
-  DIRECT_BUILTIN (subqh_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, MASK_DSPR2),
-  DIRECT_BUILTIN (subqh_r_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, MASK_DSPR2),
-  DIRECT_BUILTIN (subqh_w, MIPS_SI_FTYPE_SI_SI, MASK_DSPR2),
-  DIRECT_BUILTIN (subqh_r_w, MIPS_SI_FTYPE_SI_SI, MASK_DSPR2)
-};
-
-static const struct mips_builtin_description mips_dsp_32only_bdesc[] = {
-  DIRECT_BUILTIN (dpau_h_qbl, MIPS_DI_FTYPE_DI_V4QI_V4QI, MASK_DSP),
-  DIRECT_BUILTIN (dpau_h_qbr, MIPS_DI_FTYPE_DI_V4QI_V4QI, MASK_DSP),
-  DIRECT_BUILTIN (dpsu_h_qbl, MIPS_DI_FTYPE_DI_V4QI_V4QI, MASK_DSP),
-  DIRECT_BUILTIN (dpsu_h_qbr, MIPS_DI_FTYPE_DI_V4QI_V4QI, MASK_DSP),
-  DIRECT_BUILTIN (dpaq_s_w_ph, MIPS_DI_FTYPE_DI_V2HI_V2HI, MASK_DSP),
-  DIRECT_BUILTIN (dpsq_s_w_ph, MIPS_DI_FTYPE_DI_V2HI_V2HI, MASK_DSP),
-  DIRECT_BUILTIN (mulsaq_s_w_ph, MIPS_DI_FTYPE_DI_V2HI_V2HI, MASK_DSP),
-  DIRECT_BUILTIN (dpaq_sa_l_w, MIPS_DI_FTYPE_DI_SI_SI, MASK_DSP),
-  DIRECT_BUILTIN (dpsq_sa_l_w, MIPS_DI_FTYPE_DI_SI_SI, MASK_DSP),
-  DIRECT_BUILTIN (maq_s_w_phl, MIPS_DI_FTYPE_DI_V2HI_V2HI, MASK_DSP),
-  DIRECT_BUILTIN (maq_s_w_phr, MIPS_DI_FTYPE_DI_V2HI_V2HI, MASK_DSP),
-  DIRECT_BUILTIN (maq_sa_w_phl, MIPS_DI_FTYPE_DI_V2HI_V2HI, MASK_DSP),
-  DIRECT_BUILTIN (maq_sa_w_phr, MIPS_DI_FTYPE_DI_V2HI_V2HI, MASK_DSP),
-  DIRECT_BUILTIN (extr_w, MIPS_SI_FTYPE_DI_SI, MASK_DSP),
-  DIRECT_BUILTIN (extr_r_w, MIPS_SI_FTYPE_DI_SI, MASK_DSP),
-  DIRECT_BUILTIN (extr_rs_w, MIPS_SI_FTYPE_DI_SI, MASK_DSP),
-  DIRECT_BUILTIN (extr_s_h, MIPS_SI_FTYPE_DI_SI, MASK_DSP),
-  DIRECT_BUILTIN (extp, MIPS_SI_FTYPE_DI_SI, MASK_DSP),
-  DIRECT_BUILTIN (extpdp, MIPS_SI_FTYPE_DI_SI, MASK_DSP),
-  DIRECT_BUILTIN (shilo, MIPS_DI_FTYPE_DI_SI, MASK_DSP),
-  DIRECT_BUILTIN (mthlip, MIPS_DI_FTYPE_DI_SI, MASK_DSP),
-
-  /* The following are for the MIPS DSP ASE REV 2.  */
-  DIRECT_BUILTIN (dpa_w_ph, MIPS_DI_FTYPE_DI_V2HI_V2HI, MASK_DSPR2),
-  DIRECT_BUILTIN (dps_w_ph, MIPS_DI_FTYPE_DI_V2HI_V2HI, MASK_DSPR2),
-  DIRECT_BUILTIN (madd, MIPS_DI_FTYPE_DI_SI_SI, MASK_DSPR2),
-  DIRECT_BUILTIN (maddu, MIPS_DI_FTYPE_DI_USI_USI, MASK_DSPR2),
-  DIRECT_BUILTIN (msub, MIPS_DI_FTYPE_DI_SI_SI, MASK_DSPR2),
-  DIRECT_BUILTIN (msubu, MIPS_DI_FTYPE_DI_USI_USI, MASK_DSPR2),
-  DIRECT_BUILTIN (mulsa_w_ph, MIPS_DI_FTYPE_DI_V2HI_V2HI, MASK_DSPR2),
-  DIRECT_BUILTIN (mult, MIPS_DI_FTYPE_SI_SI, MASK_DSPR2),
-  DIRECT_BUILTIN (multu, MIPS_DI_FTYPE_USI_USI, MASK_DSPR2),
-  DIRECT_BUILTIN (dpax_w_ph, MIPS_DI_FTYPE_DI_V2HI_V2HI, MASK_DSPR2),
-  DIRECT_BUILTIN (dpsx_w_ph, MIPS_DI_FTYPE_DI_V2HI_V2HI, MASK_DSPR2),
-  DIRECT_BUILTIN (dpaqx_s_w_ph, MIPS_DI_FTYPE_DI_V2HI_V2HI, MASK_DSPR2),
-  DIRECT_BUILTIN (dpaqx_sa_w_ph, MIPS_DI_FTYPE_DI_V2HI_V2HI, MASK_DSPR2),
-  DIRECT_BUILTIN (dpsqx_s_w_ph, MIPS_DI_FTYPE_DI_V2HI_V2HI, MASK_DSPR2),
-  DIRECT_BUILTIN (dpsqx_sa_w_ph, MIPS_DI_FTYPE_DI_V2HI_V2HI, MASK_DSPR2)
-};
-
-/* This structure describes an array of mips_builtin_description entries.  */
-struct mips_bdesc_map {
-  /* The array that this entry describes.  */
-  const struct mips_builtin_description *bdesc;
-
-  /* The number of entries in BDESC.  */
-  unsigned int size;
-
-  /* The target processor that supports the functions in BDESC.
-     PROCESSOR_MAX means we enable them for all processors.  */
-  enum processor_type proc;
-
-  /* The functions in BDESC are not supported if any of these
-     target flags are set.  */
-  int unsupported_target_flags;
-};
-
-/* All MIPS-specific built-in functions.  */
-static const struct mips_bdesc_map mips_bdesc_arrays[] = {
-  { mips_ps_bdesc, ARRAY_SIZE (mips_ps_bdesc), PROCESSOR_MAX, 0 },
-  { mips_sb1_bdesc, ARRAY_SIZE (mips_sb1_bdesc), PROCESSOR_SB1, 0 },
-  { mips_dsp_bdesc, ARRAY_SIZE (mips_dsp_bdesc), PROCESSOR_MAX, 0 },
-  { mips_dsp_32only_bdesc, ARRAY_SIZE (mips_dsp_32only_bdesc),
-    PROCESSOR_MAX, MASK_64BIT }
+static const struct mips_builtin_description mips_builtins[] = {
+  DIRECT_BUILTIN (pll_ps, MIPS_V2SF_FTYPE_V2SF_V2SF, paired_single),
+  DIRECT_BUILTIN (pul_ps, MIPS_V2SF_FTYPE_V2SF_V2SF, paired_single),
+  DIRECT_BUILTIN (plu_ps, MIPS_V2SF_FTYPE_V2SF_V2SF, paired_single),
+  DIRECT_BUILTIN (puu_ps, MIPS_V2SF_FTYPE_V2SF_V2SF, paired_single),
+  DIRECT_BUILTIN (cvt_ps_s, MIPS_V2SF_FTYPE_SF_SF, paired_single),
+  DIRECT_BUILTIN (cvt_s_pl, MIPS_SF_FTYPE_V2SF, paired_single),
+  DIRECT_BUILTIN (cvt_s_pu, MIPS_SF_FTYPE_V2SF, paired_single),
+  DIRECT_BUILTIN (abs_ps, MIPS_V2SF_FTYPE_V2SF, paired_single),
+
+  DIRECT_BUILTIN (alnv_ps, MIPS_V2SF_FTYPE_V2SF_V2SF_INT, paired_single),
+  DIRECT_BUILTIN (addr_ps, MIPS_V2SF_FTYPE_V2SF_V2SF, mips3d),
+  DIRECT_BUILTIN (mulr_ps, MIPS_V2SF_FTYPE_V2SF_V2SF, mips3d),
+  DIRECT_BUILTIN (cvt_pw_ps, MIPS_V2SF_FTYPE_V2SF, mips3d),
+  DIRECT_BUILTIN (cvt_ps_pw, MIPS_V2SF_FTYPE_V2SF, mips3d),
+
+  DIRECT_BUILTIN (recip1_s, MIPS_SF_FTYPE_SF, mips3d),
+  DIRECT_BUILTIN (recip1_d, MIPS_DF_FTYPE_DF, mips3d),
+  DIRECT_BUILTIN (recip1_ps, MIPS_V2SF_FTYPE_V2SF, mips3d),
+  DIRECT_BUILTIN (recip2_s, MIPS_SF_FTYPE_SF_SF, mips3d),
+  DIRECT_BUILTIN (recip2_d, MIPS_DF_FTYPE_DF_DF, mips3d),
+  DIRECT_BUILTIN (recip2_ps, MIPS_V2SF_FTYPE_V2SF_V2SF, mips3d),
+
+  DIRECT_BUILTIN (rsqrt1_s, MIPS_SF_FTYPE_SF, mips3d),
+  DIRECT_BUILTIN (rsqrt1_d, MIPS_DF_FTYPE_DF, mips3d),
+  DIRECT_BUILTIN (rsqrt1_ps, MIPS_V2SF_FTYPE_V2SF, mips3d),
+  DIRECT_BUILTIN (rsqrt2_s, MIPS_SF_FTYPE_SF_SF, mips3d),
+  DIRECT_BUILTIN (rsqrt2_d, MIPS_DF_FTYPE_DF_DF, mips3d),
+  DIRECT_BUILTIN (rsqrt2_ps, MIPS_V2SF_FTYPE_V2SF_V2SF, mips3d),
+
+  MIPS_FP_CONDITIONS (CMP_BUILTINS),
+
+  /* Built-in functions for the SB-1 processor.  */
+  DIRECT_BUILTIN (sqrt_ps, MIPS_V2SF_FTYPE_V2SF, sb1_paired_single),
+
+  /* Built-in functions for the DSP ASE (32-bit and 64-bit).  */
+  DIRECT_BUILTIN (addq_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, dsp),
+  DIRECT_BUILTIN (addq_s_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, dsp),
+  DIRECT_BUILTIN (addq_s_w, MIPS_SI_FTYPE_SI_SI, dsp),
+  DIRECT_BUILTIN (addu_qb, MIPS_V4QI_FTYPE_V4QI_V4QI, dsp),
+  DIRECT_BUILTIN (addu_s_qb, MIPS_V4QI_FTYPE_V4QI_V4QI, dsp),
+  DIRECT_BUILTIN (subq_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, dsp),
+  DIRECT_BUILTIN (subq_s_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, dsp),
+  DIRECT_BUILTIN (subq_s_w, MIPS_SI_FTYPE_SI_SI, dsp),
+  DIRECT_BUILTIN (subu_qb, MIPS_V4QI_FTYPE_V4QI_V4QI, dsp),
+  DIRECT_BUILTIN (subu_s_qb, MIPS_V4QI_FTYPE_V4QI_V4QI, dsp),
+  DIRECT_BUILTIN (addsc, MIPS_SI_FTYPE_SI_SI, dsp),
+  DIRECT_BUILTIN (addwc, MIPS_SI_FTYPE_SI_SI, dsp),
+  DIRECT_BUILTIN (modsub, MIPS_SI_FTYPE_SI_SI, dsp),
+  DIRECT_BUILTIN (raddu_w_qb, MIPS_SI_FTYPE_V4QI, dsp),
+  DIRECT_BUILTIN (absq_s_ph, MIPS_V2HI_FTYPE_V2HI, dsp),
+  DIRECT_BUILTIN (absq_s_w, MIPS_SI_FTYPE_SI, dsp),
+  DIRECT_BUILTIN (precrq_qb_ph, MIPS_V4QI_FTYPE_V2HI_V2HI, dsp),
+  DIRECT_BUILTIN (precrq_ph_w, MIPS_V2HI_FTYPE_SI_SI, dsp),
+  DIRECT_BUILTIN (precrq_rs_ph_w, MIPS_V2HI_FTYPE_SI_SI, dsp),
+  DIRECT_BUILTIN (precrqu_s_qb_ph, MIPS_V4QI_FTYPE_V2HI_V2HI, dsp),
+  DIRECT_BUILTIN (preceq_w_phl, MIPS_SI_FTYPE_V2HI, dsp),
+  DIRECT_BUILTIN (preceq_w_phr, MIPS_SI_FTYPE_V2HI, dsp),
+  DIRECT_BUILTIN (precequ_ph_qbl, MIPS_V2HI_FTYPE_V4QI, dsp),
+  DIRECT_BUILTIN (precequ_ph_qbr, MIPS_V2HI_FTYPE_V4QI, dsp),
+  DIRECT_BUILTIN (precequ_ph_qbla, MIPS_V2HI_FTYPE_V4QI, dsp),
+  DIRECT_BUILTIN (precequ_ph_qbra, MIPS_V2HI_FTYPE_V4QI, dsp),
+  DIRECT_BUILTIN (preceu_ph_qbl, MIPS_V2HI_FTYPE_V4QI, dsp),
+  DIRECT_BUILTIN (preceu_ph_qbr, MIPS_V2HI_FTYPE_V4QI, dsp),
+  DIRECT_BUILTIN (preceu_ph_qbla, MIPS_V2HI_FTYPE_V4QI, dsp),
+  DIRECT_BUILTIN (preceu_ph_qbra, MIPS_V2HI_FTYPE_V4QI, dsp),
+  DIRECT_BUILTIN (shll_qb, MIPS_V4QI_FTYPE_V4QI_SI, dsp),
+  DIRECT_BUILTIN (shll_ph, MIPS_V2HI_FTYPE_V2HI_SI, dsp),
+  DIRECT_BUILTIN (shll_s_ph, MIPS_V2HI_FTYPE_V2HI_SI, dsp),
+  DIRECT_BUILTIN (shll_s_w, MIPS_SI_FTYPE_SI_SI, dsp),
+  DIRECT_BUILTIN (shrl_qb, MIPS_V4QI_FTYPE_V4QI_SI, dsp),
+  DIRECT_BUILTIN (shra_ph, MIPS_V2HI_FTYPE_V2HI_SI, dsp),
+  DIRECT_BUILTIN (shra_r_ph, MIPS_V2HI_FTYPE_V2HI_SI, dsp),
+  DIRECT_BUILTIN (shra_r_w, MIPS_SI_FTYPE_SI_SI, dsp),
+  DIRECT_BUILTIN (muleu_s_ph_qbl, MIPS_V2HI_FTYPE_V4QI_V2HI, dsp),
+  DIRECT_BUILTIN (muleu_s_ph_qbr, MIPS_V2HI_FTYPE_V4QI_V2HI, dsp),
+  DIRECT_BUILTIN (mulq_rs_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, dsp),
+  DIRECT_BUILTIN (muleq_s_w_phl, MIPS_SI_FTYPE_V2HI_V2HI, dsp),
+  DIRECT_BUILTIN (muleq_s_w_phr, MIPS_SI_FTYPE_V2HI_V2HI, dsp),
+  DIRECT_BUILTIN (bitrev, MIPS_SI_FTYPE_SI, dsp),
+  DIRECT_BUILTIN (insv, MIPS_SI_FTYPE_SI_SI, dsp),
+  DIRECT_BUILTIN (repl_qb, MIPS_V4QI_FTYPE_SI, dsp),
+  DIRECT_BUILTIN (repl_ph, MIPS_V2HI_FTYPE_SI, dsp),
+  DIRECT_NO_TARGET_BUILTIN (cmpu_eq_qb, MIPS_VOID_FTYPE_V4QI_V4QI, dsp),
+  DIRECT_NO_TARGET_BUILTIN (cmpu_lt_qb, MIPS_VOID_FTYPE_V4QI_V4QI, dsp),
+  DIRECT_NO_TARGET_BUILTIN (cmpu_le_qb, MIPS_VOID_FTYPE_V4QI_V4QI, dsp),
+  DIRECT_BUILTIN (cmpgu_eq_qb, MIPS_SI_FTYPE_V4QI_V4QI, dsp),
+  DIRECT_BUILTIN (cmpgu_lt_qb, MIPS_SI_FTYPE_V4QI_V4QI, dsp),
+  DIRECT_BUILTIN (cmpgu_le_qb, MIPS_SI_FTYPE_V4QI_V4QI, dsp),
+  DIRECT_NO_TARGET_BUILTIN (cmp_eq_ph, MIPS_VOID_FTYPE_V2HI_V2HI, dsp),
+  DIRECT_NO_TARGET_BUILTIN (cmp_lt_ph, MIPS_VOID_FTYPE_V2HI_V2HI, dsp),
+  DIRECT_NO_TARGET_BUILTIN (cmp_le_ph, MIPS_VOID_FTYPE_V2HI_V2HI, dsp),
+  DIRECT_BUILTIN (pick_qb, MIPS_V4QI_FTYPE_V4QI_V4QI, dsp),
+  DIRECT_BUILTIN (pick_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, dsp),
+  DIRECT_BUILTIN (packrl_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, dsp),
+  DIRECT_NO_TARGET_BUILTIN (wrdsp, MIPS_VOID_FTYPE_SI_SI, dsp),
+  DIRECT_BUILTIN (rddsp, MIPS_SI_FTYPE_SI, dsp),
+  DIRECT_BUILTIN (lbux, MIPS_SI_FTYPE_POINTER_SI, dsp),
+  DIRECT_BUILTIN (lhx, MIPS_SI_FTYPE_POINTER_SI, dsp),
+  DIRECT_BUILTIN (lwx, MIPS_SI_FTYPE_POINTER_SI, dsp),
+  BPOSGE_BUILTIN (32, dsp),
+
+  /* The following are for the MIPS DSP ASE REV 2 (32-bit and 64-bit).  */
+  DIRECT_BUILTIN (absq_s_qb, MIPS_V4QI_FTYPE_V4QI, dspr2),
+  DIRECT_BUILTIN (addu_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, dspr2),
+  DIRECT_BUILTIN (addu_s_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, dspr2),
+  DIRECT_BUILTIN (adduh_qb, MIPS_V4QI_FTYPE_V4QI_V4QI, dspr2),
+  DIRECT_BUILTIN (adduh_r_qb, MIPS_V4QI_FTYPE_V4QI_V4QI, dspr2),
+  DIRECT_BUILTIN (append, MIPS_SI_FTYPE_SI_SI_SI, dspr2),
+  DIRECT_BUILTIN (balign, MIPS_SI_FTYPE_SI_SI_SI, dspr2),
+  DIRECT_BUILTIN (cmpgdu_eq_qb, MIPS_SI_FTYPE_V4QI_V4QI, dspr2),
+  DIRECT_BUILTIN (cmpgdu_lt_qb, MIPS_SI_FTYPE_V4QI_V4QI, dspr2),
+  DIRECT_BUILTIN (cmpgdu_le_qb, MIPS_SI_FTYPE_V4QI_V4QI, dspr2),
+  DIRECT_BUILTIN (mul_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, dspr2),
+  DIRECT_BUILTIN (mul_s_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, dspr2),
+  DIRECT_BUILTIN (mulq_rs_w, MIPS_SI_FTYPE_SI_SI, dspr2),
+  DIRECT_BUILTIN (mulq_s_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, dspr2),
+  DIRECT_BUILTIN (mulq_s_w, MIPS_SI_FTYPE_SI_SI, dspr2),
+  DIRECT_BUILTIN (precr_qb_ph, MIPS_V4QI_FTYPE_V2HI_V2HI, dspr2),
+  DIRECT_BUILTIN (precr_sra_ph_w, MIPS_V2HI_FTYPE_SI_SI_SI, dspr2),
+  DIRECT_BUILTIN (precr_sra_r_ph_w, MIPS_V2HI_FTYPE_SI_SI_SI, dspr2),
+  DIRECT_BUILTIN (prepend, MIPS_SI_FTYPE_SI_SI_SI, dspr2),
+  DIRECT_BUILTIN (shra_qb, MIPS_V4QI_FTYPE_V4QI_SI, dspr2),
+  DIRECT_BUILTIN (shra_r_qb, MIPS_V4QI_FTYPE_V4QI_SI, dspr2),
+  DIRECT_BUILTIN (shrl_ph, MIPS_V2HI_FTYPE_V2HI_SI, dspr2),
+  DIRECT_BUILTIN (subu_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, dspr2),
+  DIRECT_BUILTIN (subu_s_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, dspr2),
+  DIRECT_BUILTIN (subuh_qb, MIPS_V4QI_FTYPE_V4QI_V4QI, dspr2),
+  DIRECT_BUILTIN (subuh_r_qb, MIPS_V4QI_FTYPE_V4QI_V4QI, dspr2),
+  DIRECT_BUILTIN (addqh_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, dspr2),
+  DIRECT_BUILTIN (addqh_r_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, dspr2),
+  DIRECT_BUILTIN (addqh_w, MIPS_SI_FTYPE_SI_SI, dspr2),
+  DIRECT_BUILTIN (addqh_r_w, MIPS_SI_FTYPE_SI_SI, dspr2),
+  DIRECT_BUILTIN (subqh_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, dspr2),
+  DIRECT_BUILTIN (subqh_r_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, dspr2),
+  DIRECT_BUILTIN (subqh_w, MIPS_SI_FTYPE_SI_SI, dspr2),
+  DIRECT_BUILTIN (subqh_r_w, MIPS_SI_FTYPE_SI_SI, dspr2),
+
+  /* Built-in functions for the DSP ASE (32-bit only).  */
+  DIRECT_BUILTIN (dpau_h_qbl, MIPS_DI_FTYPE_DI_V4QI_V4QI, dsp_32),
+  DIRECT_BUILTIN (dpau_h_qbr, MIPS_DI_FTYPE_DI_V4QI_V4QI, dsp_32),
+  DIRECT_BUILTIN (dpsu_h_qbl, MIPS_DI_FTYPE_DI_V4QI_V4QI, dsp_32),
+  DIRECT_BUILTIN (dpsu_h_qbr, MIPS_DI_FTYPE_DI_V4QI_V4QI, dsp_32),
+  DIRECT_BUILTIN (dpaq_s_w_ph, MIPS_DI_FTYPE_DI_V2HI_V2HI, dsp_32),
+  DIRECT_BUILTIN (dpsq_s_w_ph, MIPS_DI_FTYPE_DI_V2HI_V2HI, dsp_32),
+  DIRECT_BUILTIN (mulsaq_s_w_ph, MIPS_DI_FTYPE_DI_V2HI_V2HI, dsp_32),
+  DIRECT_BUILTIN (dpaq_sa_l_w, MIPS_DI_FTYPE_DI_SI_SI, dsp_32),
+  DIRECT_BUILTIN (dpsq_sa_l_w, MIPS_DI_FTYPE_DI_SI_SI, dsp_32),
+  DIRECT_BUILTIN (maq_s_w_phl, MIPS_DI_FTYPE_DI_V2HI_V2HI, dsp_32),
+  DIRECT_BUILTIN (maq_s_w_phr, MIPS_DI_FTYPE_DI_V2HI_V2HI, dsp_32),
+  DIRECT_BUILTIN (maq_sa_w_phl, MIPS_DI_FTYPE_DI_V2HI_V2HI, dsp_32),
+  DIRECT_BUILTIN (maq_sa_w_phr, MIPS_DI_FTYPE_DI_V2HI_V2HI, dsp_32),
+  DIRECT_BUILTIN (extr_w, MIPS_SI_FTYPE_DI_SI, dsp_32),
+  DIRECT_BUILTIN (extr_r_w, MIPS_SI_FTYPE_DI_SI, dsp_32),
+  DIRECT_BUILTIN (extr_rs_w, MIPS_SI_FTYPE_DI_SI, dsp_32),
+  DIRECT_BUILTIN (extr_s_h, MIPS_SI_FTYPE_DI_SI, dsp_32),
+  DIRECT_BUILTIN (extp, MIPS_SI_FTYPE_DI_SI, dsp_32),
+  DIRECT_BUILTIN (extpdp, MIPS_SI_FTYPE_DI_SI, dsp_32),
+  DIRECT_BUILTIN (shilo, MIPS_DI_FTYPE_DI_SI, dsp_32),
+  DIRECT_BUILTIN (mthlip, MIPS_DI_FTYPE_DI_SI, dsp_32),
+
+  /* The following are for the MIPS DSP ASE REV 2 (32-bit only).  */
+  DIRECT_BUILTIN (dpa_w_ph, MIPS_DI_FTYPE_DI_V2HI_V2HI, dspr2_32),
+  DIRECT_BUILTIN (dps_w_ph, MIPS_DI_FTYPE_DI_V2HI_V2HI, dspr2_32),
+  DIRECT_BUILTIN (madd, MIPS_DI_FTYPE_DI_SI_SI, dspr2_32),
+  DIRECT_BUILTIN (maddu, MIPS_DI_FTYPE_DI_USI_USI, dspr2_32),
+  DIRECT_BUILTIN (msub, MIPS_DI_FTYPE_DI_SI_SI, dspr2_32),
+  DIRECT_BUILTIN (msubu, MIPS_DI_FTYPE_DI_USI_USI, dspr2_32),
+  DIRECT_BUILTIN (mulsa_w_ph, MIPS_DI_FTYPE_DI_V2HI_V2HI, dspr2_32),
+  DIRECT_BUILTIN (mult, MIPS_DI_FTYPE_SI_SI, dspr2_32),
+  DIRECT_BUILTIN (multu, MIPS_DI_FTYPE_USI_USI, dspr2_32),
+  DIRECT_BUILTIN (dpax_w_ph, MIPS_DI_FTYPE_DI_V2HI_V2HI, dspr2_32),
+  DIRECT_BUILTIN (dpsx_w_ph, MIPS_DI_FTYPE_DI_V2HI_V2HI, dspr2_32),
+  DIRECT_BUILTIN (dpaqx_s_w_ph, MIPS_DI_FTYPE_DI_V2HI_V2HI, dspr2_32),
+  DIRECT_BUILTIN (dpaqx_sa_w_ph, MIPS_DI_FTYPE_DI_V2HI_V2HI, dspr2_32),
+  DIRECT_BUILTIN (dpsqx_s_w_ph, MIPS_DI_FTYPE_DI_V2HI_V2HI, dspr2_32),
+  DIRECT_BUILTIN (dpsqx_sa_w_ph, MIPS_DI_FTYPE_DI_V2HI_V2HI, dspr2_32),
+
+  /* Sundry other built-in functions.  */
+  DIRECT_NO_TARGET_BUILTIN (cache, MIPS_VOID_FTYPE_SI_CVPOINTER, cache)
 };
 
 /* MODE is a vector mode whose elements have type TYPE.  Return the type
@@ -10235,10 +10337,25 @@ mips_builtin_vector_type (tree type, enum machine_mode mode)
   return types[(int) mode];
 }
 
+/* Return a type for 'const volatile void *'.  */
+
+static tree
+mips_build_cvpointer_type (void)
+{
+  static tree cache;
+
+  if (cache == NULL_TREE)
+    cache = build_pointer_type (build_qualified_type
+				(void_type_node,
+				 TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE));
+  return cache;
+}
+
 /* Source-level argument types.  */
 #define MIPS_ATYPE_VOID void_type_node
 #define MIPS_ATYPE_INT integer_type_node
 #define MIPS_ATYPE_POINTER ptr_type_node
+#define MIPS_ATYPE_CVPOINTER mips_build_cvpointer_type ()
 
 /* Standard mode-based argument types.  */
 #define MIPS_ATYPE_SI intSI_type_node
@@ -10298,25 +10415,17 @@ static void
 mips_init_builtins (void)
 {
   const struct mips_builtin_description *d;
-  const struct mips_bdesc_map *m;
-  unsigned int offset;
+  unsigned int i;
 
   /* Iterate through all of the bdesc arrays, initializing all of the
      builtin functions.  */
-  offset = 0;
-  for (m = mips_bdesc_arrays;
-       m < &mips_bdesc_arrays[ARRAY_SIZE (mips_bdesc_arrays)];
-       m++)
+  for (i = 0; i < ARRAY_SIZE (mips_builtins); i++)
     {
-      if ((m->proc == PROCESSOR_MAX || m->proc == mips_arch)
-	  && (m->unsupported_target_flags & target_flags) == 0)
-	for (d = m->bdesc; d < &m->bdesc[m->size]; d++)
-	  if ((d->target_flags & target_flags) == d->target_flags)
-	    add_builtin_function (d->name,
-				  mips_build_function_type (d->function_type),
-				  d - m->bdesc + offset,
-				  BUILT_IN_MD, NULL, NULL);
-      offset += m->size;
+      d = &mips_builtins[i];
+      if (d->avail ())
+	add_builtin_function (d->name,
+			      mips_build_function_type (d->function_type),
+			      i, BUILT_IN_MD, NULL, NULL);
     }
 }
 
@@ -10335,7 +10444,13 @@ mips_prepare_builtin_arg (enum insn_code icode,
   mode = insn_data[icode].operand[opno].mode;
   if (!insn_data[icode].operand[opno].predicate (value, mode))
     {
-      value = copy_to_mode_reg (mode, value);
+      /* Cope with address operands, where MODE is not the mode of
+	 VALUE itself.  */
+      if (GET_MODE (value) == VOIDmode)
+	value = copy_to_mode_reg (mode, value);
+      else
+	value = copy_to_reg (value);
+
       /* Check the predicate again.  */
       if (!insn_data[icode].operand[opno].predicate (value, mode))
 	{
@@ -10561,41 +10676,6 @@ mips_expand_builtin_bposge (enum mips_builtin_type builtin_type, rtx target)
 				       const1_rtx, const0_rtx);
 }
 
-/* EXP is a CALL_EXPR that calls the function described by BDESC.
-   Expand the call and return an rtx for its return value.
-   TARGET, if nonnull, suggests a good place to put this value.  */
-
-static rtx
-mips_expand_builtin_1 (const struct mips_builtin_description *bdesc,
-		       tree exp, rtx target)
-{
-  switch (bdesc->builtin_type)
-    {
-    case MIPS_BUILTIN_DIRECT:
-      return mips_expand_builtin_direct (bdesc->icode, target, exp, true);
-
-    case MIPS_BUILTIN_DIRECT_NO_TARGET:
-      return mips_expand_builtin_direct (bdesc->icode, target, exp, false);
-
-    case MIPS_BUILTIN_MOVT:
-    case MIPS_BUILTIN_MOVF:
-      return mips_expand_builtin_movtf (bdesc->builtin_type, bdesc->icode,
-					bdesc->cond, target, exp);
-
-    case MIPS_BUILTIN_CMP_ANY:
-    case MIPS_BUILTIN_CMP_ALL:
-    case MIPS_BUILTIN_CMP_UPPER:
-    case MIPS_BUILTIN_CMP_LOWER:
-    case MIPS_BUILTIN_CMP_SINGLE:
-      return mips_expand_builtin_compare (bdesc->builtin_type, bdesc->icode,
-					  bdesc->cond, target, exp);
-
-    case MIPS_BUILTIN_BPOSGE32:
-      return mips_expand_builtin_bposge (bdesc->builtin_type, target);
-    }
-  gcc_unreachable ();
-}
-
 /* Implement TARGET_EXPAND_BUILTIN.  */
 
 static rtx
@@ -10604,25 +10684,44 @@ mips_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,
 		     int ignore ATTRIBUTE_UNUSED)
 {
   tree fndecl;
-  unsigned int fcode;
-  const struct mips_bdesc_map *m;
+  unsigned int fcode, avail;
+  const struct mips_builtin_description *d;
 
   fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);
   fcode = DECL_FUNCTION_CODE (fndecl);
+  gcc_assert (fcode < ARRAY_SIZE (mips_builtins));
+  d = &mips_builtins[fcode];
+  avail = d->avail ();
+  gcc_assert (avail != 0);
   if (TARGET_MIPS16)
     {
       error ("built-in function %qs not supported for MIPS16",
 	     IDENTIFIER_POINTER (DECL_NAME (fndecl)));
       return const0_rtx;
     }
-
-  for (m = mips_bdesc_arrays;
-       m < &mips_bdesc_arrays[ARRAY_SIZE (mips_bdesc_arrays)];
-       m++)
+  switch (d->builtin_type)
     {
-      if (fcode < m->size)
-	return mips_expand_builtin_1 (m->bdesc + fcode, exp, target);
-      fcode -= m->size;
+    case MIPS_BUILTIN_DIRECT:
+      return mips_expand_builtin_direct (d->icode, target, exp, true);
+
+    case MIPS_BUILTIN_DIRECT_NO_TARGET:
+      return mips_expand_builtin_direct (d->icode, target, exp, false);
+
+    case MIPS_BUILTIN_MOVT:
+    case MIPS_BUILTIN_MOVF:
+      return mips_expand_builtin_movtf (d->builtin_type, d->icode,
+					d->cond, target, exp);
+
+    case MIPS_BUILTIN_CMP_ANY:
+    case MIPS_BUILTIN_CMP_ALL:
+    case MIPS_BUILTIN_CMP_UPPER:
+    case MIPS_BUILTIN_CMP_LOWER:
+    case MIPS_BUILTIN_CMP_SINGLE:
+      return mips_expand_builtin_compare (d->builtin_type, d->icode,
+					  d->cond, target, exp);
+
+    case MIPS_BUILTIN_BPOSGE32:
+      return mips_expand_builtin_bposge (d->builtin_type, target);
     }
   gcc_unreachable ();
 }
@@ -10896,6 +10995,378 @@ mips16_lay_out_constants (void)
   mips16_emit_constants (pool.first, get_last_insn ());
 }
 
+/* Return true if it is worth r10k_simplify_address's while replacing
+   an address with X.  We are looking for constants, and for addresses
+   at a known offset from the incoming stack pointer.  */
+
+static bool
+r10k_simplified_address_p (rtx x)
+{
+  if (GET_CODE (x) == PLUS && CONST_INT_P (XEXP (x, 1)))
+    x = XEXP (x, 0);
+  return x == virtual_incoming_args_rtx || CONSTANT_P (x);
+}
+
+/* X is an expression that appears in INSN.  Try to use the UD chains
+   to simplify it, returning the simplified form on success and the
+   original form otherwise.  Replace the incoming value of $sp with
+   virtual_incoming_args_rtx (which should never occur in X otherwise).  */
+
+static rtx
+r10k_simplify_address (rtx x, rtx insn)
+{
+  rtx newx, op0, op1, set, def_insn, note;
+  struct df_ref *use, *def;
+  struct df_link *defs;
+
+  newx = NULL_RTX;
+  if (UNARY_P (x))
+    {
+      op0 = r10k_simplify_address (XEXP (x, 0), insn);
+      if (op0 != XEXP (x, 0))
+      newx = simplify_gen_unary (GET_CODE (x), GET_MODE (x),
+                                 op0, GET_MODE (XEXP (x, 0)));
+    }
+  else if (BINARY_P (x))
+    {
+      op0 = r10k_simplify_address (XEXP (x, 0), insn);
+      op1 = r10k_simplify_address (XEXP (x, 1), insn);
+      if (op0 != XEXP (x, 0) || op1 != XEXP (x, 1))
+      newx = simplify_gen_binary (GET_CODE (x), GET_MODE (x), op0, op1);
+    }
+  else if (GET_CODE (x) == LO_SUM)
+    {
+      /* LO_SUMs can be offset from HIGHs, if we know they won't
+       overflow.  See mips_classify_address for the rationale behind
+       the lax check.  */
+      op0 = r10k_simplify_address (XEXP (x, 0), insn);
+      if (GET_CODE (op0) == HIGH)
+      newx = XEXP (x, 1);
+    }
+  else if (REG_P (x))
+    {
+      /* Uses are recorded by regno_reg_rtx, not X itself.  */
+      use = df_find_use (insn, regno_reg_rtx[REGNO (x)]);
+      gcc_assert (use);
+      defs = DF_REF_CHAIN (use);
+
+      /* Require a single definition.  */
+      if (defs && defs->next == NULL)
+      {
+        def = defs->ref;
+        if (DF_REF_IS_ARTIFICIAL (def))
+          {
+            /* Replace the incoming value of $sp with
+               virtual_incoming_args_rtx.  */
+            if (x == stack_pointer_rtx
+                && DF_REF_BB (def) == ENTRY_BLOCK_PTR)
+              newx = virtual_incoming_args_rtx;
+          }
+        else if (dominated_by_p (CDI_DOMINATORS, DF_REF_BB (use),
+                                 DF_REF_BB (def)))
+          {
+            /* Make sure that DEF_INSN is a single set of REG.  */
+            def_insn = DF_REF_INSN (def);
+            if (NONJUMP_INSN_P (def_insn))
+              {
+                set = single_set (def_insn);
+                if (set && rtx_equal_p (SET_DEST (set), x))
+                  {
+                    /* Prefer to use notes, since the def-use chains
+                       are often shorter.  */
+                    note = find_reg_equal_equiv_note (def_insn);
+                    if (note)
+                      newx = XEXP (note, 0);
+                    else
+                      newx = SET_SRC (set);
+                    newx = r10k_simplify_address (newx, def_insn);
+                  }
+              }
+          }
+      }
+    }
+  if (newx && r10k_simplified_address_p (newx))
+    return newx;
+  return x;
+}
+
+/* Return true if ADDRESS is known to be an uncached address
+  on R10K systems.  */
+
+static bool
+r10k_uncached_address_p (unsigned HOST_WIDE_INT address)
+{
+  unsigned HOST_WIDE_INT upper;
+
+  /* Check for KSEG1.  */
+  if (address + 0x60000000 < 0x20000000)
+    return true;
+
+  /* Check for uncached XKPHYS addresses.  */
+  if (Pmode == DImode)
+    {
+      upper = (address >> 40) & 0xf9ffff;
+      if (upper == 0x900000 || upper == 0xb80000)
+      return true;
+    }
+  return false;
+}
+
+/* Return true if we can prove that an access to address X in instruction
+   INSN would be safe from R10K speculation.  This X is a general
+   expression; it might not be a legitimate address.  */
+
+static bool
+r10k_safe_address_p (rtx x, rtx insn)
+{
+  rtx base, offset;
+  HOST_WIDE_INT offset_val;
+
+  x = r10k_simplify_address (x, insn);
+
+  /* Check for references to the stack frame.  It doesn't really matter
+     how much of the frame has been allocated at INSN; -mr10k-cache-barrier
+     allows us to assume that accesses to any part of the eventual frame
+     is safe from speculation at any point in the function.  */
+  mips_split_plus (x, &base, &offset_val);
+  if (base == virtual_incoming_args_rtx
+      && offset_val >= -cfun->machine->frame.total_size
+      && offset_val < cfun->machine->frame.args_size)
+    return true;
+
+  /* Check for uncached addresses.  */
+  if (CONST_INT_P (x))
+    return r10k_uncached_address_p (INTVAL (x));
+
+  /* Check for accesses to a static object.  */
+  split_const (x, &base, &offset);
+  return offset_within_block_p (base, INTVAL (offset));
+}
+
+/* Return true if a MEM with MEM_EXPR EXPR and MEM_OFFSET OFFSET is
+   an in-range access to an automatic variable, or to an object with
+   a link-time-constant address.  */
+
+static bool
+r10k_safe_mem_expr_p (tree expr, rtx offset)
+{
+  if (expr == NULL_TREE
+      || offset == NULL_RTX
+      || !CONST_INT_P (offset)
+      || INTVAL (offset) < 0
+      || INTVAL (offset) >= int_size_in_bytes (TREE_TYPE (expr)))
+    return false;
+
+  while (TREE_CODE (expr) == COMPONENT_REF)
+    {
+      expr = TREE_OPERAND (expr, 0);
+      if (expr == NULL_TREE)
+      return false;
+    }
+
+  return DECL_P (expr);
+}
+
+/* A for_each_rtx callback for which DATA points to the instruction
+   containing *X.  Stop the search if we find a MEM that is not safe
+   from R10K speculation.  */
+
+static int
+r10k_needs_protection_p_1 (rtx *loc, void *data)
+{
+  rtx mem;
+
+  mem = *loc;
+  if (!MEM_P (mem))
+    return 0;
+
+  if (r10k_safe_mem_expr_p (MEM_EXPR (mem), MEM_OFFSET (mem)))
+    return -1;
+
+  if (r10k_safe_address_p (XEXP (mem, 0), (rtx) data))
+    return -1;
+
+  return 1;
+}
+
+/* A note_stores callback for which DATA points to an instruction pointer.
+   If *DATA is nonnull, make it null if it X contains a MEM that is not
+   safe from R10K speculation.  */
+
+static void
+r10k_needs_protection_p_store (rtx x, const_rtx pat ATTRIBUTE_UNUSED,
+                               void *data)
+{
+  rtx *insn_ptr;
+
+  insn_ptr = (rtx *) data;
+  if (*insn_ptr && for_each_rtx (&x, r10k_needs_protection_p_1, *insn_ptr))
+    *insn_ptr = NULL_RTX;
+}
+
+/* A for_each_rtx callback that iterates over the pattern of a CALL_INSN.
+   Return nonzero if the call is not to a declared function.  */
+
+static int
+r10k_needs_protection_p_call (rtx *loc, void *data ATTRIBUTE_UNUSED)
+{
+  rtx x;
+
+  x = *loc;
+  if (!MEM_P (x))
+    return 0;
+
+  x = XEXP (x, 0);
+  if (GET_CODE (x) == SYMBOL_REF && SYMBOL_REF_DECL (x))
+    return -1;
+
+  return 1;
+}
+
+/* Return true if instruction INSN needs to be protected by an R10K
+   cache barrier.  */
+
+static bool
+r10k_needs_protection_p (rtx insn)
+{
+  if (CALL_P (insn))
+    return for_each_rtx (&PATTERN (insn), r10k_needs_protection_p_call, NULL);
+
+  if (mips_r10k_cache_barrier == R10K_CACHE_BARRIER_STORE)
+    {
+      note_stores (PATTERN (insn), r10k_needs_protection_p_store, &insn);
+      return insn == NULL_RTX;
+    }
+
+  return for_each_rtx (&PATTERN (insn), r10k_needs_protection_p_1, insn);
+}
+
+/* Return true if BB is only reached by blocks in PROTECTED_BBS and if every
+   edge is unconditional.  */
+
+static bool
+r10k_protected_bb_p (basic_block bb, sbitmap protected_bbs)
+{
+  edge_iterator ei;
+  edge e;
+
+  FOR_EACH_EDGE (e, ei, bb->preds)
+    if (!single_succ_p (e->src)
+      || !TEST_BIT (protected_bbs, e->src->index)
+      || (e->flags & EDGE_COMPLEX) != 0)
+      return false;
+  return true;
+}
+
+/* Implement -mr10k-cache-barrier= for the current function.  */
+
+static void
+r10k_insert_cache_barriers (void)
+{
+  int *rev_post_order;
+  unsigned int i, n;
+  basic_block bb;
+  sbitmap protected_bbs;
+  rtx insn, end, unprotected_region;
+
+  if (TARGET_MIPS16)
+    {
+      sorry ("%qs does not support MIPS16 code", "-mr10k-cache-barrier");
+      return;
+    }
+
+  /* Restore the BLOCK_FOR_INSN pointers, which are needed by DF.  */
+  compute_bb_for_insn ();
+
+  /* Create def-use chains.  */
+  df_set_flags (DF_EQ_NOTES);
+  df_chain_add_problem (DF_UD_CHAIN);
+  df_analyze ();
+
+  /* Calculate dominators.  */
+  calculate_dominance_info (CDI_DOMINATORS);
+
+  /* Bit X of PROTECTED_BBS is set if the last operation in basic block
+     X is protected by a cache barrier.  */
+  protected_bbs = sbitmap_alloc (last_basic_block);
+  sbitmap_zero (protected_bbs);
+
+  /* Iterate over the basic blocks in reverse post-order.  */
+  rev_post_order = XNEWVEC (int, last_basic_block);
+  n = pre_and_rev_post_order_compute (NULL, rev_post_order, false);
+  for (i = 0; i < n; i++)
+    {
+      bb = BASIC_BLOCK (rev_post_order[i]);
+
+      /* If this block is only reached by unconditional edges, and if the
+       source of every edge is protected, the beginning of the block is
+       also protected.  */
+      if (r10k_protected_bb_p (bb, protected_bbs))
+      unprotected_region = NULL_RTX;
+      else
+      unprotected_region = pc_rtx;
+      end = NEXT_INSN (BB_END (bb));
+
+      /* UNPROTECTED_REGION is:
+
+       - null if we are processing a protected region,
+       - pc_rtx if we are processing an unprotected region but have
+         not yet found the first instruction in it
+       - the first instruction in an unprotected region otherwise.  */
+      for (insn = BB_HEAD (bb); insn != end; insn = NEXT_INSN (insn))
+      {
+        if (unprotected_region && INSN_P (insn))
+          {
+            if (recog_memoized (insn) == CODE_FOR_mips_cache)
+              /* This CACHE instruction protects the following code.  */
+              unprotected_region = NULL_RTX;
+            else
+              {
+                /* See if INSN is the first instruction in this
+                   unprotected region.  */
+                if (unprotected_region == pc_rtx)
+                  unprotected_region = insn;
+
+                /* See if INSN needs to be protected.  If so,
+                   we must insert a cache barrier somewhere between
+                   PREV_INSN (UNPROTECTED_REGION) and INSN.  It isn't
+                   clear which position is better performance-wise,
+                   but as a tie-breaker, we assume that it is better
+                   to allow delay slots to be back-filled where
+                   possible, and that it is better not to insert
+                   barriers in the middle of already-scheduled code.
+                   We therefore insert the barrier at the beginning
+                   of the region.  */
+                if (r10k_needs_protection_p (insn))
+                  {
+                    emit_insn_before (gen_r10k_cache_barrier (),
+                                      unprotected_region);
+                    unprotected_region = NULL_RTX;
+                  }
+              }
+          }
+
+        if (CALL_P (insn))
+          /* The called function is not required to protect the exit path.
+             The code that follows a call is therefore unprotected.  */
+          unprotected_region = pc_rtx;
+      }
+
+      /* Record whether the end of this block is protected.  */
+      if (unprotected_region == NULL_RTX)
+      SET_BIT (protected_bbs, bb->index);
+    }
+  XDELETEVEC (rev_post_order);
+
+  sbitmap_free (protected_bbs);
+
+  free_dominance_info (CDI_DOMINATORS);
+
+  df_finish_pass (false);
+
+  free_bb_for_insn ();
+}
+
 /* A temporary variable used by for_each_rtx callbacks, etc.  */
 static rtx mips_sim_insn;
 
@@ -11542,6 +12013,13 @@ mips_reorg_process_insns (void)
 		 orphaned high-part relocation.  */
 	      if (mips_orphaned_high_part_p (htab, insn))
 		delete_insn (insn);
+	      /* Also delete cache barriers if the last instruction
+		 was an annulled branch.  INSN will not be speculatively
+		 executed.  */
+	      else if (recog_memoized (insn) == CODE_FOR_r10k_cache_barrier
+		       && last_insn
+		       && INSN_ANNULLED_BRANCH_P (SEQ_BEGIN (last_insn)))
+		delete_insn (insn);
 	      else
 		{
 		  mips_avoid_hazard (last_insn, insn, &hilo_delay,
@@ -11561,6 +12039,8 @@ static void
 mips_reorg (void)
 {
   mips16_lay_out_constants ();
+  if (mips_r10k_cache_barrier != R10K_CACHE_BARRIER_NONE)
+    r10k_insert_cache_barriers ();
   if (mips_base_delayed_branch)
     dbr_schedule (get_insns ());
   mips_reorg_process_insns ();
@@ -11979,6 +12459,17 @@ mips_handle_option (size_t code, const char *arg, int value ATTRIBUTE_UNUSED)
 	return false;
       return true;
 
+    case OPT_mr10k_cache_barrier_:
+      if (strcmp (arg, "load-store") == 0)
+	mips_r10k_cache_barrier = R10K_CACHE_BARRIER_LOAD_STORE;
+      else if (strcmp (arg, "store") == 0)
+	mips_r10k_cache_barrier = R10K_CACHE_BARRIER_STORE;
+      else if (strcmp (arg, "none") == 0)
+	mips_r10k_cache_barrier = R10K_CACHE_BARRIER_NONE;
+      else
+	return false;
+      return true;
+
     default:
       return true;
     }
@@ -12216,6 +12707,14 @@ mips_override_options (void)
     warning (0, "the %qs architecture does not support paired-single"
 	     " instructions", mips_arch_info->name);
 
+  if (mips_r10k_cache_barrier != R10K_CACHE_BARRIER_NONE
+      && !TARGET_CACHE_BUILTIN)
+    {
+      error ("%qs requires a target that provides the %qs instruction",
+	     "-mr10k-cache-barrier", "cache");
+      mips_r10k_cache_barrier = R10K_CACHE_BARRIER_NONE;
+    }
+
   /* If TARGET_DSPR2, enable MASK_DSP.  */
   if (TARGET_DSPR2)
     target_flags |= MASK_DSP;
@@ -12274,6 +12773,24 @@ mips_override_options (void)
       && mips_matching_cpu_name_p (mips_arch_info->name, "r4400"))
     target_flags |= MASK_FIX_R4400;
 
+  /* Default to working around R10000 errata only if the processor
+     was selected explicitly.  */
+  if ((target_flags_explicit & MASK_FIX_R10000) == 0
+      && mips_matching_cpu_name_p (mips_arch_info->name, "r10000"))
+    target_flags |= MASK_FIX_R10000;
+
+  /* Make sure that branch-likely instructions available when using
+     -mfix-r10000.  The instructions are not available if either:
+
+	1. -mno-branch-likely was passed.
+	2. The selected ISA does not support branch-likely and
+	   the command line does not include -mbranch-likely.  */
+  if (TARGET_FIX_R10000
+      && ((target_flags_explicit & MASK_BRANCHLIKELY) == 0
+          ? !ISA_HAS_BRANCHLIKELY
+          : !TARGET_BRANCHLIKELY))
+    sorry ("%qs requires branch-likely instructions", "-mfix-r10000");
+
   /* Save base state of options.  */
   mips_base_mips16 = TARGET_MIPS16;
   mips_base_target_flags = target_flags;
diff --git a/gcc/config/mips/mips.h b/gcc/config/mips/mips.h
index 7d94ebdd..8a250094 100644
--- a/gcc/config/mips/mips.h
+++ b/gcc/config/mips/mips.h
@@ -64,6 +64,7 @@ enum processor_type {
   PROCESSOR_R7000,
   PROCESSOR_R8000,
   PROCESSOR_R9000,
+  PROCESSOR_R10000,
   PROCESSOR_SB1,
   PROCESSOR_SB1A,
   PROCESSOR_SR71000,
@@ -520,6 +521,9 @@ enum mips_code_readable_setting {
 									\
       if (mips_abi == ABI_EABI)						\
 	builtin_define ("__mips_eabi");					\
+									\
+      if (TARGET_CACHE_BUILTIN)						\
+	builtin_define ("__GCC_HAVE_BUILTIN_MIPS_CACHE");		\
     }									\
   while (0)
 
@@ -916,6 +920,12 @@ enum mips_code_readable_setting {
    ? TARGET_LLSC && !TARGET_MIPS16	\
    : ISA_HAS_LL_SC)
 
+/* The CACHE instruction is available in non-MIPS16 code.  */
+#define TARGET_CACHE_BUILTIN (mips_isa >= 3)
+
+/* The CACHE instruction is available.  */
+#define ISA_HAS_CACHE (TARGET_CACHE_BUILTIN && !TARGET_MIPS16)
+
 /* Add -G xx support.  */
 
 #undef  SWITCH_TAKES_ARG
@@ -2901,7 +2911,7 @@ while (0)
   "\tbne\t%0,%z2,2f\n"				\
   "\t" OP "\t%@,%3\n"				\
   "\tsc" SUFFIX "\t%@,%1\n"			\
-  "\tbeq\t%@,%.,1b\n"				\
+  "\tbeq%?\t%@,%.,1b\n"				\
   "\tnop\n"					\
   "2:\tsync%-%]%>%)"
 
@@ -2916,7 +2926,7 @@ while (0)
   "1:\tll" SUFFIX "\t%@,%0\n"			\
   "\t" INSN "\t%@,%@,%1\n"			\
   "\tsc" SUFFIX "\t%@,%0\n"			\
-  "\tbeq\t%@,%.,1b\n"				\
+  "\tbeq%?\t%@,%.,1b\n"				\
   "\tnop\n"					\
   "\tsync%-%]%>%)"
 
@@ -2933,7 +2943,7 @@ while (0)
   "1:\tll" SUFFIX "\t%0,%1\n"			\
   "\t" INSN "\t%@,%0,%2\n"			\
   "\tsc" SUFFIX "\t%@,%1\n"			\
-  "\tbeq\t%@,%.,1b\n"				\
+  "\tbeq%?\t%@,%.,1b\n"				\
   "\tnop\n"					\
   "\tsync%-%]%>%)"
 
@@ -2950,7 +2960,7 @@ while (0)
   "1:\tll" SUFFIX "\t%0,%1\n"			\
   "\t" INSN "\t%@,%0,%2\n"			\
   "\tsc" SUFFIX "\t%@,%1\n"			\
-  "\tbeq\t%@,%.,1b\n"				\
+  "\tbeq%?\t%@,%.,1b%~\n"				\
   "\t" INSN "\t%0,%0,%2\n"			\
   "\tsync%-%]%>%)"
 
@@ -2967,7 +2977,7 @@ while (0)
   "\tnor\t%@,%@,%.\n"				\
   "\t" INSN "\t%@,%@,%1\n"			\
   "\tsc" SUFFIX "\t%@,%0\n"			\
-  "\tbeq\t%@,%.,1b\n"				\
+  "\tbeq%?\t%@,%.,1b\n"				\
   "\tnop\n"					\
   "\tsync%-%]%>%)"
 
@@ -2986,7 +2996,7 @@ while (0)
   "\tnor\t%@,%0,%.\n"				\
   "\t" INSN "\t%@,%@,%2\n"			\
   "\tsc" SUFFIX "\t%@,%1\n"			\
-  "\tbeq\t%@,%.,1b\n"				\
+  "\tbeq%?\t%@,%.,1b\n"				\
   "\tnop\n"					\
   "\tsync%-%]%>%)"
 
@@ -3005,7 +3015,7 @@ while (0)
   "\tnor\t%0,%0,%.\n"				\
   "\t" INSN "\t%@,%0,%2\n"			\
   "\tsc" SUFFIX "\t%@,%1\n"			\
-  "\tbeq\t%@,%.,1b\n"				\
+  "\tbeq%?\t%@,%.,1b%~\n"				\
   "\t" INSN "\t%0,%0,%2\n"			\
   "\tsync%-%]%>%)"
 
@@ -3023,7 +3033,7 @@ while (0)
   "1:\tll" SUFFIX "\t%0,%1\n"			\
   "\t" OP "\t%@,%2\n"				\
   "\tsc" SUFFIX "\t%@,%1\n"			\
-  "\tbeq\t%@,%.,1b\n"				\
+  "\tbeq%?\t%@,%.,1b\n"				\
   "\tnop\n"					\
   "\tsync%-%]%>%)"
 
diff --git a/gcc/config/mips/mips.md b/gcc/config/mips/mips.md
index 5076aaf7..ff520a96 100644
--- a/gcc/config/mips/mips.md
+++ b/gcc/config/mips/mips.md
@@ -210,6 +210,9 @@
    (UNSPEC_DPAQX_SA_W_PH	446)
    (UNSPEC_DPSQX_S_W_PH		447)
    (UNSPEC_DPSQX_SA_W_PH	448)
+
+   (UNSPEC_MIPS_CACHE		600)
+   (UNSPEC_R10K_CACHE_BARRIER	601)
   ]
 )
 
@@ -412,7 +415,7 @@
 ;; Attribute describing the processor.  This attribute must match exactly
 ;; with the processor_type enumeration in mips.h.
 (define_attr "cpu"
-  "r3000,4kc,4kp,5kc,5kf,20kc,24kc,24kf2_1,24kf1_1,74kc,74kf2_1,74kf1_1,74kf3_2,m4k,r3900,r6000,r4000,r4100,r4111,r4120,r4130,r4300,r4600,r4650,r5000,r5400,r5500,r7000,r8000,r9000,sb1,sb1a,sr71000"
+  "r3000,4kc,4kp,5kc,5kf,20kc,24kc,24kf2_1,24kf1_1,74kc,74kf2_1,74kf1_1,74kf3_2,m4k,r3900,r6000,r4000,r4100,r4111,r4120,r4130,r4300,r4600,r4650,r5000,r5400,r5500,r7000,r8000,r9000,r10000,sb1,sb1a,sr71000"
   (const (symbol_ref "mips_tune")))
 
 ;; The type of hardware hazard associated with this instruction.
@@ -719,6 +722,7 @@
 (include "6000.md")
 (include "7000.md")
 (include "9000.md")
+(include "10000.md")
 (include "sb1.md")
 (include "sr71k.md")
 (include "generic.md")
@@ -3980,6 +3984,25 @@
    (set_attr "mode"	"SF")
    (set_attr "length"	"4,4,4,*,*")])
 
+;; Cache operations for R4000-style caches.
+(define_insn "mips_cache"
+  [(set (mem:BLK (scratch))
+	(unspec:BLK [(match_operand:SI 0 "const_int_operand")
+		     (match_operand:QI 1 "address_operand" "p")]
+		    UNSPEC_MIPS_CACHE))]
+  "ISA_HAS_CACHE"
+  "cache\t%X0,%a1")
+
+;; Similar, but with the operands hard-coded to an R10K cache barrier
+;; operation.  We keep the pattern distinct so that we can identify
+;; cache operations inserted by -mr10k-cache-barrier=, and so that
+;; the operation is never inserted into a delay slot.
+(define_insn "r10k_cache_barrier"
+  [(set (mem:BLK (scratch))
+	(unspec:BLK [(const_int 0)] UNSPEC_R10K_CACHE_BARRIER))]
+  "ISA_HAS_CACHE"
+  "cache\t0x14,0(%$)"
+  [(set_attr "can_delay" "no")])
 
 ;; 64-bit floating point moves
 
@@ -4426,9 +4449,9 @@
   "GENERATE_LL_SC"
 {
   if (which_alternative == 0)
-    return MIPS_COMPARE_AND_SWAP ("<d>", "li");
+    return mips_output_sync_loop (MIPS_COMPARE_AND_SWAP ("<d>", "li"));
   else
-    return MIPS_COMPARE_AND_SWAP ("<d>", "move");
+    return mips_output_sync_loop (MIPS_COMPARE_AND_SWAP ("<d>", "move"));
 }
   [(set_attr "length" "32")])
 
@@ -4441,9 +4464,9 @@
   "GENERATE_LL_SC"
 {
   if (which_alternative == 0)
-    return MIPS_SYNC_OP ("<d>", "<d>addiu");	
+    return mips_output_sync_loop (MIPS_SYNC_OP ("<d>", "<d>addiu"));
   else
-    return MIPS_SYNC_OP ("<d>", "<d>addu");	
+    return mips_output_sync_loop (MIPS_SYNC_OP ("<d>", "<d>addu"));
 }
   [(set_attr "length" "28")])
 
@@ -4455,7 +4478,7 @@
 	 UNSPEC_SYNC_OLD_OP))]
   "GENERATE_LL_SC"
 {
-  return MIPS_SYNC_OP ("<d>", "<d>subu");	
+  return mips_output_sync_loop (MIPS_SYNC_OP ("<d>", "<d>subu"));
 }
   [(set_attr "length" "28")])
 
@@ -4470,9 +4493,9 @@
   "GENERATE_LL_SC"
 {
   if (which_alternative == 0)
-    return MIPS_SYNC_OLD_OP ("<d>", "<d>addiu");	
+    return mips_output_sync_loop (MIPS_SYNC_OLD_OP ("<d>", "<d>addiu"));
   else
-    return MIPS_SYNC_OLD_OP ("<d>", "<d>addu");	
+    return mips_output_sync_loop (MIPS_SYNC_OLD_OP ("<d>", "<d>addu"));
 }
   [(set_attr "length" "28")])
 
@@ -4486,7 +4509,7 @@
 	 UNSPEC_SYNC_OLD_OP))]
   "GENERATE_LL_SC"
 {
-  return MIPS_SYNC_OLD_OP ("<d>", "<d>subu");	
+  return mips_output_sync_loop (MIPS_SYNC_OLD_OP ("<d>", "<d>subu"));
 }
   [(set_attr "length" "28")])
 
@@ -4501,9 +4524,9 @@
   "GENERATE_LL_SC"
 {
   if (which_alternative == 0)
-    return MIPS_SYNC_NEW_OP ("<d>", "<d>addiu");	
+    return mips_output_sync_loop (MIPS_SYNC_NEW_OP ("<d>", "<d>addiu"));
   else
-    return MIPS_SYNC_NEW_OP ("<d>", "<d>addu");	
+    return mips_output_sync_loop (MIPS_SYNC_NEW_OP ("<d>", "<d>addu"));
 }
   [(set_attr "length" "28")])
 
@@ -4517,7 +4540,7 @@
 	 UNSPEC_SYNC_NEW_OP))]
   "GENERATE_LL_SC"
 {
-  return MIPS_SYNC_NEW_OP ("<d>", "<d>subu");	
+  return mips_output_sync_loop (MIPS_SYNC_NEW_OP ("<d>", "<d>subu"));
 }
   [(set_attr "length" "28")])
 
@@ -4530,9 +4553,9 @@
   "GENERATE_LL_SC"
 {
   if (which_alternative == 0)
-    return MIPS_SYNC_OP ("<d>", "<immediate_insn>");	
+    return mips_output_sync_loop (MIPS_SYNC_OP ("<d>", "<immediate_insn>"));
   else
-    return MIPS_SYNC_OP ("<d>", "<insn>");	
+    return mips_output_sync_loop (MIPS_SYNC_OP ("<d>", "<insn>"));
 }
   [(set_attr "length" "28")])
 
@@ -4547,9 +4570,9 @@
   "GENERATE_LL_SC"
 {
   if (which_alternative == 0)
-    return MIPS_SYNC_OLD_OP ("<d>", "<immediate_insn>");	
+    return mips_output_sync_loop (MIPS_SYNC_OLD_OP ("<d>", "<immediate_insn>"));
   else
-    return MIPS_SYNC_OLD_OP ("<d>", "<insn>");	
+    return mips_output_sync_loop (MIPS_SYNC_OLD_OP ("<d>", "<insn>"));
 }
   [(set_attr "length" "28")])
 
@@ -4564,9 +4587,10 @@
   "GENERATE_LL_SC"
 {
   if (which_alternative == 0)
-    return MIPS_SYNC_NEW_OP ("<d>", "<immediate_insn>");	
+    return (mips_output_sync_loop
+	    (MIPS_SYNC_NEW_OP ("<d>", "<immediate_insn>")));
   else
-    return MIPS_SYNC_NEW_OP ("<d>", "<insn>");	
+    return mips_output_sync_loop (MIPS_SYNC_NEW_OP ("<d>", "<insn>"));
 }
   [(set_attr "length" "28")])
 
@@ -4577,9 +4601,9 @@
   "GENERATE_LL_SC"
 {
   if (which_alternative == 0)
-    return MIPS_SYNC_NAND ("<d>", "andi");	
+    return mips_output_sync_loop (MIPS_SYNC_NAND ("<d>", "andi"));
   else
-    return MIPS_SYNC_NAND ("<d>", "and");	
+    return mips_output_sync_loop (MIPS_SYNC_NAND ("<d>", "and"));
 }
   [(set_attr "length" "32")])
 
@@ -4592,9 +4616,9 @@
   "GENERATE_LL_SC"
 {
   if (which_alternative == 0)
-    return MIPS_SYNC_OLD_NAND ("<d>", "andi");	
+    return mips_output_sync_loop (MIPS_SYNC_OLD_NAND ("<d>", "andi"));
   else
-    return MIPS_SYNC_OLD_NAND ("<d>", "and");	
+    return mips_output_sync_loop (MIPS_SYNC_OLD_NAND ("<d>", "and"));
 }
   [(set_attr "length" "32")])
 
@@ -4607,9 +4631,9 @@
   "GENERATE_LL_SC"
 {
   if (which_alternative == 0)
-    return MIPS_SYNC_NEW_NAND ("<d>", "andi");	
+    return mips_output_sync_loop (MIPS_SYNC_NEW_NAND ("<d>", "andi"));
   else
-    return MIPS_SYNC_NEW_NAND ("<d>", "and");	
+    return mips_output_sync_loop (MIPS_SYNC_NEW_NAND ("<d>", "and"));
 }
   [(set_attr "length" "32")])
 
@@ -4622,9 +4646,9 @@
   "GENERATE_LL_SC"
 {
   if (which_alternative == 0)
-    return MIPS_SYNC_EXCHANGE ("<d>", "li");
+    return mips_output_sync_loop (MIPS_SYNC_EXCHANGE ("<d>", "li"));
   else
-    return MIPS_SYNC_EXCHANGE ("<d>", "move");
+    return mips_output_sync_loop (MIPS_SYNC_EXCHANGE ("<d>", "move"));
 }
   [(set_attr "length" "24")])
 
diff --git a/gcc/config/mips/mips.opt b/gcc/config/mips/mips.opt
index 0af61a21..522447e2 100644
--- a/gcc/config/mips/mips.opt
+++ b/gcc/config/mips/mips.opt
@@ -112,6 +112,10 @@ mfix-r4400
 Target Report Mask(FIX_R4400)
 Work around certain R4400 errata
 
+mfix-r10000
+Target Report Mask(FIX_R10000)
+Work around certain R10000 errata
+
 mfix-sb1
 Target Report Var(TARGET_FIX_SB1)
 Work around errata for early SB-1 revision 2 cores
@@ -232,6 +236,10 @@ mpaired-single
 Target Report Mask(PAIRED_SINGLE_FLOAT)
 Use paired-single floating-point instructions
 
+mr10k-cache-barrier=
+Target Joined RejectNegative
+-mr10k-cache-barrier=SETTING	Specify when r10k cache barriers should be inserted
+
 mshared
 Target Report Var(TARGET_SHARED) Init(1)
 When generating -mabicalls code, make the code suitable for use in shared libraries
diff --git a/gcc/config/netbsd-elf.h b/gcc/config/netbsd-elf.h
index 37f504b8..3fb086d0 100644
--- a/gcc/config/netbsd-elf.h
+++ b/gcc/config/netbsd-elf.h
@@ -82,6 +82,7 @@ along with GCC; see the file COPYING3.  If not see
 #define NETBSD_LINK_SPEC_ELF \
   "%{assert*} %{R*} %{rpath*} \
    %{shared:-shared} \
+   %{symbolic:-Bsymbolic} \
    %{!shared: \
      -dc -dp \
      %{!nostdlib: \
diff --git a/gcc/config/pa/linux-unwind.h b/gcc/config/pa/linux-unwind.h
index c6fda5cd..6f8e7e56 100644
--- a/gcc/config/pa/linux-unwind.h
+++ b/gcc/config/pa/linux-unwind.h
@@ -66,8 +66,8 @@ pa32_fallback_frame_state (struct _Unwind_Context *context,
   int i;
   struct sigcontext *sc;
   struct rt_sigframe {
-    struct siginfo info;
-    struct ucontext uc;
+    siginfo_t info;
+    ucontext_t uc;
   } *frame;
 
   /* rt_sigreturn trampoline:
diff --git a/gcc/config/rs6000/ppc-asm.h b/gcc/config/rs6000/ppc-asm.h
index 74e14836..47547f6a 100644
--- a/gcc/config/rs6000/ppc-asm.h
+++ b/gcc/config/rs6000/ppc-asm.h
@@ -158,7 +158,7 @@ GLUE(.L,name): \
 	.size FUNC_NAME(name),GLUE(.L,name)-FUNC_NAME(name)
 #endif
 
-#if defined __linux__ && !defined __powerpc64__
+#if defined __linux__
 	.section .note.GNU-stack
 	.previous
 #endif
diff --git a/gcc/config/s390/2084.md b/gcc/config/s390/2084.md
index 0c42f187..d3c92722 100644
--- a/gcc/config/s390/2084.md
+++ b/gcc/config/s390/2084.md
@@ -243,7 +243,7 @@
 
 (define_insn_reservation "x_itof" 7 
   (and (eq_attr "cpu" "z990,z9_109")
-       (eq_attr "type" "itof"))
+       (eq_attr "type" "itoftf,itofdf,itofsf"))
   "x_e1_t*3,x-wr-fp") 
 
 (define_bypass 1 "x_fsimpdf" "x_fstoredf")
diff --git a/gcc/config/s390/2097.md b/gcc/config/s390/2097.md
new file mode 100644
index 00000000..f27302e0
--- /dev/null
+++ b/gcc/config/s390/2097.md
@@ -0,0 +1,764 @@
+;; Scheduling description for z10 (cpu 2097).
+;; Copyright (C) 2008 Free Software Foundation, Inc.
+;; Contributed by Wolfgang Gellerich (gellerich@de.ibm.com).
+
+
+; General naming conventions used in this file:
+; - The two pipelines are called S and T, respectively.
+; - A name ending "_S" or "_T" indicates that something happens in
+;   (or belongs to) this pipeline.
+; - A name ending "_ANY" indicates that something happens in (or belongs
+;   to) either of the two pipelines.
+; - A name ending "_BOTH" indicates that something happens in (or belongs
+;   to) both pipelines.
+
+
+;; Automaton and components.
+
+(define_automaton "z10_cpu")
+
+(define_cpu_unit "z10_e1_S, z10_e1_T"  "z10_cpu")
+(define_reservation "z10_e1_ANY" "(z10_e1_S | z10_e1_T)")
+(define_reservation "z10_e1_BOTH" "(z10_e1_S + z10_e1_T)")
+
+
+; Both pipelines can execute a branch instruction, and branch
+; instructions can be grouped with all other groupable instructions
+; but not with a second branch instruction.
+
+(define_cpu_unit "z10_branch_ANY"  "z10_cpu")
+
+(define_insn_reservation "z10_branch" 4
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "branch"))
+  "z10_branch_ANY + z10_e1_ANY, z10_Gate_ANY")
+
+
+; Z10 operand and result forwarding.
+
+; Instructions marked with the attributes as z10_fwd or z10_fr can
+; forward a value they load from one of their operants into a register
+; if the instruction in the second pipeline reads the same register.
+; The second operation must be superscalar.  Instructions marked as
+; z10_rec or z10_fr can receive a value they read from a register is
+; this register gets updated by an instruction in the first pipeline.
+; The first instruction must be superscalar.
+
+
+; Forwarding from z10_fwd and z10_fr to z10_super.
+
+(define_bypass 0 "z10_la_fwd, z10_la_fwd_A1, z10_larl_fwd, z10_larl_fwd_A3, \
+                  z10_load_fwd, z10_load_fwd_A3, \
+                  z10_other_fwd, z10_other_fwd_A1, z10_other_fwd_A3, \
+	 	  z10_other_fr, z10_other_fr_A3, z10_other_fr_E1, \
+                  z10_other_fwd_E1, z10_lr_fr, z10_lr_fr_E1, \
+                  z10_int_fwd, z10_int_fwd_A1, z10_int_fwd_A3, \
+                  z10_int_fwd_E1, z10_int_fr, z10_int_fr_E1, \
+                  z10_int_fr_A3"
+                  "z10_other_super, z10_other_super_c_E1, z10_other_super_E1, \
+                  z10_int_super, z10_int_super_E1, \
+                  z10_lr, z10_store_super")
+
+
+; Forwarding from z10_super to frz10_ and z10_rec.
+
+(define_bypass 0 "z10_other_super, z10_other_super_E1, z10_other_super_c_E1, \
+                  z10_int_super, z10_int_super_E1, \
+                  z10_larl_super_E1, z10_larl_super, \
+                  z10_store_super"
+                  "z10_int_fr, z10_int_fr_E1, z10_int_fr_A3, \
+                  z10_other_fr, z10_other_fr_A3, z10_lr_fr, z10_lr_fr_E1, \
+                  z10_other_fr_E1, z10_store_rec")
+
+
+; Forwarding from z10_fwd and z10_fr to z10_rec and z10_fr.
+
+(define_bypass 0 "z10_la_fwd, z10_la_fwd_A1, z10_larl_fwd, z10_larl_fwd_A3, \
+                  z10_load_fwd, z10_load_fwd_A3, \
+                  z10_other_fwd, z10_other_fwd_A1, z10_other_fwd_A3, \
+                  z10_other_fr, z10_other_fr_A3, z10_other_fr_E1, \
+                  z10_other_fwd_E1, \
+                  z10_lr_fr, z10_lr_fr_E1, \
+                  z10_int_fwd, z10_int_fwd_A1, z10_int_fwd_A3, \
+                  z10_int_fwd_E1, z10_int_fr, z10_int_fr_E1, \
+                  z10_int_fr_A3"
+                  "z10_int_fr, z10_int_fr_E1, z10_int_fr_A3, \
+                  z10_other_fr, z10_other_fr_A3, z10_lr_fr, z10_lr_fr_E1, \
+                  z10_other_fr_E1, z10_store_rec")
+
+
+;
+; Simple insns
+;
+
+; Here is the cycle diagram for FXU-executed instructions:
+; ... A1 A2 A3 E1 P1 P2 P3 R0 ...
+;        ^              ^  ^
+;        |              |  updated GPR is available
+;        |              write to GPR
+;        instruction reads GPR during this cycle
+
+
+; Variants of z10_int follow.
+
+(define_insn_reservation "z10_int" 6
+  (and (and (eq_attr "cpu" "z10")
+            (eq_attr "type" "integer"))
+       (and (eq_attr "atype" "reg")
+             (and (and (eq_attr "z10prop" "!z10_super")
+                       (eq_attr "z10prop" "!z10_super_c"))
+                  (and (and (and (and (eq_attr "z10prop" "!z10_super_E1")
+                                      (eq_attr "z10prop" "!z10_super_c_E1"))
+                                  (eq_attr "z10prop" "!z10_fwd"))
+                             (and (eq_attr "z10prop" "!z10_fwd_A1")
+                                  (eq_attr "z10prop" "!z10_fwd_A3")))
+                        (and (and (eq_attr "z10prop" "!z10_fwd_E1")
+                                  (eq_attr "z10prop" "!z10_fr"))
+                             (and (eq_attr "z10prop" "!z10_fr_E1")
+                                  (eq_attr "z10prop" "!z10_fr_A3")))))))
+  "z10_e1_ANY, z10_Gate_ANY")
+
+(define_insn_reservation "z10_int_super" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "integer")
+            (and (eq_attr "atype" "reg")
+                 (ior (eq_attr "z10prop" "z10_super")
+                      (eq_attr "z10prop" "z10_super_c")))))
+  "z10_e1_ANY, z10_Gate_ANY")
+
+(define_insn_reservation "z10_int_super_E1" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "integer")
+            (and (eq_attr "atype" "reg")
+                 (ior (eq_attr "z10prop" "z10_super_E1")
+                      (eq_attr "z10prop" "z10_super_c_E1")))))
+  "z10_e1_ANY, z10_Gate_ANY")
+
+(define_insn_reservation "z10_int_fwd" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "integer")
+            (and (eq_attr "atype" "reg")
+                 (eq_attr "z10prop" "z10_fwd"))))
+  "z10_e1_ANY, z10_Gate_ANY")
+
+(define_insn_reservation "z10_int_fwd_A1" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "integer")
+            (and (eq_attr "atype" "reg")
+                 (eq_attr "z10prop" "z10_fwd_A1"))))
+  "z10_e1_ANY, z10_Gate_ANY")
+
+(define_insn_reservation "z10_int_fwd_A3" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "integer")
+            (and (eq_attr "atype" "reg")
+                 (eq_attr "z10prop" "z10_fwd_A3"))))
+  "z10_e1_ANY, z10_Gate_ANY")
+
+(define_insn_reservation "z10_int_fwd_E1" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "integer")
+            (and (eq_attr "atype" "reg")
+                 (eq_attr "z10prop" "z10_fwd_E1"))))
+  "z10_e1_ANY, z10_Gate_ANY")
+
+(define_insn_reservation "z10_int_fr" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "integer")
+            (and (eq_attr "atype" "reg")
+                 (eq_attr "z10prop" "z10_fr"))))
+  "z10_e1_ANY, z10_Gate_ANY")
+
+(define_insn_reservation "z10_int_fr_E1" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "integer")
+            (and (eq_attr "atype" "reg")
+                 (eq_attr "z10prop" "z10_fr_E1"))))
+  "z10_e1_ANY, z10_Gate_ANY")
+
+(define_insn_reservation "z10_int_fr_A3" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "integer")
+            (and (eq_attr "atype" "reg")
+                 (eq_attr "z10prop" "z10_fr_A3"))))
+  "z10_e1_ANY, z10_Gate_ANY")
+
+; END of z10_int variants
+
+
+(define_insn_reservation "z10_agen" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "integer")
+            (eq_attr "atype" "agen")))
+  "z10_e1_ANY, z10_Gate_ANY")
+
+
+(define_insn_reservation "z10_lr" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "lr")
+            (and (eq_attr "z10prop" "!z10_fr")
+                 (eq_attr "z10prop" "!z10_fr_E1"))))
+  "z10_e1_ANY, z10_Gate_ANY")
+
+(define_insn_reservation "z10_lr_fr" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "lr")
+            (eq_attr "z10prop" "z10_fr")))
+  "z10_e1_ANY, z10_Gate_ANY")
+;  "z10_e1_ANY")
+
+(define_insn_reservation "z10_lr_fr_E1" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "lr")
+            (eq_attr "z10prop" "z10_fr_E1")))
+  "z10_e1_ANY, z10_Gate_ANY")
+;  "z10_e1_ANY")
+
+
+(define_insn_reservation "z10_la" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "la")
+            (and (eq_attr "z10prop" "!z10_fwd")
+                 (eq_attr "z10prop" "!z10_fwd_A1"))))
+  "z10_e1_ANY, z10_Gate_ANY")
+
+(define_insn_reservation "z10_la_fwd" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "la")
+            (eq_attr "z10prop" "z10_fwd")))
+  "z10_e1_ANY, z10_Gate_ANY")
+;  "z10_e1_ANY")
+
+(define_insn_reservation "z10_la_fwd_A1" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "la")
+            (eq_attr "z10prop" "z10_fwd_A1")))
+  "z10_e1_ANY, z10_Gate_ANY")
+;  "z10_e1_ANY")
+
+
+; larl-type instructions
+
+(define_insn_reservation "z10_larl" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "larl")
+                 (and (eq_attr "z10prop" "!z10_super_A1")
+                      (and (eq_attr "z10prop" "!z10_fwd")
+                           (and (eq_attr "z10prop" "!z10_fwd_A3")
+                                (and (eq_attr "z10prop" "!z10_super")
+                                     (eq_attr "z10prop" "!z10_super_c"))
+                                (and (eq_attr "z10prop" "!z10_super_E1")
+                                     (eq_attr "z10prop" "!z10_super_c_E1")))))))
+  "z10_e1_ANY, z10_Gate_ANY")
+
+(define_insn_reservation "z10_larl_super" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "larl")
+            (and (eq_attr "z10prop" "z10_super")
+                 (eq_attr "z10prop" "z10_super_c"))))
+  "z10_e1_ANY, z10_Gate_ANY")
+
+(define_insn_reservation "z10_larl_fwd" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "larl")
+            (eq_attr "z10prop" "z10_fwd")))
+  "z10_e1_ANY, z10_Gate_ANY")
+
+(define_insn_reservation "z10_larl_fwd_A3" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "larl")
+            (eq_attr "z10prop" "z10_fwd_A3")))
+  "z10_e1_ANY, z10_Gate_ANY")
+
+
+(define_insn_reservation "z10_larl_A1" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "larl")
+            (eq_attr "z10prop" "z10_super_A1")))
+  "z10_e1_ANY, z10_Gate_ANY")
+;  "z10_e1_ANY")
+
+(define_insn_reservation "z10_larl_super_E1" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "larl")
+            (ior (eq_attr "z10prop" "z10_super_E1")
+                 (eq_attr "z10prop" "z10_super_c_E1"))))
+  "z10_e1_ANY, z10_Gate_ANY")
+;  "z10_e1_ANY")
+
+
+(define_insn_reservation "z10_load" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "load")
+            (and (eq_attr "z10prop" "!z10_fwd")
+                 (eq_attr "z10prop" "!z10_fwd_A3"))))
+  "z10_e1_ANY, z10_Gate_ANY")
+
+(define_insn_reservation "z10_load_fwd" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "load")
+            (eq_attr "z10prop" "z10_fwd")))
+  "z10_e1_ANY, z10_Gate_ANY")
+;  "z10_e1_ANY")
+
+(define_insn_reservation "z10_load_fwd_A3" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "load")
+            (eq_attr "z10prop" "z10_fwd_A3")))
+  "z10_e1_ANY, z10_Gate_ANY")
+;  "z10_e1_ANY")
+
+(define_insn_reservation "z10_store" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "store")
+            (and (eq_attr "z10prop" "!z10_rec")
+                 (and (eq_attr "z10prop" "!z10_super")
+                      (eq_attr "z10prop" "!z10_super_c")))))
+  "z10_e1_ANY, z10_Gate_ANY")
+
+(define_insn_reservation "z10_store_super" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "store")
+            (ior (eq_attr "z10prop" "z10_super")
+                 (eq_attr "z10prop" "z10_super_c"))))
+  "z10_e1_ANY, z10_Gate_ANY")
+
+(define_insn_reservation "z10_store_rec" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "store")
+            (eq_attr "z10prop" "z10_rec")))
+  "z10_e1_ANY, z10_Gate_ANY")
+
+; The default_latency is chosen to drain off the pipeline.
+(define_insn_reservation "z10_call" 14
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "jsr"))
+  "z10_e1_BOTH*4, z10_Gate_BOTH")
+
+; The default latency is for worst case.  CS and CSG take one
+; cycle only (i.e. latency would be 6).
+(define_insn_reservation "z10_sem" 9
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "sem"))
+  "z10_e1_BOTH*5, z10_Gate_ANY")
+
+(define_insn_reservation "z10_cs" 6
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "cs"))
+  "z10_e1_BOTH, z10_Gate_BOTH")
+
+(define_insn_reservation "z10_vs" 6
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "vs"))
+  "z10_e1_BOTH*4, z10_Gate_BOTH")
+
+; Load and store multiple. Actual number of cycles
+; in unknown at compile.time.
+(define_insn_reservation "z10_stm" 10
+  (and (eq_attr "cpu" "z10")
+       (ior (eq_attr "type" "stm")
+            (eq_attr "type" "lm")))
+  "z10_e1_BOTH*4, z10_Gate_BOTH")
+
+
+; Subsets of z10_other follow.
+
+(define_insn_reservation "z10_other" 6
+  (and (and (eq_attr "cpu" "z10")
+            (eq_attr "type" "other"))
+       (and (and (eq_attr "z10prop" "!z10_fwd")
+                 (eq_attr "z10prop" "!z10_fwd_A1"))
+            (and (and  (and (eq_attr "z10prop" "!z10_fr_A3")
+                            (eq_attr "z10prop" "!z10_fwd_A3"))
+                       (and (eq_attr "z10prop" "!z10_fr")
+                            (eq_attr "z10prop" "!z10_fr_E1")))
+                 (and  (and (and (eq_attr "z10prop" "!z10_super")
+                                  (eq_attr "z10prop" "!z10_super_c"))
+                            (eq_attr "z10prop" "!z10_super_c_E1"))
+                       (and (eq_attr "z10prop" "!z10_super_E1")
+                            (eq_attr "z10prop" "!z10_fwd_E1"))))))
+  "z10_e1_BOTH, z10_Gate_BOTH")
+
+(define_insn_reservation "z10_other_fr_E1" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "other")
+            (eq_attr "z10prop" "z10_fr_E1")))
+  "z10_e1_BOTH, z10_Gate_BOTH")
+
+(define_insn_reservation "z10_other_super_c_E1" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "other")
+            (eq_attr "z10prop" "z10_super_c_E1")))
+  "z10_e1_BOTH, z10_Gate_BOTH")
+
+(define_insn_reservation "z10_other_super_E1" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "other")
+            (eq_attr "z10prop" "z10_super_E1")))
+  "z10_e1_BOTH, z10_Gate_BOTH")
+
+(define_insn_reservation "z10_other_fwd_E1" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "other")
+            (eq_attr "z10prop" "z10_fwd_E1")))
+  "z10_e1_BOTH, z10_Gate_BOTH")
+
+(define_insn_reservation "z10_other_fwd" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "other")
+            (eq_attr "z10prop" "z10_fwd")))
+  "z10_e1_BOTH, z10_Gate_BOTH")
+
+(define_insn_reservation "z10_other_fwd_A3" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "other")
+            (eq_attr "z10prop" "z10_fwd_A3")))
+  "z10_e1_BOTH, z10_Gate_BOTH")
+
+(define_insn_reservation "z10_other_fwd_A1" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "other")
+            (eq_attr "z10prop" "z10_fwd_A1")))
+  "z10_e1_BOTH, z10_Gate_BOTH")
+
+(define_insn_reservation "z10_other_fr" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "other")
+            (eq_attr "z10prop" "z10_fr")))
+  "z10_e1_BOTH, z10_Gate_BOTH")
+
+(define_insn_reservation "z10_other_fr_A3" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "other")
+            (eq_attr "z10prop" "z10_fr_A3")))
+  "z10_e1_BOTH, z10_Gate_BOTH")
+
+(define_insn_reservation "z10_other_super" 6
+  (and (eq_attr "cpu" "z10")
+       (and (eq_attr "type" "other")
+            (ior (eq_attr "z10prop" "z10_super")
+                 (eq_attr "z10prop" "z10_super_c"))))
+  "z10_e1_BOTH, z10_Gate_BOTH")
+
+; END of z10_other subsets.
+
+
+;
+; Floating point insns
+;
+
+; Z10 executes the following integer operations in the BFU pipeline.
+
+(define_insn_reservation "z10_mul_sidi" 12
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "imulsi,imuldi,imulhi"))
+  "z10_e1_BOTH, z10_Gate_FP")
+
+; Some variants take fewer cycles, but that is not relevant here.
+(define_insn_reservation "z10_div" 162
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "idiv"))
+  "z10_e1_BOTH*4, z10_Gate_FP")
+
+
+; BFP multiplication and general instructions
+
+(define_insn_reservation "z10_fsimpdf" 12
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "fsimpdf,fmuldf"))
+  "z10_e1_BOTH, z10_Gate_FP")
+; Wg "z10_e1_T, z10_Gate_FP")
+
+(define_insn_reservation "z10_fsimpsf" 12
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "fsimpsf,fmulsf"))
+  "z10_e1_BOTH, z10_Gate_FP")
+; Wg "z10_e1_T, z10_Gate_FP")
+
+(define_insn_reservation "z10_fmultf" 52
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "fmultf"))
+  "z10_e1_BOTH*4, z10_Gate_FP")
+; Wg  "z10_e1_T*4, z10_Gate_FP")
+
+(define_insn_reservation "z10_fsimptf" 14
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "fsimptf"))
+  "z10_e1_BOTH*2, z10_Gate_FP")
+; Wg  "z10_e1_T*2, z10_Gate_FP")
+
+
+; BFP division
+
+(define_insn_reservation "z10_fdivtf" 113
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "fdivtf"))
+  "z10_e1_T*4, z10_Gate_FP")
+
+(define_insn_reservation "z10_fdivdf" 41
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "fdivdf"))
+  "z10_e1_T*4, z10_Gate_FP")
+
+(define_insn_reservation "z10_fdivsf" 34
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "fdivsf"))
+  "z10_e1_T*4, z10_Gate_FP")
+
+
+; BFP sqrt
+
+(define_insn_reservation "z10_fsqrtsf" 41
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "fsqrtsf"))
+  "z10_e1_T*4, z10_Gate_FP")
+
+(define_insn_reservation "z10_fsqrtdf" 54
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "fsqrtdf"))
+  "z10_e1_T*4, z10_Gate_FP")
+
+(define_insn_reservation "z10_fsqrtf" 122
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "fsqrttf"))
+  "z10_e1_T*4, z10_Gate_FP")
+
+
+; BFP load and store
+
+(define_insn_reservation "z10_floadtf" 12
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "floadtf"))
+  "z10_e1_T, z10_Gate_FP")
+
+(define_insn_reservation "z10_floaddf" 12
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "floaddf"))
+  "z10_e1_T, z10_Gate_FP")
+
+(define_insn_reservation "z10_floadsf" 12
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "floadsf"))
+  "z10_e1_T, z10_Gate_FP")
+
+(define_insn_reservation "z10_fstoredf" 12
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "fstoredf,fstoredd"))
+  "z10_e1_T, z10_Gate_FP")
+
+(define_insn_reservation "z10_fstoresf" 12
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "fstoresf,fstoresd"))
+  "z10_e1_T, z10_Gate_FP")
+
+
+; BFP truncate
+(define_insn_reservation "z10_ftrunctf" 12
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "ftrunctf"))
+  "z10_e1_T, z10_Gate_FP")
+
+(define_insn_reservation "z10_ftruncdf" 16
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "ftruncdf"))
+  "z10_e1_T, z10_Gate_FP")
+
+
+; Conversion between BFP and int.
+(define_insn_reservation "z10_ftoi" 13
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "ftoi"))
+  "z10_e1_T, z10_Gate_FP")
+
+(define_insn_reservation "z10_itoftf" 14
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "itoftf"))
+  "z10_e1_T*2, z10_Gate_FP")
+
+(define_insn_reservation "z10_itofsfdf" 12
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "itofdf,itofsf"))
+  "z10_e1_T, z10_Gate_FP")
+
+
+
+; BFP-related bypasses.  There is no bypass for extended mode.
+(define_bypass 1 "z10_fsimpdf" "z10_fstoredf")
+(define_bypass 1 "z10_fsimpsf" "z10_fstoresf")
+(define_bypass 1 "z10_floaddf" "z10_fsimpdf, z10_fstoredf, z10_floaddf")
+(define_bypass 1 "z10_floadsf" "z10_fsimpsf, z10_fstoresf, z10_floadsf")
+
+
+;
+; insn_reservations for DFP instructions.
+;
+
+; Exact number of cycles is not known at compile-time.
+(define_insn_reservation "z10_fdivddtd" 40
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "fdivdd,fdivtd"))
+  "z10_e1_BOTH,z10_Gate_DFU")
+
+(define_insn_reservation "z10_ftruncsd" 38
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "ftruncsd"))
+  "z10_e1_BOTH*4,z10_Gate_DFU")
+
+(define_insn_reservation "z10_ftruncdd" 340
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "ftruncsd"))
+  "z10_e1_BOTH*4,z10_Gate_DFU")
+
+(define_insn_reservation "z10_floaddd" 12
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "floaddd"))
+  "z10_e1_BOTH,z10_Gate_DFU")
+
+(define_insn_reservation "z10_floadsd" 12
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "floadsd"))
+  "z10_e1_BOTH,z10_Gate_DFU")
+
+; Exact number of cycles is not known at compile-time.
+(define_insn_reservation "z10_fmulddtd" 35
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "fmuldd,fmultd"))
+  "z10_e1_BOTH,z10_Gate_DFU")
+
+(define_insn_reservation "z10_fsimpdd" 17
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "fsimpdd"))
+  "z10_e1_BOTH,z10_Gate_DFU")
+
+(define_insn_reservation "z10_fsimpsd" 17
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "fsimpsd"))
+  "z10_e1_BOTH,z10_Gate_DFU")
+
+(define_insn_reservation "z10_fsimptd" 18
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "fsimptd"))
+  "z10_e1_BOTH,z10_Gate_DFU")
+
+(define_insn_reservation "z10_itofdd" 36
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "itofdd"))
+  "z10_e1_BOTH*3,z10_Gate_DFU")
+
+(define_insn_reservation "z10_itoftd" 49
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "itoftd"))
+  "z10_e1_BOTH*3,z10_Gate_DFU")
+
+; Exact number of cycles is not known at compile-time.
+(define_insn_reservation "z10_ftoidfp" 30
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "ftoidfp"))
+  "z10_e1_BOTH*3,z10_Gate_DFU")
+
+
+;
+; Address-related bypasses
+;
+
+; Here is the cycle diagram for Address-related bypasses:
+; ... G1 G2 G3 A0 A1 A2 A3 E1 P1 P2 P3 R0 ...
+;         ^  ^    ^     ^  ^
+;         |  |    |     |  E1-type bypasses provide the new addr AFTER this cycle
+;         |  |    |     A3-type bypasses provide the new addr AFTER this cycle
+;         |  |    A1-type bypasses provide the new addr AFTER this cycle
+;         |  AGI resolution, actual USE of address is DURING this cycle
+;         AGI detection
+
+(define_bypass 3 "z10_larl_A1, z10_la_fwd_A1, z10_other_fwd_A1, \
+                  z10_int_fwd_A1"
+                 "z10_agen, z10_la, z10_branch, z10_call, z10_load, \
+                  z10_store, \
+                  z10_cs, z10_stm, z10_other"
+	         "s390_agen_dep_p")
+
+
+(define_bypass 5 "z10_larl_fwd_A3, z10_load_fwd_A3, z10_other_fwd_A3, \
+                  z10_other_fr_A3, z10_int_fwd_A3, z10_int_fr_A3"
+                 "z10_agen, z10_la, z10_branch, z10_call, z10_load, \
+                  z10_store, \
+                  z10_cs, z10_stm, z10_other"
+	         "s390_agen_dep_p")
+
+(define_bypass 6 "z10_other_fr_E1, z10_other_super_c_E1, z10_other_super_E1, \
+                  z10_other_fwd_E1, \
+                  z10_lr_fr_E1, z10_larl_super_E1, \
+                  z10_int_super_E1, z10_int_fwd_E1, z10_int_fr_E1"
+                 "z10_agen, z10_la, z10_branch, z10_call, z10_load, \
+                  z10_store, \
+                  z10_cs, z10_stm, z10_other"
+ 	         "s390_agen_dep_p")
+
+
+
+;
+; Try to avoid transitions between DFU-, BFU- and FXU-executed instructions as there is a
+; dispatch delay required.
+;
+
+
+; Declaration for some pseudo-pipeline stages that reflect the
+; dispatch gap when issueing an INT/FXU/BFU-executed instruction after
+; an instruction executed by a different unit has been executed.  The
+; approach is that we pretend a pipelined execution of BFU operations
+; with as many stages as the gap is long and request that none of
+; these stages is busy when issueing a FXU- or DFU-executed
+; instruction.  Similar for FXU- and DFU-executed instructions.
+
+; Declaration for FPU stages.
+(define_cpu_unit "z10_f0, z10_f1, z10_f2, z10_f3, z10_f4, z10_f5, z10_f6, \
+                  z10_f7, z10_f8, z10_f9, z10_f10, z10_f11, z10_f12" "z10_cpu")
+(define_reservation "z10_FP_PP" "z10_f0, z10_f1, z10_f2, z10_f3, z10_f4, \
+                  z10_f5, z10_f6, z10_f7, z10_f8, z10_f9, z10_f10, z10_f11, \
+                  z10_f12")
+
+; Declaration for FXU stages.
+(define_cpu_unit "z10_S1, z10_S2, z10_S3, z10_S4, z10_S5, z10_S6"  "z10_cpu")
+(define_cpu_unit "z10_T1, z10_T2, z10_T3, z10_T4, z10_T5, z10_T6"  "z10_cpu")
+(define_reservation "z10_INT_PP" "z10_S1 | z10_T1, z10_S2 | z10_T2, z10_S3 \
+                                  | z10_T3, z10_S4 | z10_T4, z10_S5 | \
+                                  z10_T5, z10_S6 | z10_T6")
+
+; Declaration for DFU stages.
+(define_cpu_unit "z10_d0, z10_d1, z10_d2, z10_d3, z10_d4, z10_d5, z10_d6"
+                 "z10_cpu")
+(define_reservation "z10_DFU_PP" "z10_d0, z10_d1, z10_d2, z10_d3, z10_d4, \
+                                 z10_d5, z10_d6")
+
+
+; Pseudo-units representing whether the respective unit is available
+; in the sense that using it does not cause a dispatch delay.
+
+(define_cpu_unit "z10_S_avail, z10_T_avail, z10_FP_avail, z10_DFU_avail"
+                 "z10_cpu")
+
+(absence_set "z10_FP_avail"
+             "z10_S1, z10_S2, z10_S3, z10_S4, z10_S5, z10_S6, z10_T1, z10_T2, z10_T3, z10_T4, \
+              z10_T5, z10_T6, \
+              z10_d0, z10_d1, z10_d2, z10_d3, z10_d4, z10_d5, z10_d6")
+
+(absence_set "z10_S_avail,z10_T_avail"
+             "z10_f0, z10_f1, z10_f2, z10_f3, z10_f4, z10_f5, z10_f6, z10_f7, \
+              z10_f8, z10_f9, z10_f10, z10_f11, z10_f12, \
+              z10_d0, z10_d1, z10_d2, z10_d3, z10_d4, z10_d5, z10_d6")
+
+(absence_set "z10_DFU_avail"
+             "z10_S1, z10_S2, z10_S3, z10_S4, z10_S5, z10_S6, z10_T1, z10_T2, z10_T3, z10_T4, \
+              z10_T5, z10_T6, \
+              z10_f0, z10_f1, z10_f2, z10_f3, z10_f4, z10_f5, z10_f6, z10_f7, \
+              z10_f8, z10_f9, z10_f10, z10_f11, z10_f12")
+
+
+; Pseudo-units to be used in insn_reservations.
+
+(define_reservation "z10_Gate_ANY" "((z10_S_avail | z10_T_avail), z10_INT_PP)")
+(define_reservation "z10_Gate_BOTH" "((z10_S_avail + z10_T_avail), z10_INT_PP)")
+
+(define_reservation "z10_Gate_FP" "z10_FP_avail, z10_FP_PP")
+
+(define_reservation "z10_Gate_DFU" "z10_DFU_avail, z10_DFU_PP")
diff --git a/gcc/config/s390/constraints.md b/gcc/config/s390/constraints.md
index 92fd3254..41a94fbf 100644
--- a/gcc/config/s390/constraints.md
+++ b/gcc/config/s390/constraints.md
@@ -24,10 +24,14 @@
 ;; Special constraints for s/390 machine description:
 ;;
 ;;    a -- Any address register from 1 to 15.
+;;    b -- Memory operand whose address is a symbol reference or a symbol
+;;         reference + constant which can be proven to be naturally aligned.
 ;;    c -- Condition code register 33.
 ;;    d -- Any register from 0 to 15.
 ;;    f -- Floating point registers.
 ;;    t -- Access registers 36 and 37.
+;;    C -- A signed 8-bit constant (-128..127)
+;;    D -- An unsigned 16-bit constant (0..65535)
 ;;    G -- Const double zero operand
 ;;    I -- An 8-bit constant (0..255).
 ;;    J -- A 12-bit constant (0..4095).
@@ -102,6 +106,19 @@
 ;;  General constraints for constants.
 ;;
 
+(define_constraint "C"
+  "@internal
+   An 8-bit signed immediate constant (-128..127)"
+  (and (match_code "const_int")
+       (match_test "ival >= -128 && ival <= 127")))
+
+
+(define_constraint "D"
+  "An unsigned 16-bit constant (0..65535)"
+  (and (match_code "const_int")
+       (match_test "ival >= 0 && ival <= 65535")))
+
+
 (define_constraint "G"
   "@internal
    Const double zero operand"
@@ -127,7 +144,6 @@
        (match_test "ival >= -32768 && ival <= 32767")))
 
 
-
 (define_constraint "L"
   "Value appropriate as displacement.
       (0..4095) for short displacement
@@ -355,7 +371,6 @@
   (match_test "s390_mem_constraint (\"Q\", op)"))
 
 
-
 (define_memory_constraint "R"
   "Memory reference with index register and short displacement"
   (match_test "s390_mem_constraint (\"R\", op)"))
@@ -371,6 +386,27 @@
   (match_test "s390_mem_constraint (\"T\", op)"))
 
 
+(define_memory_constraint "b"
+  "Memory reference whose address is a naturally aligned symbol reference."
+  (match_test "MEM_P (op)
+               && s390_check_symref_alignment (XEXP (op, 0),
+                                               GET_MODE_SIZE (GET_MODE (op)))"))
+
+(define_memory_constraint "e"
+  "Matches all memory references available on the current architecture
+level.  This constraint will never be used and using it in an inline
+assembly is *always* a bug since there is no instruction accepting all
+those addresses.  It just serves as a placeholder for a generic memory
+constraint."
+  (match_test "legitimate_address_p (GET_MODE (op), op, 1)"))
+
+; This defines 'm' as normal memory constraint.  This is only possible
+; since the standard memory constraint is re-defined in s390.h using
+; the TARGET_MEM_CONSTRAINT macro.
+(define_memory_constraint "m"
+  "Matches the most general memory address for pre-z10 machines."
+  (match_test "s390_mem_constraint (\"R\", op)
+               || s390_mem_constraint (\"T\", op)"))
 
 (define_memory_constraint "AQ"
   "@internal 
@@ -425,7 +461,6 @@
   (match_test "s390_mem_constraint (\"BT\", op)"))
 
 
-
 (define_address_constraint "U"
   "Pointer with short displacement"
   (match_test "s390_mem_constraint (\"U\", op)"))
diff --git a/gcc/config/s390/predicates.md b/gcc/config/s390/predicates.md
index 50bf0c1e..f75b3849 100644
--- a/gcc/config/s390/predicates.md
+++ b/gcc/config/s390/predicates.md
@@ -110,7 +110,7 @@
   if (GET_CODE (op) == LABEL_REF)
     return true;
   if (GET_CODE (op) == SYMBOL_REF)
-    return ((SYMBOL_REF_FLAGS (op) & SYMBOL_FLAG_ALIGN1) == 0
+    return (!SYMBOL_REF_ALIGN1_P (op)
 	    && SYMBOL_REF_TLS_MODEL (op) == 0
 	    && (!flag_pic || SYMBOL_REF_LOCAL_P (op)));
 
@@ -172,6 +172,18 @@
   return (s390_branch_condition_mask (op) >= 0);
 })
 
+(define_predicate "s390_signed_integer_comparison"
+  (match_code "eq, ne, lt, gt, le, ge")
+{
+  return (s390_compare_and_branch_condition_mask (op) >= 0);
+})
+
+(define_predicate "s390_unsigned_integer_comparison"
+  (match_code "eq, ne, ltu, gtu, leu, geu")
+{
+  return (s390_compare_and_branch_condition_mask (op) >= 0);
+})
+
 ;; Return nonzero if OP is a valid comparison operator
 ;; for an ALC condition.
 
diff --git a/gcc/config/s390/s390-protos.h b/gcc/config/s390/s390-protos.h
index 7e329f2a..282bd64f 100644
--- a/gcc/config/s390/s390-protos.h
+++ b/gcc/config/s390/s390-protos.h
@@ -27,7 +27,7 @@ extern int s390_mem_constraint (const char *str, rtx op);
 extern int s390_O_constraint_str (const char c, HOST_WIDE_INT value);
 extern int s390_N_constraint_str (const char *str, HOST_WIDE_INT value);
 extern int s390_float_const_zero_p (rtx value);
-
+extern bool s390_check_symref_alignment (rtx addr, HOST_WIDE_INT alignment);
 
 
 /* Declare functions in s390.c.  */
@@ -51,6 +51,7 @@ extern int s390_const_ok_for_constraint_p (HOST_WIDE_INT, int, const char *);
 extern int s390_const_double_ok_for_constraint_p (rtx, int, const char *);
 extern int s390_single_part (rtx, enum machine_mode, enum machine_mode, int);
 extern unsigned HOST_WIDE_INT s390_extract_part (rtx, enum machine_mode, int);
+extern bool s390_contiguous_bitmask_p (unsigned HOST_WIDE_INT, int, int *, int *);
 extern bool s390_split_ok_p (rtx, rtx, enum machine_mode, int);
 extern bool s390_overlap_p (rtx, rtx, HOST_WIDE_INT);
 extern bool s390_offset_p (rtx, rtx, rtx);
@@ -80,6 +81,8 @@ extern enum reg_class s390_secondary_input_reload_class (enum reg_class,
 extern enum reg_class s390_secondary_output_reload_class (enum reg_class,
 							  enum machine_mode,
 							  rtx);
+extern void s390_reload_larl_operand (rtx , rtx , rtx);
+extern void s390_reload_symref_address (rtx , rtx , rtx , bool);
 extern void s390_expand_plus_operand (rtx, rtx, rtx);
 extern void emit_symbolic_move (rtx *);
 extern void s390_load_address (rtx, rtx);
@@ -113,6 +116,7 @@ extern void s390_emit_tpf_eh_return (rtx);
 extern bool s390_legitimate_address_without_index_p (rtx);
 extern bool s390_decompose_shift_count (rtx, rtx *, HOST_WIDE_INT *);
 extern int s390_branch_condition_mask (rtx);
+extern int s390_compare_and_branch_condition_mask (rtx);
 
 #endif /* RTX_CODE */
 
diff --git a/gcc/config/s390/s390.c b/gcc/config/s390/s390.c
index 9c806467..2b6116f9 100644
--- a/gcc/config/s390/s390.c
+++ b/gcc/config/s390/s390.c
@@ -188,6 +188,38 @@ struct processor_costs z9_109_cost =
   COSTS_N_INSNS (24),    /* DSGR */
 };
 
+static const
+struct processor_costs z10_cost =
+{
+  COSTS_N_INSNS (10),    /* M     */
+  COSTS_N_INSNS (10),    /* MGHI  */
+  COSTS_N_INSNS (10),    /* MH    */
+  COSTS_N_INSNS (10),    /* MHI   */
+  COSTS_N_INSNS (10),    /* ML    */
+  COSTS_N_INSNS (10),    /* MR    */
+  COSTS_N_INSNS (10),    /* MS    */
+  COSTS_N_INSNS (10),    /* MSG   */
+  COSTS_N_INSNS (10),    /* MSGF  */
+  COSTS_N_INSNS (10),    /* MSGFR */
+  COSTS_N_INSNS (10),    /* MSGR  */
+  COSTS_N_INSNS (10),    /* MSR   */
+  COSTS_N_INSNS (10),    /* multiplication in DFmode */
+  COSTS_N_INSNS (50),    /* MXBR */
+  COSTS_N_INSNS (120),   /* SQXBR */
+  COSTS_N_INSNS (52),    /* SQDBR */
+  COSTS_N_INSNS (38),    /* SQEBR */
+  COSTS_N_INSNS (10),    /* MADBR */
+  COSTS_N_INSNS (10),    /* MAEBR */
+  COSTS_N_INSNS (111),   /* DXBR */
+  COSTS_N_INSNS (39),    /* DDBR */
+  COSTS_N_INSNS (32),    /* DEBR */
+  COSTS_N_INSNS (160),   /* DLGR */
+  COSTS_N_INSNS (71),    /* DLR */
+  COSTS_N_INSNS (71),    /* DR */
+  COSTS_N_INSNS (71),    /* DSGFR */
+  COSTS_N_INSNS (71),    /* DSGR */
+};
+
 extern int reload_completed;
 
 /* Save information from a "cmpxx" operation until the branch or scc is
@@ -1029,6 +1061,41 @@ s390_branch_condition_mask (rtx code)
     }
 }
 
+
+/* Return branch condition mask to implement a compare and branch
+   specified by CODE.  Return -1 for invalid comparisons.  */
+
+int
+s390_compare_and_branch_condition_mask (rtx code)
+{
+  const int CC0 = 1 << 3;
+  const int CC1 = 1 << 2;
+  const int CC2 = 1 << 1;
+
+  switch (GET_CODE (code))
+    {
+    case EQ:
+      return CC0;
+    case NE:
+      return CC1 | CC2;
+    case LT:
+    case LTU:
+      return CC1;
+    case GT:
+    case GTU:
+      return CC2;
+    case LE:
+    case LEU:
+      return CC0 | CC1;
+    case GE:
+    case GEU:
+      return CC0 | CC2;
+    default:
+      gcc_unreachable ();
+    }
+  return -1;
+}
+
 /* If INV is false, return assembler mnemonic string to implement
    a branch specified by CODE.  If INV is true, return mnemonic
    for the corresponding inverted branch.  */
@@ -1036,6 +1103,8 @@ s390_branch_condition_mask (rtx code)
 static const char *
 s390_branch_condition_mnemonic (rtx code, int inv)
 {
+  int mask;
+
   static const char *const mnemonic[16] =
     {
       NULL, "o", "h", "nle",
@@ -1044,7 +1113,13 @@ s390_branch_condition_mnemonic (rtx code, int inv)
       "le", "nh", "no", NULL
     };
 
-  int mask = s390_branch_condition_mask (code);
+  if (GET_CODE (XEXP (code, 0)) == REG
+      && REGNO (XEXP (code, 0)) == CC_REGNUM
+      && XEXP (code, 1) == const0_rtx)
+    mask = s390_branch_condition_mask (code);
+  else
+    mask = s390_compare_and_branch_condition_mask (code);
+
   gcc_assert (mask >= 0);
 
   if (inv)
@@ -1121,6 +1196,67 @@ s390_single_part (rtx op,
   return part == -1 ? -1 : n_parts - 1 - part;
 }
 
+/* Return true if IN contains a contiguous bitfield in the lower SIZE
+   bits and no other bits are set in IN.  POS and LENGTH can be used
+   to obtain the start position and the length of the bitfield.
+
+   POS gives the position of the first bit of the bitfield counting
+   from the lowest order bit starting with zero.  In order to use this
+   value for S/390 instructions this has to be converted to "bits big
+   endian" style.  */
+
+bool
+s390_contiguous_bitmask_p (unsigned HOST_WIDE_INT in, int size,
+			   int *pos, int *length)
+{
+  int tmp_pos = 0;
+  int tmp_length = 0;
+  int i;
+  unsigned HOST_WIDE_INT mask = 1ULL;
+  bool contiguous = false;
+
+  for (i = 0; i < size; mask <<= 1, i++)
+    {
+      if (contiguous)
+	{
+	  if (mask & in)
+	    tmp_length++;
+	  else
+	    break;
+	}
+      else
+	{
+	  if (mask & in)
+	    {
+	      contiguous = true;
+	      tmp_length++;
+	    }
+	  else
+	    tmp_pos++;
+	}
+    }
+
+  if (!tmp_length)
+    return false;
+
+  /* Calculate a mask for all bits beyond the contiguous bits.  */
+  mask = (-1LL & ~(((1ULL << (tmp_length + tmp_pos - 1)) << 1) - 1));
+
+  if (mask & in)
+    return false;
+
+  if (tmp_length + tmp_pos - 1 > size)
+    return false;
+
+  if (length)
+    *length = tmp_length;
+
+  if (pos)
+    *pos = tmp_pos;
+
+  return true;
+}
+
 /* Check whether we can (and want to) split a double-word
    move in mode MODE from SRC to DST into two single-word
    moves, moving the subword FIRST_SUBWORD first.  */
@@ -1365,6 +1501,8 @@ s390_handle_arch_option (const char *arg,
                                        | PF_LONG_DISPLACEMENT | PF_EXTIMM},
       {"z9-ec", PROCESSOR_2094_Z9_109, PF_IEEE_FLOAT | PF_ZARCH
                              | PF_LONG_DISPLACEMENT | PF_EXTIMM | PF_DFP },
+      {"z10", PROCESSOR_2097_Z10, PF_IEEE_FLOAT | PF_ZARCH
+                             | PF_LONG_DISPLACEMENT | PF_EXTIMM | PF_DFP | PF_Z10},
     };
   size_t i;
 
@@ -1472,13 +1610,21 @@ override_options (void)
     }
 
   /* Set processor cost function.  */
-  if (s390_tune == PROCESSOR_2094_Z9_109)
-    s390_cost = &z9_109_cost;
-  else if (s390_tune == PROCESSOR_2084_Z990)
-    s390_cost = &z990_cost;
-  else
-    s390_cost = &z900_cost;
-  
+  switch (s390_tune)
+    {
+    case PROCESSOR_2084_Z990:
+      s390_cost = &z990_cost;
+      break;
+    case PROCESSOR_2094_Z9_109:
+      s390_cost = &z9_109_cost;
+      break;
+    case PROCESSOR_2097_Z10:
+      s390_cost = &z10_cost;
+      break;
+    default:
+      s390_cost = &z900_cost;
+    }
+
   if (TARGET_BACKCHAIN && TARGET_PACKED_STACK && TARGET_HARD_FLOAT)
     error ("-mbackchain -mpacked-stack -mhard-float are not supported "
 	   "in combination");
@@ -1992,10 +2138,9 @@ s390_mem_constraint (const char *str, rtx op)
 	return 0;
       if (GET_CODE (op) != MEM)
 	return 0;
-      /* Any invalid address here will be fixed up by reload,
-	 so accept it for the most generic constraint.  */
-      if (s390_decompose_address (XEXP (op, 0), &addr)
-	  && s390_short_displacement (addr.disp))
+      if (!s390_decompose_address (XEXP (op, 0), &addr))
+	return 0;
+      if (s390_short_displacement (addr.disp))
 	return 0;
       break;
 
@@ -2012,10 +2157,9 @@ s390_mem_constraint (const char *str, rtx op)
     case 'W':
       if (!TARGET_LONG_DISPLACEMENT)
 	return 0;
-      /* Any invalid address here will be fixed up by reload,
-	 so accept it for the most generic constraint.  */
-      if (s390_decompose_address (op, &addr)
-	  && s390_short_displacement (addr.disp))
+      if (!s390_decompose_address (op, &addr))
+	return 0;
+      if (s390_short_displacement (addr.disp))
 	return 0;
       break;
 
@@ -2651,6 +2795,132 @@ s390_preferred_reload_class (rtx op, enum reg_class class)
   return class;
 }
 
+/* Return true if ADDR is of kind symbol_ref or symbol_ref + const_int
+   and return these parts in SYMREF and ADDEND.  You can pass NULL in
+   SYMREF and/or ADDEND if you are not interested in these values.  */
+
+static bool
+s390_symref_operand_p (rtx addr, rtx *symref, HOST_WIDE_INT *addend)
+{
+  HOST_WIDE_INT tmpaddend = 0;
+
+  if (GET_CODE (addr) == CONST)
+    addr = XEXP (addr, 0);
+
+  if (GET_CODE (addr) == PLUS)
+    {
+      if (GET_CODE (XEXP (addr, 0)) == SYMBOL_REF
+	  && CONST_INT_P (XEXP (addr, 1)))
+	{
+	  tmpaddend = INTVAL (XEXP (addr, 1));
+	  addr = XEXP (addr, 0);
+	}
+      else
+	return false;
+    }
+  else
+    if (GET_CODE (addr) != SYMBOL_REF)
+	return false;
+
+  if (symref)
+    *symref = addr;
+  if (addend)
+    *addend = tmpaddend;
+
+  return true;
+}
+
+/* Return true if ADDR is SYMBOL_REF + addend with addend being a
+   multiple of ALIGNMENT and the SYMBOL_REF being naturally
+   aligned.  */
+
+bool
+s390_check_symref_alignment (rtx addr, HOST_WIDE_INT alignment)
+{
+  HOST_WIDE_INT addend;
+  rtx symref;
+
+  if (!s390_symref_operand_p (addr, &symref, &addend))
+    return false;
+
+  return (!SYMBOL_REF_NOT_NATURALLY_ALIGNED_P (symref)
+	  && !(addend & (alignment - 1)));
+}
+
+/* ADDR is moved into REG using larl.  If ADDR isn't a valid larl
+   operand SCRATCH is used to reload the even part of the address and
+   adding one.  */
+
+void
+s390_reload_larl_operand (rtx reg, rtx addr, rtx scratch)
+{
+  HOST_WIDE_INT addend;
+  rtx symref;
+
+  if (!s390_symref_operand_p (addr, &symref, &addend))
+    gcc_unreachable ();
+
+  if (!(addend & 1))
+    /* Easy case.  The addend is even so larl will do fine.  */
+    emit_move_insn (reg, addr);
+  else
+    {
+      /* We can leave the scratch register untouched if the target
+	 register is a valid base register.  */
+      if (REGNO (reg) < FIRST_PSEUDO_REGISTER
+	  && REGNO_REG_CLASS (REGNO (reg)) == ADDR_REGS)
+	scratch = reg;
+
+      gcc_assert (REGNO (scratch) < FIRST_PSEUDO_REGISTER);
+      gcc_assert (REGNO_REG_CLASS (REGNO (scratch)) == ADDR_REGS);
+
+      if (addend != 1)
+	emit_move_insn (scratch,
+			gen_rtx_CONST (Pmode,
+				       gen_rtx_PLUS (Pmode, symref,
+						     GEN_INT (addend - 1))));
+      else
+	emit_move_insn (scratch, symref);
+
+      /* Increment the address using la in order to avoid clobbering cc.  */
+      emit_move_insn (reg, gen_rtx_PLUS (Pmode, scratch, const1_rtx));
+    }
+}
+
+/* Generate what is necessary to move between REG and MEM using
+   SCRATCH.  The direction is given by TOMEM.  */
+
+void
+s390_reload_symref_address (rtx reg, rtx mem, rtx scratch, bool tomem)
+{
+  /* Reload might have pulled a constant out of the literal pool.
+     Force it back in.  */
+  if (CONST_INT_P (mem) || GET_CODE (mem) == CONST_DOUBLE
+      || GET_CODE (mem) == CONST)
+    mem = force_const_mem (GET_MODE (reg), mem);
+
+  gcc_assert (MEM_P (mem));
+
+  /* For a load from memory we can leave the scratch register
+     untouched if the target register is a valid base register.  */
+  if (!tomem
+      && REGNO (reg) < FIRST_PSEUDO_REGISTER
+      && REGNO_REG_CLASS (REGNO (reg)) == ADDR_REGS
+      && GET_MODE (reg) == GET_MODE (scratch))
+    scratch = reg;
+
+  /* Load address into scratch register.  Since we can't have a
+     secondary reload for a secondary reload we have to cover the case
+     where larl would need a secondary reload here as well.  */
+  s390_reload_larl_operand (scratch, XEXP (mem, 0), scratch);
+
+  /* Now we can use a standard load/store to do the move.  */
+  if (tomem)
+    emit_move_insn (replace_equiv_address (mem, scratch), reg);
+  else
+    emit_move_insn (reg, replace_equiv_address (mem, scratch));
+}
+
 /* Inform reload about cases where moving X with a mode MODE to a register in
    CLASS requires an extra scratch or immediate register.  Return the class
    needed for the immediate register.  */
@@ -2663,6 +2933,60 @@ s390_secondary_reload (bool in_p, rtx x, enum reg_class class,
   if (reg_classes_intersect_p (CC_REGS, class))
     return GENERAL_REGS;
 
+  if (TARGET_Z10)
+    {
+      /* On z10 several optimizer steps may generate larl operands with
+	 an odd addend.  */
+      if (in_p
+	  && s390_symref_operand_p (x, NULL, NULL)
+	  && mode == Pmode
+	  && !s390_check_symref_alignment (x, 2))
+	sri->icode = ((mode == DImode) ? CODE_FOR_reloaddi_larl_odd_addend_z10
+		      : CODE_FOR_reloadsi_larl_odd_addend_z10);
+
+      /* On z10 we need a scratch register when moving QI, TI or floating
+	 point mode values from or to a memory location with a SYMBOL_REF
+	 or if the symref addend of a SI or DI move is not aligned to the
+	 width of the access.  */
+      if (MEM_P (x)
+	  && s390_symref_operand_p (XEXP (x, 0), NULL, NULL)
+	  && (mode == QImode || mode == TImode || FLOAT_MODE_P (mode)
+	      || (!TARGET_64BIT && mode == DImode)
+	      || ((mode == HImode || mode == SImode || mode == DImode)
+		  && (!s390_check_symref_alignment (XEXP (x, 0),
+						    GET_MODE_SIZE (mode))))))
+	{
+#define __SECONDARY_RELOAD_CASE(M,m)					\
+	  case M##mode:							\
+	    if (TARGET_64BIT)						\
+	      sri->icode = in_p ? CODE_FOR_reload##m##di_toreg_z10 :	\
+                                  CODE_FOR_reload##m##di_tomem_z10;	\
+	    else							\
+  	      sri->icode = in_p ? CODE_FOR_reload##m##si_toreg_z10 :	\
+                                  CODE_FOR_reload##m##si_tomem_z10;	\
+	  break;
+
+	  switch (GET_MODE (x))
+	    {
+	      __SECONDARY_RELOAD_CASE (QI, qi);
+	      __SECONDARY_RELOAD_CASE (HI, hi);
+	      __SECONDARY_RELOAD_CASE (SI, si);
+	      __SECONDARY_RELOAD_CASE (DI, di);
+	      __SECONDARY_RELOAD_CASE (TI, ti);
+	      __SECONDARY_RELOAD_CASE (SF, sf);
+	      __SECONDARY_RELOAD_CASE (DF, df);
+	      __SECONDARY_RELOAD_CASE (TF, tf);
+	      __SECONDARY_RELOAD_CASE (SD, sd);
+	      __SECONDARY_RELOAD_CASE (DD, dd);
+	      __SECONDARY_RELOAD_CASE (TD, td);
+
+	    default:
+	      gcc_unreachable ();
+	    }
+#undef __SECONDARY_RELOAD_CASE
+	}
+    }
+
   /* We need a scratch register when loading a PLUS expression which
      is not a legitimate operand of the LOAD ADDRESS instruction.  */
   if (in_p && s390_plus_operand (x, mode))
@@ -2769,10 +3093,16 @@ s390_expand_plus_operand (rtx target, rtx src,
    STRICT specifies whether strict register checking applies.  */
 
 bool
-legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,
-		      rtx addr, int strict)
+legitimate_address_p (enum machine_mode mode, rtx addr, int strict)
 {
   struct s390_address ad;
+
+  if (TARGET_Z10
+      && larl_operand (addr, VOIDmode)
+      && (mode == VOIDmode
+	  || s390_check_symref_alignment (addr, GET_MODE_SIZE (mode))))
+    return true;
+
   if (!s390_decompose_address (addr, &ad))
     return false;
 
@@ -4010,14 +4340,31 @@ s390_expand_addcc (enum rtx_code cmp_code, rtx cmp_op0, rtx cmp_op1,
   return false;
 }
 
-/* Expand code for the insv template. Return true if successful, false else.  */
+/* Expand code for the insv template. Return true if successful.  */
 
-bool 
+bool
 s390_expand_insv (rtx dest, rtx op1, rtx op2, rtx src)
 {
   int bitsize = INTVAL (op1);
   int bitpos = INTVAL (op2);
 
+  /* On z10 we can use the risbg instruction to implement insv.  */
+  if (TARGET_Z10
+      && ((GET_MODE (dest) == DImode && GET_MODE (src) == DImode)
+	  || (GET_MODE (dest) == SImode && GET_MODE (src) == SImode)))
+    {
+      rtx op;
+      rtx clobber;
+
+      op = gen_rtx_SET (GET_MODE(src),
+			gen_rtx_ZERO_EXTRACT (GET_MODE (dest), dest, op1, op2),
+			src);
+      clobber = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, CC_REGNUM));
+      emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, op, clobber)));
+
+      return true;
+    }
+
   /* We need byte alignment.  */
   if (bitsize % BITS_PER_UNIT)
     return false;
@@ -4554,6 +4901,13 @@ print_operand_address (FILE *file, rtx addr)
 {
   struct s390_address ad;
 
+  if (s390_symref_operand_p (addr, NULL, NULL))
+    {
+      gcc_assert (TARGET_Z10);
+      output_addr_const (file, addr);
+      return;
+    }
+
   if (!s390_decompose_address (addr, &ad)
       || (ad.base && !REGNO_OK_FOR_BASE_P (REGNO (ad.base)))
       || (ad.indx && !REGNO_OK_FOR_INDEX_P (REGNO (ad.indx))))
@@ -4587,6 +4941,7 @@ print_operand_address (FILE *file, rtx addr)
     'Y': print shift count operand.
 
     'b': print integer X as if it's an unsigned byte.
+    'c': print integer X as if it's an signed byte.
     'x': print integer X as if it's an unsigned halfword.
     'h': print integer X as if it's a signed halfword.
     'i': print the first nonzero HImode part of X.
@@ -4732,6 +5087,8 @@ print_operand (FILE *file, rtx x, int code)
     case CONST_INT:
       if (code == 'b')
         fprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (x) & 0xff);
+      else if (code == 'c')
+        fprintf (file, HOST_WIDE_INT_PRINT_DEC, ((INTVAL (x) & 0xff) ^ 0x80) - 0x80);
       else if (code == 'x')
         fprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (x) & 0xffff);
       else if (code == 'h')
@@ -4891,6 +5248,7 @@ s390_agen_dep_p (rtx dep_insn, rtx insn)
   return 0;
 }
 
+
 /* A C statement (sans semicolon) to update the integer scheduling priority
    INSN_PRIORITY (INSN).  Increase the priority to execute the INSN earlier,
    reduce the priority to execute INSN later.  Do not define this macro if
@@ -4930,10 +5288,16 @@ s390_adjust_priority (rtx insn ATTRIBUTE_UNUSED, int priority)
 static int
 s390_issue_rate (void)
 {
-  if (s390_tune == PROCESSOR_2084_Z990
-      || s390_tune == PROCESSOR_2094_Z9_109)
-    return 3;
-  return 1;
+  switch (s390_tune)
+    {
+    case PROCESSOR_2084_Z990:
+    case PROCESSOR_2094_Z9_109:
+      return 3;
+    case PROCESSOR_2097_Z10:
+      return 2;
+    default:
+      return 1;
+    }
 }
 
 static int
@@ -8532,11 +8896,30 @@ s390_encode_section_info (tree decl, rtx rtl, int first)
 {
   default_encode_section_info (decl, rtl, first);
 
-  /* If a variable has a forced alignment to < 2 bytes, mark it with
-     SYMBOL_FLAG_ALIGN1 to prevent it from being used as LARL operand.  */
-  if (TREE_CODE (decl) == VAR_DECL
-      && DECL_USER_ALIGN (decl) && DECL_ALIGN (decl) < 16)
-    SYMBOL_REF_FLAGS (XEXP (rtl, 0)) |= SYMBOL_FLAG_ALIGN1;
+  if (TREE_CODE (decl) == VAR_DECL)
+    {
+      /* If a variable has a forced alignment to < 2 bytes, mark it
+	 with SYMBOL_FLAG_ALIGN1 to prevent it from being used as LARL
+	 operand.  */
+      if (DECL_USER_ALIGN (decl) && DECL_ALIGN (decl) < 16)
+	SYMBOL_REF_FLAGS (XEXP (rtl, 0)) |= SYMBOL_FLAG_ALIGN1;
+      if (!DECL_SIZE (decl)
+	  || !DECL_ALIGN (decl)
+	  || !host_integerp (DECL_SIZE (decl), 0)
+	  || (DECL_ALIGN (decl) <= 64
+	      && DECL_ALIGN (decl) != tree_low_cst (DECL_SIZE (decl), 0)))
+	SYMBOL_REF_FLAGS (XEXP (rtl, 0)) |= SYMBOL_FLAG_NOT_NATURALLY_ALIGNED;
+    }
+
+  /* Literal pool references don't have a decl so they are handled
+     differently here.  We rely on the information in the MEM_ALIGN
+     entry to decide upon natural alignment.  */
+  if (MEM_P (rtl)
+      && GET_CODE (XEXP (rtl, 0)) == SYMBOL_REF
+      && TREE_CONSTANT_POOL_ADDRESS_P (XEXP (rtl, 0))
+      && (MEM_ALIGN (rtl) == 0
+	  || MEM_ALIGN (rtl) < GET_MODE_BITSIZE (GET_MODE (rtl))))
+    SYMBOL_REF_FLAGS (XEXP (rtl, 0)) |= SYMBOL_FLAG_NOT_NATURALLY_ALIGNED;
 }
 
 /* Output thunk to FILE that implements a C++ virtual function call (with
diff --git a/gcc/config/s390/s390.h b/gcc/config/s390/s390.h
index 7d9a0f87..f5e6a934 100644
--- a/gcc/config/s390/s390.h
+++ b/gcc/config/s390/s390.h
@@ -40,6 +40,7 @@ enum processor_type
   PROCESSOR_2064_Z900,
   PROCESSOR_2084_Z990,
   PROCESSOR_2094_Z9_109,
+  PROCESSOR_2097_Z10,
   PROCESSOR_max
 };
 
@@ -51,7 +52,8 @@ enum processor_flags
   PF_ZARCH = 2,
   PF_LONG_DISPLACEMENT = 4,
   PF_EXTIMM = 8,
-  PF_DFP = 16
+  PF_DFP = 16,
+  PF_Z10 = 32
 };
 
 extern enum processor_type s390_tune;
@@ -60,6 +62,10 @@ extern enum processor_flags s390_tune_flags;
 extern enum processor_type s390_arch;
 extern enum processor_flags s390_arch_flags;
 
+/* These flags indicate that the generated code should run on a cpu
+   providing the respective hardware facility regardless of the
+   current cpu mode (ESA or z/Architecture).  */
+
 #define TARGET_CPU_IEEE_FLOAT \
 	(s390_arch_flags & PF_IEEE_FLOAT)
 #define TARGET_CPU_ZARCH \
@@ -70,13 +76,21 @@ extern enum processor_flags s390_arch_flags;
  	(s390_arch_flags & PF_EXTIMM)
 #define TARGET_CPU_DFP \
  	(s390_arch_flags & PF_DFP)
+#define TARGET_CPU_Z10 \
+ 	(s390_arch_flags & PF_Z10)
+
+/* These flags indicate that the generated code should run on a cpu
+   providing the respective hardware facility when run in
+   z/Architecture mode.  */
 
 #define TARGET_LONG_DISPLACEMENT \
        (TARGET_ZARCH && TARGET_CPU_LONG_DISPLACEMENT)
 #define TARGET_EXTIMM \
        (TARGET_ZARCH && TARGET_CPU_EXTIMM)
 #define TARGET_DFP \
-       (TARGET_ZARCH && TARGET_CPU_DFP)
+       (TARGET_ZARCH && TARGET_CPU_DFP && TARGET_HARD_FLOAT)
+#define TARGET_Z10 \
+       (TARGET_ZARCH && TARGET_CPU_Z10)
 
 /* Run-time target specification.  */
 
@@ -485,11 +499,14 @@ extern const enum reg_class regclass_map[FIRST_PSEUDO_REGISTER];
 #define PREFERRED_RELOAD_CLASS(X, CLASS)	\
   s390_preferred_reload_class ((X), (CLASS))
 
-/* We need secondary memory to move data between GPRs and FPRs.  */
+/* We need secondary memory to move data between GPRs and FPRs.  With
+   DFP the ldgr lgdr instructions are available.  But these
+   instructions do not handle GPR pairs so it is not possible for 31
+   bit.  */
 #define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE) \
  ((CLASS1) != (CLASS2)                                \
   && ((CLASS1) == FP_REGS || (CLASS2) == FP_REGS)     \
-  && (!TARGET_DFP || GET_MODE_SIZE (MODE) != 8))
+  && (!TARGET_DFP || !TARGET_64BIT || GET_MODE_SIZE (MODE) != 8))
 
 /* Get_secondary_mem widens its argument to BITS_PER_WORD which loses on 64bit
    because the movsi and movsf patterns don't handle r/f moves.  */
@@ -696,6 +713,13 @@ CUMULATIVE_ARGS;
 /* Maximum number of registers that can appear in a valid memory address.  */
 #define MAX_REGS_PER_ADDRESS 2
 
+/* This definition replaces the formerly used 'm' constraint with a
+different constraint letter in order to avoid changing semantics of
+the 'm' constraint when accepting new address formats in
+legitimate_address_p.  The constraint letter defined here must not be
+used in insn definitions or inline assemblies.  */
+#define TARGET_MEM_CONSTRAINT 'e'
+
 /* S/390 has no mode dependent addresses.  */
 #define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)
 
@@ -962,7 +986,12 @@ do {									\
 #define CLZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE) ((VALUE) = 64, 1)
 
 /* Machine-specific symbol_ref flags.  */
-#define SYMBOL_FLAG_ALIGN1	(SYMBOL_FLAG_MACH_DEP << 0)
+#define SYMBOL_FLAG_ALIGN1	          (SYMBOL_FLAG_MACH_DEP << 0)
+#define SYMBOL_REF_ALIGN1_P(X)		\
+  ((SYMBOL_REF_FLAGS (X) & SYMBOL_FLAG_ALIGN1))
+#define SYMBOL_FLAG_NOT_NATURALLY_ALIGNED (SYMBOL_FLAG_MACH_DEP << 1)
+#define SYMBOL_REF_NOT_NATURALLY_ALIGNED_P(X) \
+  ((SYMBOL_REF_FLAGS (X) & SYMBOL_FLAG_NOT_NATURALLY_ALIGNED))
 
 /* Check whether integer displacement is in range.  */
 #define DISP_IN_RANGE(d) \
diff --git a/gcc/config/s390/s390.md b/gcc/config/s390/s390.md
index 5ffa7288..8b9500d8 100644
--- a/gcc/config/s390/s390.md
+++ b/gcc/config/s390/s390.md
@@ -38,6 +38,7 @@
 ;;     %Y: print shift count operand.
 ;;  
 ;;     %b: print integer X as if it's an unsigned byte.
+;;     %c: print integer X as if it's an signed byte.
 ;;     %x: print integer X as if it's an unsigned halfword.
 ;;     %h: print integer X as if it's a signed halfword.
 ;;     %i: print the first nonzero HImode part of X.
@@ -189,7 +190,7 @@
 ;; Used to determine defaults for length and other attribute values.
 
 (define_attr "op_type"
-  "NN,E,RR,RRE,RX,RS,RSI,RI,SI,S,SS,SSE,RXE,RSE,RIL,RIE,RXY,RSY,SIY,RRF,RRR"
+  "NN,E,RR,RRE,RX,RS,RSI,RI,SI,S,SS,SSE,RXE,RSE,RIL,RIE,RXY,RSY,SIY,RRF,RRR,SIL,RRS,RIS"
   (const_string "NN"))
 
 ;; Instruction type attribute used for scheduling.
@@ -200,8 +201,12 @@
 		     branch,jsr,fsimptf,fsimpdf,fsimpsf,
 		     floadtf,floaddf,floadsf,fstoredf,fstoresf,
 		     fmultf,fmuldf,fmulsf,fdivtf,fdivdf,fdivsf,
-		     ftoi,itof,fsqrttf,fsqrtdf,fsqrtsf,
-                     ftrunctf,ftruncdf,other"
+		     ftoi,fsqrttf,fsqrtdf,fsqrtsf,
+                     ftrunctf,ftruncdf, ftruncsd, ftruncdd,
+                     itoftf, itofdf, itofsf, itofdd, itoftd,
+                     fdivdd, fdivtd, floaddd, floadsd, fmuldd, fmultd,
+                     fsimpdd, fsimpsd, fsimptd, fstoredd, fstoresd,
+                     ftoidfp, other"
   (cond [(eq_attr "op_type" "NN")  (const_string "other")
          (eq_attr "op_type" "SS")  (const_string "cs")]
     (const_string "integer")))
@@ -215,11 +220,36 @@
 		(const_string "reg")
 		(const_string "agen")))
 
+;; Properties concerning Z10 execution grouping and value forwarding.
+;; z10_super: instruction is superscalar.
+;; z10_super_c: instruction is superscalar and meets the condition of z10_c.
+;; z10_fwd: The instruction reads the value of an operand and stores it into a
+;;   target register.  It can forward this value to a second instruction that reads
+;;   the same register if that second instruction is issued in the same group.
+;; z10_rec: The instruction is in the T pipeline and reads a register. If the
+;;   instruction in the S pipe writes to the register, then the T instruction
+;;   can immediately read the new value.
+;; z10_fr: union of Z10_fwd and z10_rec.
+;; z10_c: second operand of instruction is a register and read with complemented bits.
+;; z10_cobra: its a compare and branch instruction
+;;
+;; An additional suffix A1, A3, or E1 indicates the respective AGI bypass.
+
+
+(define_attr "z10prop" "none,
+                        z10_super, z10_super_E1, z10_super_A1, z10_super_c, z10_super_c_E1,
+                        z10_fwd, z10_fwd_A1, z10_fwd_A3, z10_fwd_E1,
+                        z10_rec,
+                        z10_fr, z10_fr_A3, z10_fr_E1,
+                        z10_c, z10_cobra"
+             (const_string "none"))
+
+
 ;; Length in bytes.
 
 (define_attr "length" ""
-  (cond [(eq_attr "op_type" "E,RR")		      (const_int 2)
-         (eq_attr "op_type" "RX,RI,RRE,RS,RSI,S,SI")  (const_int 4)]
+  (cond [(eq_attr "op_type" "E,RR")		              (const_int 2)
+         (eq_attr "op_type" "RX,RI,RRE,RS,RSI,S,SI,RRF,RRR")  (const_int 4)]
     (const_int 6)))
 
 
@@ -228,9 +258,41 @@
 ;; distinguish between g5 and g6, but there are differences between the two
 ;; CPUs could in theory be modeled.
 
-(define_attr "cpu" "g5,g6,z900,z990,z9_109"
+(define_attr "cpu" "g5,g6,z900,z990,z9_109,z10"
   (const (symbol_ref "s390_tune")))
 
+(define_attr "cpu_facility" "standard,ieee,zarch,longdisp,extimm,dfp,z10"
+  (const_string "standard"))
+
+(define_attr "enabled" ""
+  (cond [(eq_attr "cpu_facility" "standard")
+	 (const_int 1)
+
+         (and (eq_attr "cpu_facility" "ieee")
+	      (ne (symbol_ref "TARGET_CPU_IEEE_FLOAT") (const_int 0)))
+	 (const_int 1)
+
+	 (and (eq_attr "cpu_facility" "zarch")
+	      (ne (symbol_ref "TARGET_ZARCH") (const_int 0)))
+	 (const_int 1)
+
+	 (and (eq_attr "cpu_facility" "longdisp")
+	      (ne (symbol_ref "TARGET_LONG_DISPLACEMENT") (const_int 0)))
+	 (const_int 1)
+
+         (and (eq_attr "cpu_facility" "extimm")
+	      (ne (symbol_ref "TARGET_EXTIMM") (const_int 0)))
+	 (const_int 1)
+
+         (and (eq_attr "cpu_facility" "dfp")
+	      (ne (symbol_ref "TARGET_DFP") (const_int 0)))
+	 (const_int 1)
+
+         (and (eq_attr "cpu_facility" "z10")
+              (ne (symbol_ref "TARGET_Z10") (const_int 0)))
+	 (const_int 1)]
+	(const_int 0)))
+
 ;; Pipeline description for z900.  For lack of anything better,
 ;; this description is also used for the g5 and g6.
 (include "2064.md")
@@ -238,6 +300,9 @@
 ;; Pipeline description for z990, z9-109 and z9-ec.
 (include "2084.md")
 
+;; Pipeline description for z10
+(include "2097.md")
+
 ;; Predicates
 (include "predicates.md")
 
@@ -254,6 +319,7 @@
 (define_mode_iterator FP_ALL [TF DF SF (TD "TARGET_HARD_DFP") (DD "TARGET_HARD_DFP") 
                               (SD "TARGET_HARD_DFP")])
 (define_mode_iterator FP [TF DF SF (TD "TARGET_HARD_DFP") (DD "TARGET_HARD_DFP")])
+(define_mode_iterator FPALL [TF DF SF TD DD SD])
 (define_mode_iterator BFP [TF DF SF])
 (define_mode_iterator DFP [TD DD])
 (define_mode_iterator DFP_ALL [TD DD SD])
@@ -283,6 +349,7 @@
 ;; This mode iterator allows the integer patterns to be defined from the
 ;; same template.
 (define_mode_iterator INT [(DI "TARGET_64BIT") SI HI QI])
+(define_mode_iterator INTALL [TI DI SI HI QI])
 
 ;; This iterator allows to unify all 'bCOND' expander patterns.
 (define_code_iterator COMPARE [eq ne gt gtu lt ltu ge geu le leu unordered 
@@ -352,12 +419,6 @@
 ;; modes and to an empty string for bfp modes.
 (define_mode_attr _d [(TF "") (DF "") (SF "") (TD "d") (DD "d") (SD "d")])
 
-;; Although it is imprecise for z9-ec we handle all dfp instructions like
-;; bfp regarding the pipeline description.
-(define_mode_attr bfp [(TF "tf") (DF "df") (SF "sf")
-                       (TD "tf") (DD "df") (SD "sf")])
-
-
 ;; In GPR and P templates, a constraint like "<d0>" will expand to "d" in DImode
 ;; and "0" in SImode. This allows to combine instructions of which the 31bit
 ;; version only operates on one register.
@@ -367,13 +428,13 @@
 ;; version only operates on one register. The DImode version needs an additional
 ;; register for the assembler output.
 (define_mode_attr 1 [(DI "%1,") (SI "")])
-  
-;; In SHIFT templates, a string like "s<lr>dl" will expand to "sldl" in 
+
+;; In SHIFT templates, a string like "s<lr>dl" will expand to "sldl" in
 ;; 'ashift' and "srdl" in 'lshiftrt'.
 (define_code_attr lr [(ashift "l") (lshiftrt "r")])
 
 ;; In SHIFT templates, this attribute holds the correct standard name for the
-;; pattern itself and the corresponding function calls. 
+;; pattern itself and the corresponding function calls.
 (define_code_attr shift [(ashift "ashl") (lshiftrt "lshr")])
 
 ;; This attribute handles differences in the instruction 'type' and will result
@@ -425,7 +486,6 @@
 ;; Maximum unsigned integer that fits in MODE.
 (define_mode_attr max_uint [(HI "65535") (QI "255")])
 
-
 ;;
 ;;- Compare instructions.
 ;;
@@ -464,7 +524,8 @@
   "@
    tm\t%S0,%b1
    tmy\t%S0,%b1"
-  [(set_attr "op_type" "SI,SIY")])
+  [(set_attr "op_type" "SI,SIY")
+   (set_attr "z10prop" "z10_super,z10_super")])
 
 (define_insn "*tmdi_reg"
   [(set (reg CC_REGNUM)
@@ -480,7 +541,8 @@
    tmhl\t%0,%i1
    tmlh\t%0,%i1
    tmll\t%0,%i1"
-  [(set_attr "op_type" "RI")])
+  [(set_attr "op_type" "RI")
+   (set_attr "z10prop" "z10_super,z10_super,z10_super,z10_super")])
 
 (define_insn "*tmsi_reg"
   [(set (reg CC_REGNUM)
@@ -511,19 +573,25 @@
 
 (define_insn "*tstdi_sign"
   [(set (reg CC_REGNUM)
-        (compare (ashiftrt:DI (ashift:DI (subreg:DI (match_operand:SI 0 "register_operand" "d") 0)
-					 (const_int 32)) (const_int 32))
-                 (match_operand:DI 1 "const0_operand" "")))
-   (set (match_operand:DI 2 "register_operand" "=d")
+        (compare
+          (ashiftrt:DI
+            (ashift:DI
+              (subreg:DI (match_operand:SI 0 "nonimmediate_operand" "d,RT") 0)
+	      (const_int 32)) (const_int 32))
+	  (match_operand:DI 1 "const0_operand" "")))
+   (set (match_operand:DI 2 "register_operand" "=d,d")
         (sign_extend:DI (match_dup 0)))]
   "s390_match_ccmode(insn, CCSmode) && TARGET_64BIT"
-  "ltgfr\t%2,%0"
-  [(set_attr "op_type" "RRE")])
+  "ltgfr\t%2,%0
+   ltgf\t%2,%0"
+  [(set_attr "op_type"      "RRE,RXY")
+   (set_attr "cpu_facility" "*,z10")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1") ])
 
 ; ltr, lt, ltgr, ltg
 (define_insn "*tst<mode>_extimm"
   [(set (reg CC_REGNUM)
-        (compare (match_operand:GPR 0 "nonimmediate_operand" "d,m")
+        (compare (match_operand:GPR 0 "nonimmediate_operand" "d,RT")
                  (match_operand:GPR 1 "const0_operand" "")))
    (set (match_operand:GPR 2 "register_operand" "=d,d")
         (match_dup 0))]
@@ -531,19 +599,21 @@
   "@
    lt<g>r\t%2,%0
    lt<g>\t%2,%0"
-  [(set_attr "op_type" "RR<E>,RXY")])
+  [(set_attr "op_type" "RR<E>,RXY")
+   (set_attr "z10prop" "z10_fr_E1,z10_fr_A3") ])
 
 ; ltr, lt, ltgr, ltg
 (define_insn "*tst<mode>_cconly_extimm"
   [(set (reg CC_REGNUM)
-        (compare (match_operand:GPR 0 "nonimmediate_operand" "d,m")
+        (compare (match_operand:GPR 0 "nonimmediate_operand" "d,RT")
                  (match_operand:GPR 1 "const0_operand" "")))
    (clobber (match_scratch:GPR 2 "=X,d"))]
   "s390_match_ccmode(insn, CCSmode) && TARGET_EXTIMM"
   "@
    lt<g>r\t%0,%0
    lt<g>\t%2,%0"
-  [(set_attr "op_type" "RR<E>,RXY")])
+  [(set_attr "op_type" "RR<E>,RXY")
+   (set_attr "z10prop" "z10_fr_E1,z10_fr_A3")])
 
 (define_insn "*tstdi"
   [(set (reg CC_REGNUM)
@@ -553,7 +623,8 @@
         (match_dup 0))]
   "s390_match_ccmode(insn, CCSmode) && TARGET_64BIT && !TARGET_EXTIMM"
   "ltgr\t%2,%0"
-  [(set_attr "op_type" "RRE")])
+  [(set_attr "op_type" "RRE")
+   (set_attr "z10prop" "z10_fr_E1")])
 
 (define_insn "*tstsi"
   [(set (reg CC_REGNUM)
@@ -566,7 +637,8 @@
    ltr\t%2,%0
    icm\t%2,15,%S0
    icmy\t%2,15,%S0"
-  [(set_attr "op_type" "RR,RS,RSY")])
+  [(set_attr "op_type" "RR,RS,RSY")
+   (set_attr "z10prop" "z10_fr_E1,z10_super_E1,z10_super_E1")])
 
 (define_insn "*tstsi_cconly"
   [(set (reg CC_REGNUM)
@@ -578,7 +650,8 @@
    ltr\t%0,%0
    icm\t%2,15,%S0
    icmy\t%2,15,%S0"
-  [(set_attr "op_type" "RR,RS,RSY")])
+  [(set_attr "op_type" "RR,RS,RSY")
+   (set_attr "z10prop" "z10_fr_E1,z10_super_E1,z10_super_E1")])
 
 (define_insn "*tstdi_cconly_31"
   [(set (reg CC_REGNUM)
@@ -596,7 +669,8 @@
                  (match_operand:GPR 1 "const0_operand" "")))]
   "s390_match_ccmode(insn, CCSmode)"
   "lt<g>r\t%0,%0"
-  [(set_attr "op_type" "RR<E>")])
+  [(set_attr "op_type" "RR<E>")
+   (set_attr "z10prop" "z10_fr_E1")])
 
 ; tst(hi|qi) instruction pattern(s).
 
@@ -611,7 +685,8 @@
    icm\t%2,<icm_lo>,%S0
    icmy\t%2,<icm_lo>,%S0
    tml\t%0,<max_uint>"
-  [(set_attr "op_type" "RS,RSY,RI")])
+  [(set_attr "op_type" "RS,RSY,RI")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1,z10_super")])
 
 (define_insn "*tsthiCCT_cconly"
   [(set (reg CC_REGNUM)
@@ -623,7 +698,8 @@
    icm\t%2,3,%S0
    icmy\t%2,3,%S0
    tml\t%0,65535"
-  [(set_attr "op_type" "RS,RSY,RI")])
+  [(set_attr "op_type" "RS,RSY,RI")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1,z10_super")])
 
 (define_insn "*tstqiCCT_cconly"
   [(set (reg CC_REGNUM)
@@ -634,7 +710,8 @@
    cli\t%S0,0
    cliy\t%S0,0
    tml\t%0,255"
-  [(set_attr "op_type" "SI,SIY,RI")])
+  [(set_attr "op_type" "SI,SIY,RI")
+   (set_attr "z10prop" "z10_super,z10_super,*")])
 
 (define_insn "*tst<mode>"
   [(set (reg CC_REGNUM)
@@ -646,7 +723,8 @@
   "@
    icm\t%2,<icm_lo>,%S0
    icmy\t%2,<icm_lo>,%S0"
-  [(set_attr "op_type" "RS,RSY")])
+  [(set_attr "op_type" "RS,RSY")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1")])
 
 (define_insn "*tst<mode>_cconly"
   [(set (reg CC_REGNUM)
@@ -657,7 +735,8 @@
   "@
    icm\t%2,<icm_lo>,%S0
    icmy\t%2,<icm_lo>,%S0"
-  [(set_attr "op_type" "RS,RSY")])
+  [(set_attr "op_type" "RS,RSY")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1")])
 
 
 ; Compare (equality) instructions
@@ -665,7 +744,7 @@
 (define_insn "*cmpdi_cct"
   [(set (reg CC_REGNUM)
         (compare (match_operand:DI 0 "nonimmediate_operand" "%d,d,d,d,Q")
-                 (match_operand:DI 1 "general_operand" "d,K,Os,m,BQ")))]
+                 (match_operand:DI 1 "general_operand" "d,K,Os,RT,BQ")))]
   "s390_match_ccmode (insn, CCTmode) && TARGET_64BIT"
   "@
    cgr\t%0,%1
@@ -673,7 +752,8 @@
    cgfi\t%0,%1
    cg\t%0,%1
    #"
-  [(set_attr "op_type" "RRE,RI,RIL,RXY,SS")])
+  [(set_attr "op_type" "RRE,RI,RIL,RXY,SS")
+   (set_attr "z10prop" "z10_super_c,z10_super,z10_super,z10_super,*")])
 
 (define_insn "*cmpsi_cct"
   [(set (reg CC_REGNUM)
@@ -687,97 +767,174 @@
    c\t%0,%1
    cy\t%0,%1
    #"
-  [(set_attr "op_type" "RR,RI,RIL,RX,RXY,SS")])
-
+  [(set_attr "op_type" "RR,RI,RIL,RX,RXY,SS")
+   (set_attr "z10prop" "z10_super,z10_super,z10_super,z10_super,z10_super,*")])
 
 ; Compare (signed) instructions
 
 (define_insn "*cmpdi_ccs_sign"
   [(set (reg CC_REGNUM)
-        (compare (sign_extend:DI (match_operand:SI 1 "nonimmediate_operand" "d,m"))
-                 (match_operand:DI 0 "register_operand" "d,d")))]
+        (compare (sign_extend:DI (match_operand:SI 1 "nonimmediate_operand"
+						     "d,RT,b"))
+                 (match_operand:DI 0 "register_operand" "d, d,d")))]
   "s390_match_ccmode(insn, CCSRmode) && TARGET_64BIT"
   "@
    cgfr\t%0,%1
-   cgf\t%0,%1"
-  [(set_attr "op_type" "RRE,RXY")])
+   cgf\t%0,%1
+   cgfrl\t%0,%1"
+  [(set_attr "op_type"      "RRE,RXY,RIL")
+   (set_attr "z10prop" "z10_c,*,*")
+   (set_attr "type"         "*,*,larl")])
+
+
 
 (define_insn "*cmpsi_ccs_sign"
   [(set (reg CC_REGNUM)
-        (compare (sign_extend:SI (match_operand:HI 1 "memory_operand" "R,T"))
-                 (match_operand:SI 0 "register_operand" "d,d")))]
+        (compare (sign_extend:SI (match_operand:HI 1 "memory_operand" "R,T,b"))
+                 (match_operand:SI 0 "register_operand" "d,d,d")))]
   "s390_match_ccmode(insn, CCSRmode)"
   "@
    ch\t%0,%1
-   chy\t%0,%1"
-  [(set_attr "op_type" "RX,RXY")])
+   chy\t%0,%1
+   chrl\t%0,%1"
+  [(set_attr "op_type"      "RX,RXY,RIL")
+   (set_attr "cpu_facility" "*,*,z10")
+   (set_attr "type"         "*,*,larl")])
 
-; cr, chi, cfi, c, cy, cgr, cghi, cgfi, cg
+(define_insn "*cmphi_ccs_z10"
+  [(set (reg CC_REGNUM)
+        (compare (match_operand:HI 0 "s_operand"         "Q")
+                 (match_operand:HI 1 "immediate_operand" "K")))]
+  "s390_match_ccmode(insn, CCSmode) && TARGET_Z10"
+  "chhsi\t%0,%1"
+  [(set_attr "op_type" "SIL")])
+
+(define_insn "*cmpdi_ccs_signhi_rl"
+  [(set (reg CC_REGNUM)
+	(compare (sign_extend:DI (match_operand:HI 1 "memory_operand" "RT,b"))
+		 (match_operand:GPR 0 "register_operand"  "d,d")))]
+  "s390_match_ccmode(insn, CCSRmode) && TARGET_Z10"
+  "@
+   cgh\t%0,%1
+   cghrl\t%0,%1"
+  [(set_attr "op_type" "RXY,RIL")
+   (set_attr "type"    "*,larl")])
+
+; cr, chi, cfi, c, cy, cgr, cghi, cgfi, cg, chsi, cghsi, crl, cgrl
 (define_insn "*cmp<mode>_ccs"
   [(set (reg CC_REGNUM)
-        (compare (match_operand:GPR 0 "register_operand" "d,d,d,d,d")
-                 (match_operand:GPR 1 "general_operand" "d,K,Os,R,T")))]
+        (compare (match_operand:GPR 0 "nonimmediate_operand"
+                                      "d,d,Q, d,d,d,d")
+                 (match_operand:GPR 1 "general_operand"
+                                      "d,K,K,Os,R,T,b")))]
   "s390_match_ccmode(insn, CCSmode)"
   "@
    c<g>r\t%0,%1
    c<g>hi\t%0,%h1
+   c<g>hsi\t%0,%h1
    c<g>fi\t%0,%1
    c<g>\t%0,%1
-   c<y>\t%0,%1"
-  [(set_attr "op_type" "RR<E>,RI,RIL,RX<Y>,RXY")])
+   c<y>\t%0,%1
+   c<g>rl\t%0,%1"
+  [(set_attr "op_type" "RR<E>,RI,SIL,RIL,RX<Y>,RXY,RIL")
+   (set_attr "cpu_facility" "*,*,z10,extimm,*,*,z10")
+   (set_attr "type" "*,*,*,*,*,*,larl")
+   (set_attr "z10prop" "z10_super_c,z10_super,z10_super,z10_super,z10_super,z10_super,z10_super")])
 
 
 ; Compare (unsigned) instructions
 
+(define_insn "*cmpsi_ccu_zerohi_rlsi"
+  [(set (reg CC_REGNUM)
+ 	(compare (zero_extend:SI (mem:HI (match_operand:SI 1
+					  "larl_operand" "X")))
+		 (match_operand:SI 0 "register_operand" "d")))]
+  "s390_match_ccmode(insn, CCURmode) && TARGET_Z10"
+  "clhrl\t%0,%1"
+  [(set_attr "op_type" "RIL")
+   (set_attr "type"    "larl")])
+
+; clhrl, clghrl
+(define_insn "*cmp<GPR:mode>_ccu_zerohi_rldi"
+  [(set (reg CC_REGNUM)
+ 	(compare (zero_extend:GPR (mem:HI (match_operand:DI 1
+					  "larl_operand" "X")))
+		 (match_operand:GPR 0 "register_operand" "d")))]
+  "s390_match_ccmode(insn, CCURmode) && TARGET_Z10"
+  "cl<g>hrl\t%0,%1"
+  [(set_attr "op_type" "RIL")
+   (set_attr "type"    "larl")
+   (set_attr "z10prop" "z10_super")])
+
 (define_insn "*cmpdi_ccu_zero"
   [(set (reg CC_REGNUM)
-        (compare (zero_extend:DI (match_operand:SI 1 "nonimmediate_operand" "d,m"))
-                 (match_operand:DI 0 "register_operand" "d,d")))]
+        (compare (zero_extend:DI (match_operand:SI 1 "nonimmediate_operand"
+                                                        "d,RT,b"))
+                 (match_operand:DI 0 "register_operand" "d, d,d")))]
   "s390_match_ccmode (insn, CCURmode) && TARGET_64BIT"
   "@
    clgfr\t%0,%1
-   clgf\t%0,%1"
-  [(set_attr "op_type" "RRE,RXY")])
+   clgf\t%0,%1
+   clgfrl\t%0,%1"
+  [(set_attr "op_type"      "RRE,RXY,RIL")
+   (set_attr "cpu_facility" "*,*,z10")
+   (set_attr "type"         "*,*,larl")
+   (set_attr "z10prop" "z10_super_c,z10_super_E1,z10_super")])
 
 (define_insn "*cmpdi_ccu"
   [(set (reg CC_REGNUM)
-        (compare (match_operand:DI 0 "nonimmediate_operand" "d,d,d,Q,BQ")
-                 (match_operand:DI 1 "general_operand" "d,Op,m,BQ,Q")))]
+        (compare (match_operand:DI 0 "nonimmediate_operand"
+                                     "d, d,d,Q, d, Q,BQ")
+                 (match_operand:DI 1 "general_operand"
+                                     "d,Op,b,D,RT,BQ,Q")))]
   "s390_match_ccmode (insn, CCUmode) && TARGET_64BIT"
   "@
    clgr\t%0,%1
    clgfi\t%0,%1
+   clgrl\t%0,%1
+   clghsi\t%0,%x1
    clg\t%0,%1
    #
    #"
-  [(set_attr "op_type" "RRE,RIL,RXY,SS,SS")])
+  [(set_attr "op_type" "RRE,RIL,RIL,SIL,RXY,SS,SS")
+   (set_attr "cpu_facility" "*,extimm,z10,z10,*,*,*")
+   (set_attr "type"         "*,*,larl,*,*,*,*")
+   (set_attr "z10prop" "z10_super_c,z10_super,z10_super,z10_super,z10_super,*,*")])
 
 (define_insn "*cmpsi_ccu"
   [(set (reg CC_REGNUM)
-        (compare (match_operand:SI 0 "nonimmediate_operand" "d,d,d,d,Q,BQ")
-                 (match_operand:SI 1 "general_operand" "d,Os,R,T,BQ,Q")))]
+        (compare (match_operand:SI 0 "nonimmediate_operand" "d, d,d,Q,d,d, Q,BQ")
+                 (match_operand:SI 1 "general_operand"      "d,Os,b,D,R,T,BQ, Q")))]
   "s390_match_ccmode (insn, CCUmode)"
   "@
    clr\t%0,%1
    clfi\t%0,%o1
+   clrl\t%0,%1
+   clfhsi\t%0,%x1
    cl\t%0,%1
    cly\t%0,%1
    #
    #"
-  [(set_attr "op_type" "RR,RIL,RX,RXY,SS,SS")])
+  [(set_attr "op_type" "RR,RIL,RIL,SIL,RX,RXY,SS,SS")
+   (set_attr "cpu_facility" "*,extimm,z10,z10,*,*,*,*")
+   (set_attr "type"         "*,*,larl,*,*,*,*,*")
+   (set_attr "z10prop" "z10_super_c,z10_super,z10_super,z10_super,z10_super,z10_super,*,*")])
 
 (define_insn "*cmphi_ccu"
   [(set (reg CC_REGNUM)
-        (compare (match_operand:HI 0 "nonimmediate_operand" "d,d,Q,BQ")
-                 (match_operand:HI 1 "general_operand" "Q,S,BQ,Q")))]
+        (compare (match_operand:HI 0 "nonimmediate_operand" "d,d,Q,Q,BQ")
+                 (match_operand:HI 1 "general_operand"      "Q,S,D,BQ,Q")))]
   "s390_match_ccmode (insn, CCUmode)
    && !register_operand (operands[1], HImode)"
   "@
    clm\t%0,3,%S1
    clmy\t%0,3,%S1
+   clhhsi\t%0,%1
    #
    #"
-  [(set_attr "op_type" "RS,RSY,SS,SS")])
+  [(set_attr "op_type" "RS,RSY,SIL,SS,SS")
+   (set_attr "cpu_facility" "*,*,z10,*,*")
+   (set_attr "z10prop" "*,*,z10_super,*,*")])
 
 (define_insn "*cmpqi_ccu"
   [(set (reg CC_REGNUM)
@@ -792,7 +949,8 @@
    cliy\t%S0,%b1
    #
    #"
-  [(set_attr "op_type" "RS,RSY,SI,SIY,SS,SS")])
+  [(set_attr "op_type" "RS,RSY,SI,SIY,SS,SS")
+   (set_attr "z10prop" "*,*,z10_super,z10_super,*,*")])
 
 
 ; Block compare (CLC) instruction patterns.
@@ -839,7 +997,7 @@
   "s390_match_ccmode(insn, CCSmode) && TARGET_HARD_FLOAT"
   "lt<xde><bt>r\t%0,%0"
    [(set_attr "op_type" "RRE")
-    (set_attr "type"  "fsimp<bfp>")])
+    (set_attr "type"  "fsimp<mode>")])
 
 ; cxtr, cxbr, cdbr, cebr, cxb, cdb, ceb, cxbtr, cdbtr
 (define_insn "*cmp<mode>_ccs"
@@ -851,7 +1009,66 @@
    c<xde><bt>r\t%0,%1
    c<xde>b\t%0,%1"
    [(set_attr "op_type" "RRE,RXE")
-    (set_attr "type"  "fsimp<bfp>")])
+    (set_attr "type"  "fsimp<mode>")])
+
+
+; Compare and Branch instructions
+
+; cij, cgij, crj, cgrj, cfi, cgfi, cr, cgr
+; The following instructions do a complementary access of their second
+; operand (z01 only): crj_c, cgrjc, cr, cgr
+(define_insn "*cmp_and_br_signed_<mode>"
+  [(set (pc)
+	(if_then_else (match_operator 0 "s390_signed_integer_comparison"
+			[(match_operand:GPR 1 "register_operand"  "d,d")
+			 (match_operand:GPR 2 "nonmemory_operand" "d,C")])
+		      (label_ref (match_operand 3 "" ""))
+		      (pc)))
+   (clobber (reg:CC CC_REGNUM))]
+  "TARGET_Z10"
+{
+  if (get_attr_length (insn) == 6)
+    return which_alternative ?
+      "c<g>ij%C0\t%1,%c2,%l3" : "c<g>rj%C0\t%1,%2,%l3";
+  else
+    return which_alternative ?
+      "c<g>fi\t%1,%c2\;jg%C0\t%l3" : "c<g>r\t%1,%2\;jg%C0\t%l3";
+}
+  [(set_attr "op_type" "RIE")
+   (set_attr "type"    "branch")
+   (set_attr "z10prop" "z10_cobra,z10_super")
+   (set (attr "length")
+        (if_then_else (lt (abs (minus (pc) (match_dup 3))) (const_int 60000))
+                      (const_int 6) (const_int 12)))]) ; 8 byte for cr/jg
+                                                       ; 10 byte for cgr/jg
+
+; clij, clgij, clrj, clgrj, clfi, clgfi, clr, clgr
+; The following instructions do a complementary access of their second
+; operand (z10 only): clrj, clgrj, clr, clgr
+(define_insn "*cmp_and_br_unsigned_<mode>"
+  [(set (pc)
+	(if_then_else (match_operator 0 "s390_unsigned_integer_comparison"
+			[(match_operand:GPR 1 "register_operand"  "d,d")
+			 (match_operand:GPR 2 "nonmemory_operand" "d,I")])
+		      (label_ref (match_operand 3 "" ""))
+		      (pc)))
+   (clobber (reg:CC CC_REGNUM))]
+  "TARGET_Z10"
+{
+  if (get_attr_length (insn) == 6)
+    return which_alternative ?
+      "cl<g>ij%C0\t%1,%b2,%l3" : "cl<g>rj%C0\t%1,%2,%l3";
+  else
+    return which_alternative ?
+      "cl<g>fi\t%1,%b2\;jg%C0\t%l3" : "cl<g>r\t%1,%2\;jg%C0\t%l3";
+}
+  [(set_attr "op_type" "RIE")
+   (set_attr "type"    "branch")
+   (set_attr "z10prop" "z10_cobra,z10_super")
+   (set (attr "length")
+        (if_then_else (lt (abs (minus (pc) (match_dup 3))) (const_int 60000))
+                      (const_int 6) (const_int 12)))]) ; 8 byte for clr/jg
+                                                       ; 10 byte for clgr/jg
 
 ;;
 ;;- Move instructions.
@@ -863,7 +1080,7 @@
 
 (define_insn "movti"
   [(set (match_operand:TI 0 "nonimmediate_operand" "=d,QS,d,o,Q")
-        (match_operand:TI 1 "general_operand" "QS,d,dPm,d,Q"))]
+        (match_operand:TI 1 "general_operand" "QS,d,dPRT,d,Q"))]
   "TARGET_64BIT"
   "@
    lmg\t%0,%N0,%S1
@@ -919,6 +1136,60 @@
 ; Patterns used for secondary reloads
 ;
 
+; z10 provides move instructions accepting larl memory operands.
+; Unfortunately there is no such variant for QI, TI and FP mode moves.
+; These patterns are also used for unaligned SI and DI accesses.
+
+(define_expand "reload<INTALL:mode><P:mode>_tomem_z10"
+  [(parallel [(match_operand:INTALL 0 "memory_operand"   "")
+	      (match_operand:INTALL 1 "register_operand" "=d")
+	      (match_operand:P 2 "register_operand" "=&a")])]
+  "TARGET_Z10"
+{
+  s390_reload_symref_address (operands[1], operands[0], operands[2], 1);
+  DONE;
+})
+
+(define_expand "reload<INTALL:mode><P:mode>_toreg_z10"
+  [(parallel [(match_operand:INTALL 0 "register_operand" "=d")
+	      (match_operand:INTALL 1 "memory_operand"   "")
+	      (match_operand:P 2 "register_operand" "=a")])]
+  "TARGET_Z10"
+{
+  s390_reload_symref_address (operands[0], operands[1], operands[2], 0);
+  DONE;
+})
+
+(define_expand "reload<FPALL:mode><P:mode>_tomem_z10"
+  [(parallel [(match_operand:FPALL 0 "memory_operand"   "")
+	      (match_operand:FPALL 1 "register_operand" "=d")
+	      (match_operand:P 2 "register_operand" "=&a")])]
+  "TARGET_Z10"
+{
+  s390_reload_symref_address (operands[1], operands[0], operands[2], 1);
+  DONE;
+})
+
+(define_expand "reload<FPALL:mode><P:mode>_toreg_z10"
+  [(parallel [(match_operand:FPALL 0 "register_operand" "=d")
+	      (match_operand:FPALL 1 "memory_operand"   "")
+	      (match_operand:P 2 "register_operand" "=a")])]
+  "TARGET_Z10"
+{
+  s390_reload_symref_address (operands[0], operands[1], operands[2], 0);
+  DONE;
+})
+
+(define_expand "reload<P:mode>_larl_odd_addend_z10"
+  [(parallel [(match_operand:P 0 "register_operand" "=d")
+	      (match_operand:P 1 "larl_operand"     "")
+	      (match_operand:P 2 "register_operand" "=a")])]
+  "TARGET_Z10"
+{
+  s390_reload_larl_operand (operands[0], operands[1], operands[2]);
+  DONE;
+})
+
 ; Handles loading a PLUS (load address) expression
 
 (define_expand "reload<mode>_plus"
@@ -984,16 +1255,17 @@
    && !FP_REG_P (operands[0])"
   "larl\t%0,%1"
    [(set_attr "op_type" "RIL")
-    (set_attr "type"    "larl")])
+    (set_attr "type"    "larl")
+    (set_attr "z10prop" "z10_super_A1")])
 
-(define_insn "*movdi_64dfp"
+(define_insn "*movdi_64"
   [(set (match_operand:DI 0 "nonimmediate_operand"
-                            "=d,d,d,d,d,d,d,d,f,d,d,d,d,
-                             m,!*f,!*f,!*f,!R,!T,d,t,Q,t,?Q")
+                            "=d,d,d,d,d,d,d,d,f,d,d,d,d,d,
+                             RT,!*f,!*f,!*f,!R,!T,b,Q,d,t,Q,t,?Q")
         (match_operand:DI 1 "general_operand"
-                            "K,N0HD0,N1HD0,N2HD0,N3HD0,Os,N0SD0,N1SD0,d,f,L,d,m,
-                             d,*f,R,T,*f,*f,t,d,t,Q,?Q"))]
-  "TARGET_64BIT && TARGET_DFP"
+                            "K,N0HD0,N1HD0,N2HD0,N3HD0,Os,N0SD0,N1SD0,d,f,L,b,d,RT,
+                             d,*f,R,T,*f,*f,d,K,t,d,t,Q,?Q"))]
+  "TARGET_64BIT"
   "@
    lghi\t%0,%h1
    llihh\t%0,%i1
@@ -1006,6 +1278,7 @@
    ldgr\t%0,%1
    lgdr\t%0,%1
    lay\t%0,%a1
+   lgrl\t%0,%1
    lgr\t%0,%1
    lg\t%0,%1
    stg\t%1,%0
@@ -1014,80 +1287,49 @@
    ldy\t%0,%1
    std\t%1,%0
    stdy\t%1,%0
+   stgrl\t%1,%0
+   mvghi\t%0,%1
    #
    #
    stam\t%1,%N1,%S0
    lam\t%0,%N0,%S1
    #"
-  [(set_attr "op_type" "RI,RI,RI,RI,RI,RIL,RIL,RIL,RRE,RRE,RXY,RRE,RXY,RXY,
-                        RR,RX,RXY,RX,RXY,*,*,RS,RS,SS")
-   (set_attr "type" "*,*,*,*,*,*,*,*,floaddf,floaddf,la,lr,load,store,
-                     floaddf,floaddf,floaddf,fstoredf,fstoredf,*,*,*,*,*")])
-
-(define_insn "*movdi_64extimm"
-  [(set (match_operand:DI 0 "nonimmediate_operand"
-                            "=d,d,d,d,d,d,d,d,d,d,d,m,!*f,!*f,!*f,!R,!T,d,t,Q,t,?Q")
-        (match_operand:DI 1 "general_operand"
-                            "K,N0HD0,N1HD0,N2HD0,N3HD0,Os,N0SD0,N1SD0,L,d,m,d,*f,R,T,*f,*f,t,d,t,Q,?Q"))]
-  "TARGET_64BIT && TARGET_EXTIMM"
-  "@
-   lghi\t%0,%h1
-   llihh\t%0,%i1
-   llihl\t%0,%i1
-   llilh\t%0,%i1
-   llill\t%0,%i1
-   lgfi\t%0,%1
-   llihf\t%0,%k1
-   llilf\t%0,%k1
-   lay\t%0,%a1
-   lgr\t%0,%1
-   lg\t%0,%1
-   stg\t%1,%0
-   ldr\t%0,%1
-   ld\t%0,%1
-   ldy\t%0,%1
-   std\t%1,%0
-   stdy\t%1,%0
-   #
-   #
-   stam\t%1,%N1,%S0
-   lam\t%0,%N0,%S1
-   #"
-  [(set_attr "op_type" "RI,RI,RI,RI,RI,RIL,RIL,RIL,RXY,RRE,RXY,RXY,
-                        RR,RX,RXY,RX,RXY,*,*,RS,RS,SS")
-   (set_attr "type" "*,*,*,*,*,*,*,*,la,lr,load,store,
-                     floaddf,floaddf,floaddf,fstoredf,fstoredf,*,*,*,*,*")])
-
-(define_insn "*movdi_64"
-  [(set (match_operand:DI 0 "nonimmediate_operand"
-                            "=d,d,d,d,d,d,d,d,m,!*f,!*f,!*f,!R,!T,d,t,Q,t,?Q")
-        (match_operand:DI 1 "general_operand"
-                            "K,N0HD0,N1HD0,N2HD0,N3HD0,L,d,m,d,*f,R,T,*f,*f,t,d,t,Q,?Q"))]
-  "TARGET_64BIT && !TARGET_EXTIMM"
-  "@
-   lghi\t%0,%h1
-   llihh\t%0,%i1
-   llihl\t%0,%i1
-   llilh\t%0,%i1
-   llill\t%0,%i1
-   lay\t%0,%a1
-   lgr\t%0,%1
-   lg\t%0,%1
-   stg\t%1,%0
-   ldr\t%0,%1
-   ld\t%0,%1
-   ldy\t%0,%1
-   std\t%1,%0
-   stdy\t%1,%0
-   #
-   #
-   stam\t%1,%N1,%S0
-   lam\t%0,%N0,%S1
-   #"
-  [(set_attr "op_type" "RI,RI,RI,RI,RI,RXY,RRE,RXY,RXY,
-                        RR,RX,RXY,RX,RXY,*,*,RS,RS,SS")
-   (set_attr "type" "*,*,*,*,*,la,lr,load,store,
-                     floaddf,floaddf,floaddf,fstoredf,fstoredf,*,*,*,*,*")])
+  [(set_attr "op_type" "RI,RI,RI,RI,RI,RIL,RIL,RIL,RRE,RRE,RXY,RIL,RRE,RXY,
+                        RXY,RR,RX,RXY,RX,RXY,RIL,SIL,*,*,RS,RS,SS")
+   (set_attr "type" "*,*,*,*,*,*,*,*,floaddf,floaddf,la,larl,lr,load,store,
+                     floaddf,floaddf,floaddf,fstoredf,fstoredf,larl,*,*,*,
+                     *,*,*")
+   (set_attr "cpu_facility" "*,*,*,*,*,extimm,extimm,extimm,dfp,dfp,longdisp,
+                             z10,*,*,*,*,*,longdisp,*,longdisp,
+                             z10,z10,*,*,*,*,*")
+   (set_attr "z10prop" "z10_fwd_A1,
+                        z10_fwd_E1,
+                        z10_fwd_E1,
+                        z10_fwd_E1,
+                        z10_fwd_E1,
+                        z10_fwd_A1,
+                        z10_fwd_E1,
+                        z10_fwd_E1,
+                        *,
+                        *,
+                        z10_fwd_A1,
+                        z10_fwd_A3,
+                        z10_fr_E1,
+                        z10_fwd_A3,
+                        z10_rec,
+                        *,
+                        *,
+                        *,
+                        *,
+                        *,
+                        z10_rec,
+                        z10_super,
+                        *,
+                        *,
+                        *,
+                        *,
+                        *")
+])
 
 (define_split
   [(set (match_operand:DI 0 "register_operand" "")
@@ -1123,8 +1365,10 @@
    s390_split_access_reg (operands[0], &operands[3], &operands[4]);")
 
 (define_insn "*movdi_31"
-  [(set (match_operand:DI 0 "nonimmediate_operand" "=d,d,Q,S,d,o,!*f,!*f,!*f,!R,!T,Q")
-        (match_operand:DI 1 "general_operand" "Q,S,d,d,dPm,d,*f,R,T,*f,*f,Q"))]
+  [(set (match_operand:DI 0 "nonimmediate_operand"
+                            "=d,d,Q,S,d   ,o,!*f,!*f,!*f,!R,!T,Q,d")
+        (match_operand:DI 1 "general_operand"
+                            " Q,S,d,d,dPRT,d, *f,  R,  T,*f,*f,Q,b"))]
   "!TARGET_64BIT"
   "@
    lm\t%0,%N0,%S1
@@ -1138,9 +1382,26 @@
    ldy\t%0,%1
    std\t%1,%0
    stdy\t%1,%0
+   #
    #"
-  [(set_attr "op_type" "RS,RSY,RS,RSY,*,*,RR,RX,RXY,RX,RXY,SS")
-   (set_attr "type" "lm,lm,stm,stm,*,*,floaddf,floaddf,floaddf,fstoredf,fstoredf,*")])
+  [(set_attr "op_type" "RS,RSY,RS,RSY,*,*,RR,RX,RXY,RX,RXY,SS,*")
+   (set_attr "type" "lm,lm,stm,stm,*,*,floaddf,floaddf,floaddf,fstoredf,fstoredf,*,*")
+   (set_attr "cpu_facility" "*,*,*,*,*,*,*,*,*,*,*,*,z10")])
+
+; For a load from a symbol ref we can use one of the target registers
+; together with larl to load the address.
+(define_split
+  [(set (match_operand:DI 0 "register_operand" "")
+        (match_operand:DI 1 "memory_operand" ""))]
+  "!TARGET_64BIT && reload_completed && TARGET_Z10
+   && larl_operand (XEXP (operands[1], 0), SImode)"
+  [(set (match_dup 2) (match_dup 3))
+   (set (match_dup 0) (match_dup 1))]
+{
+  operands[2] = operand_subword (operands[0], 1, 0, DImode);
+  operands[3] = XEXP (operands[1], 0);
+  operands[1] = replace_equiv_address (operands[1], operands[2]);
+})
 
 (define_split
   [(set (match_operand:DI 0 "nonimmediate_operand" "")
@@ -1203,7 +1464,8 @@
    la\t%0,%a1
    lay\t%0,%a1"
   [(set_attr "op_type" "RX,RXY")
-   (set_attr "type"    "la")])
+   (set_attr "type"    "la")
+   (set_attr "z10prop" "z10_fwd_A1,z10_fwd_A1")])
 
 (define_peephole2
   [(parallel
@@ -1254,13 +1516,14 @@
    && !FP_REG_P (operands[0])"
   "larl\t%0,%1"
    [(set_attr "op_type" "RIL")
-    (set_attr "type"    "larl")])
+    (set_attr "type"    "larl")
+    (set_attr "z10prop" "z10_super_A1")])
 
 (define_insn "*movsi_zarch"
   [(set (match_operand:SI 0 "nonimmediate_operand"
-			    "=d,d,d,d,d,d,d,d,R,T,!*f,!*f,!*f,!R,!T,d,t,Q,t,?Q")
+			    "=d,d,d,d,d,d,d,d,d,R,T,!*f,!*f,!*f,!R,!T,d,t,Q,b,Q,t,?Q")
         (match_operand:SI 1 "general_operand"
-			    "K,N0HS0,N1HS0,Os,L,d,R,T,d,d,*f,R,T,*f,*f,t,d,t,Q,?Q"))]
+			    "K,N0HS0,N1HS0,Os,L,b,d,R,T,d,d,*f,R,T,*f,*f,t,d,t,d,K,Q,?Q"))]
   "TARGET_ZARCH"
   "@
    lhi\t%0,%h1
@@ -1268,6 +1531,7 @@
    llill\t%0,%i1
    iilf\t%0,%o1
    lay\t%0,%a1
+   lrl\t%0,%1
    lr\t%0,%1
    l\t%0,%1
    ly\t%0,%1
@@ -1281,12 +1545,60 @@
    ear\t%0,%1
    sar\t%0,%1
    stam\t%1,%1,%S0
+   strl\t%1,%0
+   mvhi\t%0,%1
    lam\t%0,%0,%S1
    #"
-  [(set_attr "op_type" "RI,RI,RI,RIL,RXY,RR,RX,RXY,RX,RXY,
-                        RR,RX,RXY,RX,RXY,RRE,RRE,RS,RS,SS")
-   (set_attr "type" "*,*,*,*,la,lr,load,load,store,store,
-                     floadsf,floadsf,floadsf,fstoresf,fstoresf,*,*,*,*,*")])
+  [(set_attr "op_type" "RI,RI,RI,RIL,RXY,RIL,RR,RX,RXY,RX,RXY,
+                        RR,RX,RXY,RX,RXY,RRE,RRE,RS,RIL,SIL,RS,SS")
+   (set_attr "type" "*,
+                     *,
+                     *,
+                     *,
+                     la,
+                     larl,
+                     lr,
+                     load,
+                     load,
+                     store,
+                     store,
+                     floadsf,
+                     floadsf,
+                     floadsf,
+                     fstoresf,
+                     fstoresf,
+                     *,
+                     *,
+                     *,
+                     larl,
+                     *,
+                     *,
+                     *")
+   (set_attr "cpu_facility" "*,*,*,extimm,longdisp,z10,*,*,longdisp,*,longdisp,
+                             *,*,longdisp,*,longdisp,*,*,*,z10,z10,*,*")
+   (set_attr "z10prop" "z10_fwd_A1,
+                        z10_fwd_E1,
+                        z10_fwd_E1,
+                        z10_fwd_A1,
+                        z10_fwd_A1,
+                        z10_fwd_A3,
+                        z10_fr_E1,
+                        z10_fwd_A3,
+                        z10_fwd_A3,
+                        z10_super,
+                        z10_rec,
+                        *,
+                        *,
+                        *,
+                        *,
+                        *,
+                        z10_super_E1,
+                        z10_super,
+                        *,
+                        z10_rec,
+                        z10_super,
+                        *,
+                        *")])
 
 (define_insn "*movsi_esa"
   [(set (match_operand:SI 0 "nonimmediate_operand" "=d,d,d,R,!*f,!*f,!R,d,t,Q,t,?Q")
@@ -1306,7 +1618,20 @@
    lam\t%0,%0,%S1
    #"
   [(set_attr "op_type" "RI,RR,RX,RX,RR,RX,RX,RRE,RRE,RS,RS,SS")
-   (set_attr "type" "*,lr,load,store,floadsf,floadsf,fstoresf,*,*,*,*,*")])
+   (set_attr "type" "*,lr,load,store,floadsf,floadsf,fstoresf,*,*,*,*,*")
+   (set_attr "z10prop" "z10_fwd_A1,
+                        z10_fr_E1,
+                        z10_fwd_A3,
+                        z10_super,
+                        *,
+                        *,
+                        *,
+                        z10_super_E1,
+                        z10_super,
+                        *,
+                        *,
+                        *")
+])
 
 (define_peephole2
   [(set (match_operand:SI 0 "register_operand" "")
@@ -1327,7 +1652,8 @@
    la\t%0,%a1
    lay\t%0,%a1"
   [(set_attr "op_type"  "RX,RXY")
-   (set_attr "type"     "la")])
+   (set_attr "type"     "la")
+   (set_attr "z10prop" "z10_fwd_A1,z10_fwd_A1")])
 
 (define_peephole2
   [(parallel
@@ -1362,7 +1688,8 @@
    la\t%0,%a1
    lay\t%0,%a1"
   [(set_attr "op_type"  "RX,RXY")
-   (set_attr "type"     "la")])
+   (set_attr "type"     "la")
+   (set_attr "z10prop" "z10_fwd_A1,z10_fwd_A1")])
 
 (define_insn_and_split "*la_31_and_cc"
   [(set (match_operand:SI 0 "register_operand" "=d")
@@ -1387,7 +1714,8 @@
    la\t%0,%a1
    lay\t%0,%a1"
   [(set_attr "op_type"  "RX")
-   (set_attr "type"     "la")])
+   (set_attr "type"     "la")
+   (set_attr "z10prop" "z10_fwd_A1,z10_fwd_A1")])
 
 ;
 ; movhi instruction pattern(s).
@@ -1412,19 +1740,33 @@
 })
 
 (define_insn "*movhi"
-  [(set (match_operand:HI 0 "nonimmediate_operand" "=d,d,d,d,R,T,?Q")
-        (match_operand:HI 1 "general_operand" "d,n,R,T,d,d,?Q"))]
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=d,d,d,d,d,R,T,b,Q,?Q")
+        (match_operand:HI 1 "general_operand"      " d,n,R,T,b,d,d,d,K,?Q"))]
   ""
   "@
    lr\t%0,%1
    lhi\t%0,%h1
    lh\t%0,%1
    lhy\t%0,%1
+   lhrl\t%0,%1
    sth\t%1,%0
    sthy\t%1,%0
+   sthrl\t%1,%0
+   mvhhi\t%0,%1
    #"
-  [(set_attr "op_type" "RR,RI,RX,RXY,RX,RXY,SS")
-   (set_attr "type" "lr,*,*,*,store,store,*")])
+  [(set_attr "op_type"      "RR,RI,RX,RXY,RIL,RX,RXY,RIL,SIL,SS")
+   (set_attr "type"         "lr,*,*,*,larl,store,store,store,*,*")
+   (set_attr "cpu_facility" "*,*,*,*,z10,*,*,z10,z10,*")
+   (set_attr "z10prop" "z10_fr_E1,
+                       z10_fwd_A1,
+                       z10_super_E1,
+                       z10_super_E1,
+                       z10_super_E1,
+                       z10_super,
+                       z10_rec,
+                       z10_rec,
+                       z10_super,
+                       *")])
 
 (define_peephole2
   [(set (match_operand:HI 0 "register_operand" "")
@@ -1473,7 +1815,16 @@
    mviy\t%S0,%b1
    #"
   [(set_attr "op_type" "RR,RI,RX,RXY,RX,RXY,SI,SIY,SS")
-   (set_attr "type" "lr,*,*,*,store,store,store,store,*")])
+   (set_attr "type" "lr,*,*,*,store,store,store,store,*")
+   (set_attr "z10prop" "z10_fr_E1,
+                        z10_fwd_A1,
+                        z10_super_E1,
+                        z10_super_E1,
+                        z10_super,
+                        z10_rec,
+                        z10_super,
+                        z10_super,
+                        *")])
 
 (define_peephole2
   [(set (match_operand:QI 0 "nonimmediate_operand" "")
@@ -1496,7 +1847,8 @@
   "@
    ic\t%0,%1
    icy\t%0,%1"
-  [(set_attr "op_type"  "RX,RXY")])
+  [(set_attr "op_type"  "RX,RXY")
+   (set_attr "z10prop" "z10_super_E1,z10_super")])
 
 ;
 ; movstricthi instruction pattern(s).
@@ -1510,7 +1862,8 @@
   "@
    icm\t%0,3,%S1
    icmy\t%0,3,%S1"
-  [(set_attr "op_type" "RS,RSY")])
+  [(set_attr "op_type" "RS,RSY")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1")])
 
 ;
 ; movstrictsi instruction pattern(s).
@@ -1526,7 +1879,8 @@
    ly\t%0,%1
    ear\t%0,%1"
   [(set_attr "op_type" "RR,RX,RXY,RRE")
-   (set_attr "type" "lr,load,load,*")])
+   (set_attr "type" "lr,load,load,*")
+   (set_attr "z10prop" "z10_fr_E1,z10_fwd_A3,z10_fwd_A3,z10_super_E1")])
 
 ;
 ; mov(tf|td) instruction pattern(s).
@@ -1540,7 +1894,7 @@
 
 (define_insn "*mov<mode>_64"
   [(set (match_operand:TD_TF 0 "nonimmediate_operand" "=f,f,f,o, d,QS, d,o,Q")
-        (match_operand:TD_TF 1 "general_operand"      " G,f,o,f,QS, d,dm,d,Q"))]
+        (match_operand:TD_TF 1 "general_operand"      " G,f,o,f,QS, d,dRT,d,Q"))]
   "TARGET_64BIT"
   "@
    lzxr\t%0
@@ -1616,7 +1970,7 @@
 (define_split
   [(set (match_operand:TD_TF 0 "register_operand" "")
         (match_operand:TD_TF 1 "memory_operand" ""))]
-  "reload_completed && offsettable_memref_p (operands[1]) 
+  "reload_completed && offsettable_memref_p (operands[1])
    && FP_REG_P (operands[0])"
   [(set (match_dup 2) (match_dup 4))
    (set (match_dup 3) (match_dup 5))]
@@ -1657,9 +2011,9 @@
 
 (define_insn "*mov<mode>_64dfp"
   [(set (match_operand:DD_DF 0 "nonimmediate_operand"
-			       "=f,f,f,d,f,f,R,T,d,d,m,?Q")
+			       "=f,f,f,d,f,f,R,T,d,d,RT,?Q")
         (match_operand:DD_DF 1 "general_operand"
-			       "G,f,d,f,R,T,f,f,d,m,d,?Q"))]
+			       "G,f,d,f,R,T,f,f,d,RT,d,?Q"))]
   "TARGET_64BIT && TARGET_DFP"
   "@
    lzdr\t%0
@@ -1676,11 +2030,24 @@
    #"
   [(set_attr "op_type" "RRE,RR,RRE,RRE,RX,RXY,RX,RXY,RRE,RXY,RXY,SS")
    (set_attr "type" "fsimpdf,floaddf,floaddf,floaddf,floaddf,floaddf,
-                     fstoredf,fstoredf,lr,load,store,*")])
+                     fstoredf,fstoredf,lr,load,store,*")
+   (set_attr "z10prop" "*,
+                        *,
+                        *,
+                        *,
+                        *,
+                        *,
+                        *,
+                        *,
+                        z10_fr_E1,
+                        z10_fwd_A3,
+                        z10_rec,
+                        *")
+])
 
 (define_insn "*mov<mode>_64"
-  [(set (match_operand:DD_DF 0 "nonimmediate_operand" "=f,f,f,f,R,T,d,d,m,?Q")
-        (match_operand:DD_DF 1 "general_operand"       "G,f,R,T,f,f,d,m,d,?Q"))]
+  [(set (match_operand:DD_DF 0 "nonimmediate_operand" "=f,f,f,f,R,T,d, d,RT,?Q")
+        (match_operand:DD_DF 1 "general_operand"       "G,f,R,T,f,f,d,RT, d,?Q"))]
   "TARGET_64BIT"
   "@
    lzdr\t%0
@@ -1694,14 +2061,24 @@
    stg\t%1,%0
    #"
   [(set_attr "op_type" "RRE,RR,RX,RXY,RX,RXY,RRE,RXY,RXY,SS")
-   (set_attr "type" "fsimp<bfp>,fload<bfp>,fload<bfp>,fload<bfp>,
-                     fstore<bfp>,fstore<bfp>,lr,load,store,*")])
+   (set_attr "type" "fsimp<mode>,fload<mode>,fload<mode>,fload<mode>,
+                     fstore<mode>,fstore<mode>,lr,load,store,*")
+   (set_attr "z10prop" "*,
+                        *,
+                        *,
+                        *,
+                        *,
+                        *,
+                        z10_fr_E1,
+                        z10_fwd_A3,
+                        z10_rec,
+                        *")])
 
 (define_insn "*mov<mode>_31"
   [(set (match_operand:DD_DF 0 "nonimmediate_operand"
-                               "=f,f,f,f,R,T,d,d,Q,S,  d,o,Q")
+                               "=f,f,f,f,R,T,d,d,Q,S,   d,o,Q")
         (match_operand:DD_DF 1 "general_operand"
-                               " G,f,R,T,f,f,Q,S,d,d,dPm,d,Q"))]
+                               " G,f,R,T,f,f,Q,S,d,d,dPRT,d,Q"))]
   "!TARGET_64BIT"
   "@
    lzdr\t%0
@@ -1718,8 +2095,8 @@
    #
    #"
   [(set_attr "op_type" "RRE,RR,RX,RXY,RX,RXY,RS,RSY,RS,RSY,*,*,SS")
-   (set_attr "type" "fsimp<bfp>,fload<bfp>,fload<bfp>,fload<bfp>,
-                     fstore<bfp>,fstore<bfp>,lm,lm,stm,stm,*,*,*")])
+   (set_attr "type" "fsimp<mode>,fload<mode>,fload<mode>,fload<mode>,
+                     fstore<mode>,fstore<mode>,lm,lm,stm,stm,*,*,*")])
 
 (define_split
   [(set (match_operand:DD_DF 0 "nonimmediate_operand" "")
@@ -1786,8 +2163,20 @@
    sty\t%1,%0
    #"
   [(set_attr "op_type" "RRE,RR,RX,RXY,RX,RXY,RR,RX,RXY,RX,RXY,SS")
-   (set_attr "type" "fsimp<bfp>,fload<bfp>,fload<bfp>,fload<bfp>,
-                     fstore<bfp>,fstore<bfp>,lr,load,load,store,store,*")])
+   (set_attr "type" "fsimp<mode>,fload<mode>,fload<mode>,fload<mode>,
+                     fstore<mode>,fstore<mode>,lr,load,load,store,store,*")
+   (set_attr "z10prop" "*,
+                        *,
+                        *,
+                        *,
+                        *,
+                        *,
+                        z10_fr_E1,
+                        z10_fwd_A3,
+                        z10_fwd_A3,
+                        z10_super,
+                        z10_rec,
+                        *")])
 
 ;
 ; movcc instruction pattern
@@ -1806,7 +2195,8 @@
    l\t%1,%0
    ly\t%1,%0"
   [(set_attr "op_type" "RR,RI,RRE,RX,RXY,RX,RXY")
-   (set_attr "type" "lr,*,*,store,store,load,load")])
+   (set_attr "type" "lr,*,*,store,store,load,load")
+   (set_attr "z10prop" "z10_fr_E1,*,*,z10_super,z10_rec,z10_fwd_A3,z10_fwd_A3")])
 
 ;
 ; Block move (MVC) patterns.
@@ -1846,7 +2236,7 @@
      (use (match_operand 5 "const_int_operand" ""))])]
   "s390_offset_p (operands[0], operands[3], operands[2])
    && s390_offset_p (operands[1], operands[4], operands[2])
-   && !s390_overlap_p (operands[0], operands[1], 
+   && !s390_overlap_p (operands[0], operands[1],
                        INTVAL (operands[2]) + INTVAL (operands[5]))
    && INTVAL (operands[2]) + INTVAL (operands[5]) <= 256"
   [(parallel
@@ -2045,6 +2435,17 @@
 ;; String instructions.
 ;;
 
+(define_insn "*execute_rl"
+  [(match_parallel 0 ""
+    [(unspec [(match_operand 1    "register_operand" "a")
+	      (match_operand 2    "" "")
+              (match_operand:SI 3 "larl_operand" "X")] UNSPEC_EXECUTE)])]
+  "TARGET_Z10 && GET_MODE_CLASS (GET_MODE (operands[1])) == MODE_INT
+   && GET_MODE_SIZE (GET_MODE (operands[1])) <= UNITS_PER_WORD"
+  "exrl\t%1,%3"
+  [(set_attr "op_type" "RIL")
+   (set_attr "type"    "cs")])
+
 (define_insn "*execute"
   [(match_parallel 0 ""
     [(unspec [(match_operand 1 "register_operand" "a")
@@ -2141,19 +2542,19 @@
   "clst\t%0,%1\;jo\t.-4"
   [(set_attr "length" "8")
    (set_attr "type" "vs")])
- 
+
 ;
 ; movstr instruction pattern.
 ;
 
 (define_expand "movstr"
   [(set (reg:SI 0) (const_int 0))
-   (parallel 
+   (parallel
     [(clobber (match_dup 3))
      (set (match_operand:BLK 1 "memory_operand" "")
 	  (match_operand:BLK 2 "memory_operand" ""))
      (set (match_operand 0 "register_operand" "")
-	  (unspec [(match_dup 1) 
+	  (unspec [(match_dup 1)
 		   (match_dup 2)
 		   (reg:SI 0)] UNSPEC_MVST))
      (clobber (reg:CC CC_REGNUM))])]
@@ -2174,7 +2575,7 @@
    (set (mem:BLK (match_operand:P 1 "register_operand" "0"))
 	(mem:BLK (match_operand:P 3 "register_operand" "2")))
    (set (match_operand:P 0 "register_operand" "=d")
-	(unspec [(mem:BLK (match_dup 1)) 
+	(unspec [(mem:BLK (match_dup 1))
 		 (mem:BLK (match_dup 3))
 		 (reg:SI 0)] UNSPEC_MVST))
    (clobber (reg:CC CC_REGNUM))]
@@ -2182,16 +2583,16 @@
   "mvst\t%1,%2\;jo\t.-4"
   [(set_attr "length" "8")
    (set_attr "type" "vs")])
-  
+
 
 ;
 ; movmemM instruction pattern(s).
 ;
 
 (define_expand "movmem<mode>"
-  [(set (match_operand:BLK 0 "memory_operand" "")
-        (match_operand:BLK 1 "memory_operand" ""))
-   (use (match_operand:GPR 2 "general_operand" ""))
+  [(set (match_operand:BLK 0 "memory_operand" "")   ; destination
+        (match_operand:BLK 1 "memory_operand" ""))  ; source
+   (use (match_operand:GPR 2 "general_operand" "")) ; count
    (match_operand 3 "" "")]
   ""
   "s390_expand_movmem (operands[0], operands[1], operands[2]); DONE;")
@@ -2210,15 +2611,16 @@
   "operands[3] = gen_rtx_SCRATCH (Pmode);")
 
 (define_insn "*movmem_short"
-  [(set (match_operand:BLK 0 "memory_operand" "=Q,Q,Q")
-        (match_operand:BLK 1 "memory_operand" "Q,Q,Q"))
-   (use (match_operand 2 "nonmemory_operand" "n,a,a"))
-   (use (match_operand 3 "immediate_operand" "X,R,X"))
-   (clobber (match_scratch 4 "=X,X,&a"))]
+  [(set (match_operand:BLK 0 "memory_operand" "=Q,Q,Q,Q")
+        (match_operand:BLK 1 "memory_operand" "Q,Q,Q,Q"))
+   (use (match_operand 2 "nonmemory_operand" "n,a,a,a"))
+   (use (match_operand 3 "immediate_operand" "X,R,X,X"))
+   (clobber (match_scratch 4 "=X,X,X,&a"))]
   "(GET_MODE (operands[2]) == Pmode || GET_MODE (operands[2]) == VOIDmode)
    && GET_MODE (operands[4]) == Pmode"
   "#"
-  [(set_attr "type" "cs")])
+  [(set_attr "type"         "cs")
+   (set_attr "cpu_facility" "*,*,z10,*")])
 
 (define_split
   [(set (match_operand:BLK 0 "memory_operand" "")
@@ -2246,6 +2648,20 @@
      (use (const_int 1))])]
   "")
 
+(define_split
+  [(set (match_operand:BLK 0 "memory_operand" "")
+        (match_operand:BLK 1 "memory_operand" ""))
+   (use (match_operand 2 "register_operand" ""))
+   (use (const:BLK (unspec:BLK [(const_int 0)] UNSPEC_INSN)))
+   (clobber (scratch))]
+  "TARGET_Z10 && reload_completed"
+  [(parallel
+    [(unspec [(match_dup 2) (const_int 0)
+              (label_ref (match_dup 3))] UNSPEC_EXECUTE)
+     (set (match_dup 0) (match_dup 1))
+     (use (const_int 1))])]
+  "operands[3] = gen_label_rtx ();")
+
 (define_split
   [(set (match_operand:BLK 0 "memory_operand" "")
         (match_operand:BLK 1 "memory_operand" ""))
@@ -2255,7 +2671,7 @@
   "reload_completed && TARGET_CPU_ZARCH"
   [(set (match_dup 3) (label_ref (match_dup 4)))
    (parallel
-    [(unspec [(match_dup 2) (mem:BLK (match_dup 3)) 
+    [(unspec [(match_dup 2) (mem:BLK (match_dup 3))
               (label_ref (match_dup 4))] UNSPEC_EXECUTE)
      (set (match_dup 0) (match_dup 1))
      (use (const_int 1))])]
@@ -2316,8 +2732,8 @@
 
 (define_expand "signbit<mode>2"
   [(set (reg:CCZ CC_REGNUM)
-        (unspec:CCZ [(match_operand:FP_ALL 1 "register_operand" "f") 
-                     (match_dup 2)] 
+        (unspec:CCZ [(match_operand:FP_ALL 1 "register_operand" "f")
+                     (match_dup 2)]
                      UNSPEC_TDC_INSN))
    (set (match_operand:SI 0 "register_operand" "=d")
         (unspec:SI [(reg:CCZ CC_REGNUM)] UNSPEC_CCZ_TO_INT))]
@@ -2328,8 +2744,8 @@
 
 (define_expand "isinf<mode>2"
   [(set (reg:CCZ CC_REGNUM)
-        (unspec:CCZ [(match_operand:FP_ALL 1 "register_operand" "f") 
-                     (match_dup 2)] 
+        (unspec:CCZ [(match_operand:FP_ALL 1 "register_operand" "f")
+                     (match_dup 2)]
                      UNSPEC_TDC_INSN))
    (set (match_operand:SI 0 "register_operand" "=d")
         (unspec:SI [(reg:CCZ CC_REGNUM)] UNSPEC_CCZ_TO_INT))]
@@ -2341,16 +2757,16 @@
 ; This insn is used to generate all variants of the Test Data Class
 ; instruction, namely tcxb, tcdb, and tceb.  The insn's first operand
 ; is the register to be tested and the second one is the bit mask
-; specifying the required test(s).  
+; specifying the required test(s).
 ;
 (define_insn "*TDC_insn_<mode>"
   [(set (reg:CCZ CC_REGNUM)
-        (unspec:CCZ [(match_operand:FP_ALL 0 "register_operand" "f") 
+        (unspec:CCZ [(match_operand:FP_ALL 0 "register_operand" "f")
                      (match_operand:SI 1 "const_int_operand")] UNSPEC_TDC_INSN))]
   "TARGET_HARD_FLOAT"
   "t<_d>c<xde><bt>\t%0,%1"
    [(set_attr "op_type" "RXE")
-    (set_attr "type"  "fsimp<bfp>")])
+    (set_attr "type"  "fsimp<mode>")])
 
 (define_insn_and_split "*ccz_to_int"
   [(set (match_operand:SI 0 "register_operand" "=d")
@@ -2389,16 +2805,17 @@
   "operands[2] = gen_rtx_SCRATCH (Pmode);")
 
 (define_insn "*clrmem_short"
-  [(set (match_operand:BLK 0 "memory_operand" "=Q,Q,Q")
+  [(set (match_operand:BLK 0 "memory_operand" "=Q,Q,Q,Q")
         (const_int 0))
-   (use (match_operand 1 "nonmemory_operand" "n,a,a"))
-   (use (match_operand 2 "immediate_operand" "X,R,X"))
-   (clobber (match_scratch 3 "=X,X,&a"))
+   (use (match_operand 1 "nonmemory_operand" "n,a,a,a"))
+   (use (match_operand 2 "immediate_operand" "X,R,X,X"))
+   (clobber (match_scratch 3 "=X,X,X,&a"))
    (clobber (reg:CC CC_REGNUM))]
   "(GET_MODE (operands[1]) == Pmode || GET_MODE (operands[1]) == VOIDmode)
    && GET_MODE (operands[3]) == Pmode"
   "#"
-  [(set_attr "type" "cs")])
+  [(set_attr "type" "cs")
+   (set_attr "cpu_facility" "*,*,z10,*")])
 
 (define_split
   [(set (match_operand:BLK 0 "memory_operand" "")
@@ -2430,6 +2847,22 @@
      (clobber (reg:CC CC_REGNUM))])]
   "")
 
+(define_split
+  [(set (match_operand:BLK 0 "memory_operand" "")
+        (const_int 0))
+   (use (match_operand 1 "register_operand" ""))
+   (use (const:BLK (unspec:BLK [(const_int 0)] UNSPEC_INSN)))
+   (clobber (scratch))
+   (clobber (reg:CC CC_REGNUM))]
+  "TARGET_Z10 && reload_completed"
+  [(parallel
+    [(unspec [(match_dup 1) (const_int 0)
+              (label_ref (match_dup 3))] UNSPEC_EXECUTE)
+     (set (match_dup 0) (const_int 0))
+     (use (const_int 1))
+     (clobber (reg:CC CC_REGNUM))])]
+  "operands[3] = gen_label_rtx ();")
+
 (define_split
   [(set (match_operand:BLK 0 "memory_operand" "")
         (const_int 0))
@@ -2440,14 +2873,14 @@
   "reload_completed && TARGET_CPU_ZARCH"
   [(set (match_dup 2) (label_ref (match_dup 3)))
    (parallel
-    [(unspec [(match_dup 1) (mem:BLK (match_dup 2)) 
+    [(unspec [(match_dup 1) (mem:BLK (match_dup 2))
               (label_ref (match_dup 3))] UNSPEC_EXECUTE)
      (set (match_dup 0) (const_int 0))
      (use (const_int 1))
      (clobber (reg:CC CC_REGNUM))])]
   "operands[3] = gen_label_rtx ();")
 
-; Initialize a block of arbitrary length with (operands[2] % 256). 
+; Initialize a block of arbitrary length with (operands[2] % 256).
 
 (define_expand "setmem_long"
   [(parallel
@@ -2530,15 +2963,16 @@
 
 (define_insn "*cmpmem_short"
   [(set (reg:CCU CC_REGNUM)
-        (compare:CCU (match_operand:BLK 0 "memory_operand" "Q,Q,Q")
-                     (match_operand:BLK 1 "memory_operand" "Q,Q,Q")))
-   (use (match_operand 2 "nonmemory_operand" "n,a,a"))
-   (use (match_operand 3 "immediate_operand" "X,R,X"))
-   (clobber (match_scratch 4 "=X,X,&a"))]
+        (compare:CCU (match_operand:BLK 0 "memory_operand" "Q,Q,Q,Q")
+                     (match_operand:BLK 1 "memory_operand" "Q,Q,Q,Q")))
+   (use (match_operand 2 "nonmemory_operand" "n,a,a,a"))
+   (use (match_operand 3 "immediate_operand" "X,R,X,X"))
+   (clobber (match_scratch 4 "=X,X,X,&a"))]
   "(GET_MODE (operands[2]) == Pmode || GET_MODE (operands[2]) == VOIDmode)
    && GET_MODE (operands[4]) == Pmode"
   "#"
-  [(set_attr "type" "cs")])
+  [(set_attr "type" "cs")
+   (set_attr "cpu_facility" "*,*,z10,*")])
 
 (define_split
   [(set (reg:CCU CC_REGNUM)
@@ -2568,6 +3002,21 @@
      (use (const_int 1))])]
   "")
 
+(define_split
+  [(set (reg:CCU CC_REGNUM)
+        (compare:CCU (match_operand:BLK 0 "memory_operand" "")
+                     (match_operand:BLK 1 "memory_operand" "")))
+   (use (match_operand 2 "register_operand" ""))
+   (use (const:BLK (unspec:BLK [(const_int 0)] UNSPEC_INSN)))
+   (clobber (scratch))]
+  "TARGET_Z10 && reload_completed"
+  [(parallel
+    [(unspec [(match_dup 2) (const_int 0)
+              (label_ref (match_dup 4))] UNSPEC_EXECUTE)
+     (set (reg:CCU CC_REGNUM) (compare:CCU (match_dup 0) (match_dup 1)))
+     (use (const_int 1))])]
+  "operands[4] = gen_label_rtx ();")
+
 (define_split
   [(set (reg:CCU CC_REGNUM)
         (compare:CCU (match_operand:BLK 0 "memory_operand" "")
@@ -2578,7 +3027,7 @@
   "reload_completed && TARGET_CPU_ZARCH"
   [(set (match_dup 3) (label_ref (match_dup 4)))
    (parallel
-    [(unspec [(match_dup 2) (mem:BLK (match_dup 3)) 
+    [(unspec [(match_dup 2) (mem:BLK (match_dup 3))
               (label_ref (match_dup 4))] UNSPEC_EXECUTE)
      (set (reg:CCU CC_REGNUM) (compare:CCU (match_dup 0) (match_dup 1)))
      (use (const_int 1))])]
@@ -2683,7 +3132,7 @@
 
 (define_insn_and_split "*cmpint_sign_cc"
   [(set (reg CC_REGNUM)
-        (compare (ashiftrt:DI (ashift:DI (subreg:DI 
+        (compare (ashiftrt:DI (ashift:DI (subreg:DI
                    (unspec:SI [(match_operand:CCU 1 "register_operand" "0")]
                               UNSPEC_CCU_TO_INT) 0)
                    (const_int 32)) (const_int 32))
@@ -2717,7 +3166,8 @@
   "@
    icm\t%0,%2,%S1
    icmy\t%0,%2,%S1"
-  [(set_attr "op_type" "RS,RSY")])
+  [(set_attr "op_type" "RS,RSY")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1")])
 
 (define_insn "*sethighpartdi_64"
   [(set (match_operand:DI 0 "register_operand" "=d")
@@ -2737,7 +3187,9 @@
   "@
    icm\t%0,%2,%S1
    icmy\t%0,%2,%S1"
-  [(set_attr "op_type" "RS,RSY")])
+  [(set_attr "op_type" "RS,RSY")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1")])
+
 
 (define_insn_and_split "*extzv<mode>"
   [(set (match_operand:GPR 0 "register_operand" "=d")
@@ -2807,6 +3259,85 @@
   FAIL;
 })
 
+(define_insn "*insv<mode>_z10"
+  [(set (zero_extract:GPR (match_operand:GPR 0 "nonimmediate_operand" "+d")
+			  (match_operand 1 "const_int_operand"    "I")
+			  (match_operand 2 "const_int_operand"    "I"))
+	(match_operand:GPR 3 "nonimmediate_operand" "d"))
+   (clobber (reg:CC CC_REGNUM))]
+  "TARGET_Z10
+   && (INTVAL (operands[1]) + INTVAL (operands[2])) <=
+      GET_MODE_BITSIZE (<MODE>mode)"
+{
+  int start = INTVAL (operands[2]);
+  int size = INTVAL (operands[1]);
+  int offset = 64 - GET_MODE_BITSIZE (<MODE>mode);
+
+  operands[2] = GEN_INT (offset + start);              /* start bit position */
+  operands[1] = GEN_INT (offset + start + size - 1);   /* end bit position */
+  operands[4] = GEN_INT (GET_MODE_BITSIZE (<MODE>mode) -
+			 start - size);       /* left shift count */
+
+  return "risbg\t%0,%3,%b2,%b1,%b4";
+}
+  [(set_attr "op_type" "RIE")
+   (set_attr "z10prop" "z10_super_E1")])
+
+; and op1 with a mask being 1 for the selected bits and 0 for the rest
+; and op3=op0 with a mask being 0 for the selected bits and 1 for the rest
+(define_insn "*insv<mode>_z10_noshift"
+  [(set (match_operand:GPR 0 "nonimmediate_operand" "=d")
+	(ior:GPR (and:GPR (match_operand:GPR 1 "nonimmediate_operand" "d")
+			  (match_operand 2 "const_int_operand" "n"))
+		 (and:GPR (match_operand:GPR 3 "nonimmediate_operand" "0")
+			  (match_operand 4 "const_int_operand" "n"))))
+   (clobber (reg:CC CC_REGNUM))]
+  "TARGET_Z10
+   && s390_contiguous_bitmask_p (INTVAL (operands[2]),
+                                 GET_MODE_BITSIZE (<MODE>mode), NULL, NULL)
+   && INTVAL (operands[2]) == ~(INTVAL (operands[4]))"
+
+{
+  int start;
+  int size;
+
+  s390_contiguous_bitmask_p (INTVAL (operands[2]),
+                             GET_MODE_BITSIZE (<MODE>mode), &start, &size);
+
+  operands[5] = GEN_INT (64 - start - size); /* start bit position */
+  operands[6] = GEN_INT (64 - 1 - start);    /* end bit position */
+  operands[7] = const0_rtx;                  /* left shift count */
+
+  return "risbg\t%0,%1,%b5,%b6,%b7";
+}
+  [(set_attr "op_type" "RIE")
+   (set_attr "z10prop" "z10_super_E1")])
+
+; and op1 with a mask being 1 for the selected bits and 0 for the rest
+(define_insn "*insv<mode>_or_z10_noshift"
+  [(set (match_operand:GPR 0 "nonimmediate_operand" "=d")
+	(ior:GPR (and:GPR (match_operand:GPR 1 "nonimmediate_operand" "d")
+			  (match_operand 2 "const_int_operand" "n"))
+		(match_operand:GPR 3 "nonimmediate_operand" "0")))
+   (clobber (reg:CC CC_REGNUM))]
+  "TARGET_Z10
+   && s390_contiguous_bitmask_p (INTVAL (operands[2]),
+                                 GET_MODE_BITSIZE (<MODE>mode), NULL, NULL)"
+{
+  int start;
+  int size;
+
+  s390_contiguous_bitmask_p (INTVAL (operands[2]),
+                             GET_MODE_BITSIZE (<MODE>mode), &start, &size);
+
+  operands[4] = GEN_INT (64 - start - size); /* start bit position */
+  operands[5] = GEN_INT (64 - 1 - start);    /* end bit position */
+  operands[6] = const0_rtx;                  /* left shift count */
+
+  return "rosbg\t%0,%1,%b4,%b5,%b6";
+}
+  [(set_attr "op_type" "RIE")])
+
 (define_insn "*insv<mode>_mem_reg"
   [(set (zero_extract:P (match_operand:QI 0 "memory_operand" "+Q,S")
 			(match_operand 1 "const_int_operand" "n,n")
@@ -2819,10 +3350,11 @@
     int size = INTVAL (operands[1]) / BITS_PER_UNIT;
 
     operands[1] = GEN_INT ((1ul << size) - 1);
-    return (which_alternative == 0) ? "stcm\t%2,%1,%S0" 
+    return (which_alternative == 0) ? "stcm\t%2,%1,%S0"
 				    : "stcmy\t%2,%1,%S0";
 }
-  [(set_attr "op_type" "RS,RSY")])
+  [(set_attr "op_type" "RS,RSY")
+   (set_attr "z10prop" "z10_super,z10_super")])
 
 (define_insn "*insvdi_mem_reghigh"
   [(set (zero_extract:DI (match_operand:QI 0 "memory_operand" "+QS")
@@ -2840,7 +3372,8 @@
     operands[1] = GEN_INT ((1ul << size) - 1);
     return "stcmh\t%2,%1,%S0";
 }
-[(set_attr "op_type" "RSY")])
+[(set_attr "op_type" "RSY")
+ (set_attr "z10prop" "z10_super")])
 
 (define_insn "*insv<mode>_reg_imm"
   [(set (zero_extract:P (match_operand:P 0 "register_operand" "+d")
@@ -2861,7 +3394,9 @@
       default: gcc_unreachable();
     }
 }
-  [(set_attr "op_type" "RI")])
+  [(set_attr "op_type" "RI")
+   (set_attr "z10prop" "z10_super_E1")])
+
 
 (define_insn "*insv<mode>_reg_extimm"
   [(set (zero_extract:P (match_operand:P 0 "register_operand" "+d")
@@ -2880,7 +3415,9 @@
       default: gcc_unreachable();
     }
 }
-  [(set_attr "op_type" "RIL")])
+  [(set_attr "op_type" "RIL")
+   (set_attr "z10prop" "z10_fwd_E1")])
+
 
 ;
 ; extendsidi2 instruction pattern(s).
@@ -2902,13 +3439,17 @@
 })
 
 (define_insn "*extendsidi2"
-  [(set (match_operand:DI 0 "register_operand" "=d,d")
-        (sign_extend:DI (match_operand:SI 1 "nonimmediate_operand" "d,m")))]
+  [(set (match_operand:DI 0 "register_operand" "=d,d,d")
+        (sign_extend:DI (match_operand:SI 1 "nonimmediate_operand" "d,RT,b")))]
   "TARGET_64BIT"
   "@
    lgfr\t%0,%1
-   lgf\t%0,%1"
-  [(set_attr "op_type" "RRE,RXY")])
+   lgf\t%0,%1
+   lgfrl\t%0,%1"
+  [(set_attr "op_type"      "RRE,RXY,RIL")
+   (set_attr "type"         "*,*,larl")
+   (set_attr "cpu_facility" "*,*,z10")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1,z10_super_E1")])
 
 ;
 ; extend(hi|qi)(si|di)2 instruction pattern(s).
@@ -2943,34 +3484,43 @@
 ;
 
 (define_insn "*extendhidi2_extimm"
-  [(set (match_operand:DI 0 "register_operand" "=d,d")
-        (sign_extend:DI (match_operand:HI 1 "nonimmediate_operand" "d,m")))]
+  [(set (match_operand:DI 0 "register_operand" "=d,d,d")
+        (sign_extend:DI (match_operand:HI 1 "general_operand" "d,RT,b")))]
   "TARGET_64BIT && TARGET_EXTIMM"
   "@
    lghr\t%0,%1
-   lgh\t%0,%1"
-  [(set_attr "op_type" "RRE,RXY")])
+   lgh\t%0,%1
+   lghrl\t%0,%1"
+  [(set_attr "op_type"      "RRE,RXY,RIL")
+   (set_attr "type"         "*,*,larl")
+   (set_attr "cpu_facility" "extimm,extimm,z10")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1,z10_super_E1")])
 
 (define_insn "*extendhidi2"
   [(set (match_operand:DI 0 "register_operand" "=d")
-        (sign_extend:DI (match_operand:HI 1 "memory_operand" "m")))]
+        (sign_extend:DI (match_operand:HI 1 "memory_operand" "RT")))]
   "TARGET_64BIT"
   "lgh\t%0,%1"
-  [(set_attr "op_type" "RXY")])
+  [(set_attr "op_type" "RXY")
+   (set_attr "z10prop" "z10_super_E1")])
 
 ;
 ; extendhisi2 instruction pattern(s).
 ;
 
 (define_insn "*extendhisi2_extimm"
-  [(set (match_operand:SI 0 "register_operand" "=d,d,d")
-        (sign_extend:SI (match_operand:HI 1 "nonimmediate_operand" "d,R,T")))]
+  [(set (match_operand:SI 0 "register_operand" "=d,d,d,d")
+        (sign_extend:SI (match_operand:HI 1 "nonimmediate_operand" " d,R,T,b")))]
   "TARGET_EXTIMM"
   "@
    lhr\t%0,%1
    lh\t%0,%1
-   lhy\t%0,%1"
-  [(set_attr "op_type" "RRE,RX,RXY")])
+   lhy\t%0,%1
+   lhrl\t%0,%1"
+  [(set_attr "op_type"      "RRE,RX,RXY,RIL")
+   (set_attr "type"         "*,*,*,larl")
+   (set_attr "cpu_facility" "extimm,extimm,extimm,z10")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1,z10_super_E1,z10_super_E1")])
 
 (define_insn "*extendhisi2"
   [(set (match_operand:SI 0 "register_operand" "=d,d")
@@ -2979,7 +3529,8 @@
   "@
    lh\t%0,%1
    lhy\t%0,%1"
-  [(set_attr "op_type" "RX,RXY")])
+  [(set_attr "op_type" "RX,RXY")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1")])
 
 ;
 ; extendqi(si|di)2 instruction pattern(s).
@@ -2988,20 +3539,22 @@
 ; lbr, lgbr, lb, lgb
 (define_insn "*extendqi<mode>2_extimm"
   [(set (match_operand:GPR 0 "register_operand" "=d,d")
-        (sign_extend:GPR (match_operand:QI 1 "nonimmediate_operand" "d,m")))]
+        (sign_extend:GPR (match_operand:QI 1 "nonimmediate_operand" "d,RT")))]
   "TARGET_EXTIMM"
   "@
    l<g>br\t%0,%1
    l<g>b\t%0,%1"
-  [(set_attr "op_type" "RRE,RXY")])
+  [(set_attr "op_type" "RRE,RXY")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1")])
 
 ; lb, lgb
 (define_insn "*extendqi<mode>2"
   [(set (match_operand:GPR 0 "register_operand" "=d")
-        (sign_extend:GPR (match_operand:QI 1 "memory_operand" "m")))]
+        (sign_extend:GPR (match_operand:QI 1 "memory_operand" "RT")))]
   "!TARGET_EXTIMM && TARGET_LONG_DISPLACEMENT"
   "l<g>b\t%0,%1"
-  [(set_attr "op_type" "RXY")])
+  [(set_attr "op_type" "RXY")
+   (set_attr "z10prop" "z10_super_E1")])
 
 (define_insn_and_split "*extendqi<mode>2_short_displ"
   [(set (match_operand:GPR 0 "register_operand" "=d")
@@ -3042,13 +3595,17 @@
 })
 
 (define_insn "*zero_extendsidi2"
-  [(set (match_operand:DI 0 "register_operand" "=d,d")
-        (zero_extend:DI (match_operand:SI 1 "nonimmediate_operand" "d,m")))]
+  [(set (match_operand:DI 0 "register_operand" "=d,d,d")
+        (zero_extend:DI (match_operand:SI 1 "nonimmediate_operand" "d,RT,b")))]
   "TARGET_64BIT"
   "@
    llgfr\t%0,%1
-   llgf\t%0,%1"
-  [(set_attr "op_type" "RRE,RXY")])
+   llgf\t%0,%1
+   llgfrl\t%0,%1"
+  [(set_attr "op_type"      "RRE,RXY,RIL")
+   (set_attr "type"         "*,*,larl")
+   (set_attr "cpu_facility" "*,*,z10")
+   (set_attr "z10prop" "z10_fwd_E1,z10_fwd_A3,z10_fwd_A3")])
 
 ;
 ; LLGT-type instructions (zero-extend from 31 bit to 64 bit).
@@ -3056,15 +3613,16 @@
 
 (define_insn "*llgt_sidi"
   [(set (match_operand:DI 0 "register_operand" "=d")
-        (and:DI (subreg:DI (match_operand:SI 1 "memory_operand" "m") 0)
+        (and:DI (subreg:DI (match_operand:SI 1 "memory_operand" "RT") 0)
 		(const_int 2147483647)))]
   "TARGET_64BIT"
   "llgt\t%0,%1"
-  [(set_attr "op_type"  "RXE")])
+  [(set_attr "op_type"  "RXE")
+   (set_attr "z10prop" "z10_super_E1")])
 
 (define_insn_and_split "*llgt_sidi_split"
   [(set (match_operand:DI 0 "register_operand" "=d")
-        (and:DI (subreg:DI (match_operand:SI 1 "memory_operand" "m") 0)
+        (and:DI (subreg:DI (match_operand:SI 1 "memory_operand" "RT") 0)
 		(const_int 2147483647)))
    (clobber (reg:CC CC_REGNUM))]
   "TARGET_64BIT"
@@ -3077,13 +3635,14 @@
 
 (define_insn "*llgt_sisi"
   [(set (match_operand:SI 0 "register_operand" "=d,d")
-        (and:SI (match_operand:SI 1 "nonimmediate_operand" "d,m")
+        (and:SI (match_operand:SI 1 "nonimmediate_operand" "d,RT")
 		(const_int 2147483647)))]
   "TARGET_ZARCH"
   "@
    llgtr\t%0,%1
    llgt\t%0,%1"
-  [(set_attr "op_type"  "RRE,RXE")])
+  [(set_attr "op_type"  "RRE,RXE")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1")])
 
 (define_insn "*llgt_didi"
   [(set (match_operand:DI 0 "register_operand" "=d,d")
@@ -3093,7 +3652,8 @@
   "@
    llgtr\t%0,%1
    llgt\t%0,%N1"
-  [(set_attr "op_type"  "RRE,RXE")])
+  [(set_attr "op_type"  "RRE,RXE")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1")])
 
 (define_split
   [(set (match_operand:GPR 0 "register_operand" "")
@@ -3124,7 +3684,7 @@
     }
   else if (!TARGET_EXTIMM)
     {
-      rtx bitcount = GEN_INT (GET_MODE_BITSIZE(DImode) - 
+      rtx bitcount = GEN_INT (GET_MODE_BITSIZE(DImode) -
 			      GET_MODE_BITSIZE(<MODE>mode));
       operands[1] = gen_lowpart (DImode, operands[1]);
       emit_insn (gen_ashldi3 (operands[0], operands[1], bitcount));
@@ -3141,29 +3701,45 @@
   if (!TARGET_EXTIMM)
     {
       operands[1] = gen_lowpart (SImode, operands[1]);
-      emit_insn (gen_andsi3 (operands[0], operands[1], 
+      emit_insn (gen_andsi3 (operands[0], operands[1],
                    GEN_INT ((1 << GET_MODE_BITSIZE(<MODE>mode)) - 1)));
       DONE;
     }
 })
 
+; llhrl, llghrl
+(define_insn "*zero_extendhi<mode>2_z10"
+  [(set (match_operand:GPR 0 "register_operand" "=d,d,d")
+        (zero_extend:GPR (match_operand:HI 1 "nonimmediate_operand" "d,RT,b")))]
+  "TARGET_Z10"
+  "@
+   ll<g>hr\t%0,%1
+   ll<g>h\t%0,%1
+   ll<g>hrl\t%0,%1"
+  [(set_attr "op_type"      "RXY,RRE,RIL")
+   (set_attr "type"         "*,*,larl")
+   (set_attr "cpu_facility" "*,*,z10")
+   (set_attr "z10prop" "z10_fwd_A3")])
+
 ; llhr, llcr, llghr, llgcr, llh, llc, llgh, llgc
 (define_insn "*zero_extend<HQI:mode><GPR:mode>2_extimm"
   [(set (match_operand:GPR 0 "register_operand" "=d,d")
-        (zero_extend:GPR (match_operand:HQI 1 "nonimmediate_operand" "d,m")))]
+        (zero_extend:GPR (match_operand:HQI 1 "nonimmediate_operand" "d,RT")))]
   "TARGET_EXTIMM"
   "@
    ll<g><hc>r\t%0,%1
    ll<g><hc>\t%0,%1"
-  [(set_attr "op_type" "RRE,RXY")])
+  [(set_attr "op_type" "RRE,RXY")
+   (set_attr "z10prop" "z10_super_E1,z10_fwd_A3")])
 
 ; llgh, llgc
 (define_insn "*zero_extend<HQI:mode><GPR:mode>2"
   [(set (match_operand:GPR 0 "register_operand" "=d")
-        (zero_extend:GPR (match_operand:HQI 1 "memory_operand" "m")))]
+        (zero_extend:GPR (match_operand:HQI 1 "memory_operand" "RT")))]
   "TARGET_ZARCH && !TARGET_EXTIMM"
   "llg<hc>\t%0,%1"
-  [(set_attr "op_type" "RXY")])
+  [(set_attr "op_type" "RXY")
+   (set_attr "z10prop" "z10_fwd_A3")])
 
 (define_insn_and_split "*zero_extendhisi2_31"
   [(set (match_operand:SI 0 "register_operand" "=&d")
@@ -3180,7 +3756,7 @@
 
 (define_insn_and_split "*zero_extendqisi2_31"
   [(set (match_operand:SI 0 "register_operand" "=&d")
-        (zero_extend:SI (match_operand:QI 1 "memory_operand" "m")))]
+        (zero_extend:SI (match_operand:QI 1 "memory_operand" "RT")))]
   "!TARGET_ZARCH"
   "#"
   "&& reload_completed"
@@ -3204,14 +3780,15 @@
 
 (define_insn "*zero_extendqihi2_64"
   [(set (match_operand:HI 0 "register_operand" "=d")
-        (zero_extend:HI (match_operand:QI 1 "memory_operand" "m")))]
+        (zero_extend:HI (match_operand:QI 1 "memory_operand" "RT")))]
   "TARGET_ZARCH && !TARGET_EXTIMM"
   "llgc\t%0,%1"
-  [(set_attr "op_type" "RXY")])
+  [(set_attr "op_type" "RXY")
+   (set_attr "z10prop" "z10_fwd_A3")])
 
 (define_insn_and_split "*zero_extendqihi2_31"
   [(set (match_operand:HI 0 "register_operand" "=&d")
-        (zero_extend:HI (match_operand:QI 1 "memory_operand" "m")))]
+        (zero_extend:HI (match_operand:QI 1 "memory_operand" "RT")))]
   "!TARGET_ZARCH"
   "#"
   "&& reload_completed"
@@ -3228,8 +3805,8 @@
     [(set (match_operand:DI 0 "register_operand" "")
 	  (unsigned_fix:DI (match_operand:DD 1 "register_operand" "")))
      (clobber (match_scratch:TD 2 "=f"))])]
-	      
-  "TARGET_HARD_FLOAT && TARGET_HARD_DFP"
+
+  "TARGET_HARD_DFP"
 {
   rtx label1 = gen_label_rtx ();
   rtx label2 = gen_label_rtx ();
@@ -3240,7 +3817,7 @@
   decimal_real_from_string (&sub, "18446744073709551616.0"); /* 2^64 */
 
   /* 2^63 can't be represented as 64bit DFP number with full precision.  The
-     solution is doing the check and the subtraction in TD mode and using a 
+     solution is doing the check and the subtraction in TD mode and using a
      TD -> DI convert afterwards.  */
   emit_insn (gen_extendddtd2 (temp, operands[1]));
   temp = force_reg (TDmode, temp);
@@ -3261,17 +3838,17 @@
 (define_expand "fixuns_trunctddi2"
   [(set (match_operand:DI 0 "register_operand" "")
         (unsigned_fix:DI (match_operand:TD 1 "register_operand" "")))]
-  "TARGET_HARD_FLOAT && TARGET_HARD_DFP"
+  "TARGET_HARD_DFP"
 {
   rtx label1 = gen_label_rtx ();
   rtx label2 = gen_label_rtx ();
   rtx temp = gen_reg_rtx (TDmode);
   REAL_VALUE_TYPE cmp, sub;
-  
+
   operands[1] = force_reg (TDmode, operands[1]);
   decimal_real_from_string (&cmp, "9223372036854775808.0");  /* 2^63 */
   decimal_real_from_string (&sub, "18446744073709551616.0"); /* 2^64 */
-  
+
   emit_insn (gen_cmptd (operands[1],
 	CONST_DOUBLE_FROM_REAL_VALUE (cmp, TDmode)));
   emit_jump_insn (gen_blt (label1));
@@ -3287,7 +3864,7 @@
 })
 
 ;
-; fixuns_trunc(sf|df)(si|di)2 and fix_trunc(sf|df)(si|di)2 
+; fixuns_trunc(sf|df)(si|di)2 and fix_trunc(sf|df)(si|di)2
 ; instruction pattern(s).
 ;
 
@@ -3300,11 +3877,11 @@
   rtx label2 = gen_label_rtx ();
   rtx temp = gen_reg_rtx (<BFP:MODE>mode);
   REAL_VALUE_TYPE cmp, sub;
-  
+
   operands[1] = force_reg (<BFP:MODE>mode, operands[1]);
   real_2expN (&cmp, GET_MODE_BITSIZE(<GPR:MODE>mode) - 1, <BFP:MODE>mode);
   real_2expN (&sub, GET_MODE_BITSIZE(<GPR:MODE>mode), <BFP:MODE>mode);
-  
+
   emit_insn (gen_cmp<BFP:mode> (operands[1],
 	CONST_DOUBLE_FROM_REAL_VALUE (cmp, <BFP:MODE>mode)));
   emit_jump_insn (gen_blt (label1));
@@ -3350,7 +3927,7 @@
 (define_expand "fix_trunc<mode>di2"
   [(set (match_operand:DI 0 "register_operand" "")
         (fix:DI (match_operand:DFP 1 "nonimmediate_operand" "")))]
-  "TARGET_64BIT && TARGET_HARD_FLOAT && TARGET_HARD_DFP"
+  "TARGET_64BIT && TARGET_HARD_DFP"
 {
   operands[1] = force_reg (<MODE>mode, operands[1]);
   emit_insn (gen_fix_trunc<mode>di2_dfp (operands[0], operands[1],
@@ -3364,10 +3941,10 @@
         (fix:DI (match_operand:DFP 1 "register_operand" "f")))
    (unspec:DI [(match_operand:DI 2 "immediate_operand" "K")] UNSPEC_ROUND)
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_64BIT && TARGET_HARD_FLOAT && TARGET_HARD_DFP"
+  "TARGET_64BIT && TARGET_HARD_DFP"
   "cg<DFP:xde>tr\t%0,%h2,%1"
   [(set_attr "op_type" "RRF")
-   (set_attr "type"    "ftoi")])
+   (set_attr "type"    "ftoidfp")])
 
 
 ;
@@ -3394,7 +3971,7 @@
   "TARGET_64BIT && TARGET_HARD_FLOAT"
   "c<xde>g<bt>r\t%0,%1"
   [(set_attr "op_type" "RRE")
-   (set_attr "type"    "itof" )])
+   (set_attr "type"    "itof<mode>" )])
 
 ; cxfbr, cdfbr, cefbr
 (define_insn "floatsi<mode>2"
@@ -3403,7 +3980,7 @@
   "TARGET_HARD_FLOAT"
   "c<xde>fbr\t%0,%1"
   [(set_attr "op_type" "RRE")
-   (set_attr "type"   "itof" )])
+   (set_attr "type"   "itof<mode>" )])
 
 
 ;
@@ -3430,7 +4007,7 @@
   "TARGET_HARD_FLOAT"
   "l<xde>xbr\t%2,%1\;l<xde>r\t%0,%2"
   [(set_attr "length" "6")
-   (set_attr "type"   "ftrunctf")])   
+   (set_attr "type"   "ftrunctf")])
 
 ;
 ; trunctddd2 and truncddsd2 instruction pattern(s).
@@ -3440,18 +4017,18 @@
   [(set (match_operand:DD 0 "register_operand" "=f")
 	(float_truncate:DD (match_operand:TD 1 "register_operand" "f")))
    (clobber (match_scratch:TD 2 "=f"))]
-  "TARGET_HARD_FLOAT && TARGET_HARD_DFP"
+  "TARGET_HARD_DFP"
   "ldxtr\t%2,0,%1,0\;ldr\t%0,%2"
   [(set_attr "length"  "6")
-   (set_attr "type"    "ftrunctf")])
+   (set_attr "type"    "ftruncdd")])
 
 (define_insn "truncddsd2"
   [(set (match_operand:SD 0 "register_operand" "=f")
 	(float_truncate:SD (match_operand:DD 1 "register_operand" "f")))]
-  "TARGET_HARD_FLOAT && TARGET_HARD_DFP"
+  "TARGET_HARD_DFP"
   "ledtr\t%0,0,%1,0"
   [(set_attr "op_type" "RRF")
-   (set_attr "type"    "fsimptf")])
+   (set_attr "type"    "ftruncsd")])
 
 ;
 ; extend(sf|df)(df|tf)2 instruction pattern(s).
@@ -3476,7 +4053,7 @@
 (define_insn "extendddtd2"
   [(set (match_operand:TD 0 "register_operand" "=f")
 	(float_extend:TD (match_operand:DD 1 "register_operand" "f")))]
-  "TARGET_HARD_FLOAT && TARGET_HARD_DFP"
+  "TARGET_HARD_DFP"
   "lxdtr\t%0,%1,0"
   [(set_attr "op_type" "RRF")
    (set_attr "type"    "fsimptf")])
@@ -3484,7 +4061,7 @@
 (define_insn "extendsddd2"
   [(set (match_operand:DD 0 "register_operand" "=f")
 	(float_extend:DD (match_operand:SD 1 "register_operand" "f")))]
-  "TARGET_HARD_FLOAT && TARGET_HARD_DFP"
+  "TARGET_HARD_DFP"
   "ldetr\t%0,%1,0"
   [(set_attr "op_type" "RRF")
    (set_attr "type"    "fsimptf")])
@@ -3497,7 +4074,7 @@
         (float_truncate:DFP_ALL (reg:BFP FPR2_REGNUM)))
    (use (reg:SI GPR0_REGNUM))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_HARD_FLOAT && TARGET_DFP"
+  "TARGET_HARD_DFP"
   "pfpo")
 
 (define_insn "*trunc<DFP_ALL:mode><BFP:mode>2"
@@ -3505,7 +4082,7 @@
         (float_truncate:BFP (reg:DFP_ALL FPR2_REGNUM)))
    (use (reg:SI GPR0_REGNUM))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_HARD_FLOAT && TARGET_DFP"
+  "TARGET_HARD_DFP"
   "pfpo")
 
 (define_expand "trunc<BFP:mode><DFP_ALL:mode>2"
@@ -3518,7 +4095,7 @@
      (clobber (reg:CC CC_REGNUM))])
    (set (match_operand:DFP_ALL 0 "nonimmediate_operand" "")
         (reg:DFP_ALL FPR0_REGNUM))]
-  "TARGET_HARD_FLOAT && TARGET_DFP
+  "TARGET_HARD_DFP
    && GET_MODE_SIZE (<BFP:MODE>mode) > GET_MODE_SIZE (<DFP_ALL:MODE>mode)"
 {
   HOST_WIDE_INT flags;
@@ -3539,7 +4116,7 @@
      (use (reg:SI GPR0_REGNUM))
      (clobber (reg:CC CC_REGNUM))])
    (set (match_operand:BFP 0 "nonimmediate_operand" "") (reg:BFP FPR0_REGNUM))]
-  "TARGET_HARD_FLOAT && TARGET_DFP
+  "TARGET_HARD_DFP
    && GET_MODE_SIZE (<DFP_ALL:MODE>mode) >= GET_MODE_SIZE (<BFP:MODE>mode)"
 {
   HOST_WIDE_INT flags;
@@ -3559,14 +4136,14 @@
   [(set (reg:DFP_ALL FPR0_REGNUM) (float_extend:DFP_ALL (reg:BFP FPR2_REGNUM)))
    (use (reg:SI GPR0_REGNUM))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_HARD_FLOAT && TARGET_DFP"
+  "TARGET_HARD_DFP"
   "pfpo")
 
 (define_insn "*extend<DFP_ALL:mode><BFP:mode>2"
   [(set (reg:BFP FPR0_REGNUM) (float_extend:BFP (reg:DFP_ALL FPR2_REGNUM)))
    (use (reg:SI GPR0_REGNUM))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_HARD_FLOAT && TARGET_DFP"
+  "TARGET_HARD_DFP"
   "pfpo")
 
 (define_expand "extend<BFP:mode><DFP_ALL:mode>2"
@@ -3579,7 +4156,7 @@
      (clobber (reg:CC CC_REGNUM))])
    (set (match_operand:DFP_ALL 0 "nonimmediate_operand" "")
         (reg:DFP_ALL FPR0_REGNUM))]
-  "TARGET_HARD_FLOAT && TARGET_DFP
+  "TARGET_HARD_DFP
    && GET_MODE_SIZE (<BFP:MODE>mode) <= GET_MODE_SIZE (<DFP_ALL:MODE>mode)"
 {
   HOST_WIDE_INT flags;
@@ -3600,7 +4177,7 @@
      (use (reg:SI GPR0_REGNUM))
      (clobber (reg:CC CC_REGNUM))])
    (set (match_operand:BFP 0 "nonimmediate_operand" "") (reg:BFP FPR0_REGNUM))]
-  "TARGET_HARD_FLOAT && TARGET_DFP
+  "TARGET_HARD_DFP
    && GET_MODE_SIZE (<DFP_ALL:MODE>mode) < GET_MODE_SIZE (<BFP:MODE>mode)"
 {
   HOST_WIDE_INT flags;
@@ -3659,7 +4236,7 @@
 
 (define_expand "adddi3"
   [(parallel
-    [(set (match_operand:DI 0 "register_operand" "")
+    [(set (match_operand:DI 0 "nonimmediate_operand" "")
           (plus:DI (match_operand:DI 1 "nonimmediate_operand" "")
                    (match_operand:DI 2 "general_operand" "")))
      (clobber (reg:CC CC_REGNUM))])]
@@ -3668,7 +4245,7 @@
 
 (define_insn "*adddi3_sign"
   [(set (match_operand:DI 0 "register_operand" "=d,d")
-        (plus:DI (sign_extend:DI (match_operand:SI 2 "general_operand" "d,m"))
+        (plus:DI (sign_extend:DI (match_operand:SI 2 "general_operand" "d,RT"))
                  (match_operand:DI 1 "register_operand" "0,0")))
    (clobber (reg:CC CC_REGNUM))]
   "TARGET_64BIT"
@@ -3679,7 +4256,7 @@
 
 (define_insn "*adddi3_zero_cc"
   [(set (reg CC_REGNUM)
-        (compare (plus:DI (zero_extend:DI (match_operand:SI 2 "general_operand" "d,m"))
+        (compare (plus:DI (zero_extend:DI (match_operand:SI 2 "general_operand" "d,RT"))
                           (match_operand:DI 1 "register_operand" "0,0"))
                  (const_int 0)))
    (set (match_operand:DI 0 "register_operand" "=d,d")
@@ -3688,11 +4265,12 @@
   "@
    algfr\t%0,%2
    algf\t%0,%2"
-  [(set_attr "op_type"  "RRE,RXY")])
+  [(set_attr "op_type"  "RRE,RXY")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1")])
 
 (define_insn "*adddi3_zero_cconly"
   [(set (reg CC_REGNUM)
-        (compare (plus:DI (zero_extend:DI (match_operand:SI 2 "general_operand" "d,m"))
+        (compare (plus:DI (zero_extend:DI (match_operand:SI 2 "general_operand" "d,RT"))
                           (match_operand:DI 1 "register_operand" "0,0"))
                  (const_int 0)))
    (clobber (match_scratch:DI 0 "=d,d"))]
@@ -3700,21 +4278,23 @@
   "@
    algfr\t%0,%2
    algf\t%0,%2"
-  [(set_attr "op_type"  "RRE,RXY")])
+  [(set_attr "op_type"  "RRE,RXY")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1")])
 
 (define_insn "*adddi3_zero"
   [(set (match_operand:DI 0 "register_operand" "=d,d")
-        (plus:DI (zero_extend:DI (match_operand:SI 2 "general_operand" "d,m"))
+        (plus:DI (zero_extend:DI (match_operand:SI 2 "general_operand" "d,RT"))
                  (match_operand:DI 1 "register_operand" "0,0")))
    (clobber (reg:CC CC_REGNUM))]
   "TARGET_64BIT"
   "@
    algfr\t%0,%2
    algf\t%0,%2"
-  [(set_attr "op_type"  "RRE,RXY")])
+  [(set_attr "op_type"  "RRE,RXY")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1")])
 
 (define_insn_and_split "*adddi3_31z"
-  [(set (match_operand:DI 0 "register_operand" "=&d")
+  [(set (match_operand:DI 0 "nonimmediate_operand" "=&d")
         (plus:DI (match_operand:DI 1 "nonimmediate_operand" "%0")
                  (match_operand:DI 2 "general_operand" "do") ) )
    (clobber (reg:CC CC_REGNUM))]
@@ -3739,7 +4319,7 @@
    operands[8] = operand_subword (operands[2], 1, 0, DImode);")
 
 (define_insn_and_split "*adddi3_31"
-  [(set (match_operand:DI 0 "register_operand" "=&d")
+  [(set (match_operand:DI 0 "nonimmediate_operand" "=&d")
         (plus:DI (match_operand:DI 1 "nonimmediate_operand" "%0")
                  (match_operand:DI 2 "general_operand" "do") ) )
    (clobber (reg:CC CC_REGNUM))]
@@ -3776,7 +4356,7 @@
 
 (define_expand "addsi3"
   [(parallel
-    [(set (match_operand:SI 0 "register_operand" "")
+    [(set (match_operand:SI 0 "nonimmediate_operand" "")
           (plus:SI (match_operand:SI 1 "nonimmediate_operand" "")
                    (match_operand:SI 2 "general_operand" "")))
      (clobber (reg:CC CC_REGNUM))])]
@@ -3798,11 +4378,11 @@
 ; add(di|si)3 instruction pattern(s).
 ;
 
-; ar, ahi, alfi, slfi, a, ay, agr, aghi, algfi, slgfi, ag
+; ar, ahi, alfi, slfi, a, ay, agr, aghi, algfi, slgfi, ag, asi, agsi
 (define_insn "*add<mode>3"
-  [(set (match_operand:GPR 0 "register_operand" "=d,d,d,d,d,d")
-        (plus:GPR (match_operand:GPR 1 "nonimmediate_operand" "%0,0,0,0,0,0")
-		  (match_operand:GPR 2 "general_operand" "d,K,Op,On,R,T") ) )
+  [(set (match_operand:GPR 0 "nonimmediate_operand" "=d,d,d,d,d,d,QS")
+        (plus:GPR (match_operand:GPR 1 "nonimmediate_operand" "%0,0,0,0,0,0,0")
+		  (match_operand:GPR 2 "general_operand" "d,K,Op,On,R,T,C") ) )
    (clobber (reg:CC CC_REGNUM))]
   ""
   "@
@@ -3811,16 +4391,25 @@
    al<g>fi\t%0,%2
    sl<g>fi\t%0,%n2
    a<g>\t%0,%2
-   a<y>\t%0,%2"
-  [(set_attr "op_type"  "RR<E>,RI,RIL,RIL,RX<Y>,RXY")])
-
-; alr, alfi, slfi, al, aly, algr, algfi, slgfi, alg
+   a<y>\t%0,%2
+   a<g>si\t%0,%c2"
+  [(set_attr "op_type"  "RR<E>,RI,RIL,RIL,RX<Y>,RXY,SIY")
+   (set_attr "cpu_facility" "*,*,extimm,extimm,*,*,z10")
+   (set_attr "z10prop" "z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1")])
+
+; alr, alfi, slfi, al, aly, algr, algfi, slgfi, alg, alsi, algsi
 (define_insn "*add<mode>3_carry1_cc"
   [(set (reg CC_REGNUM)
-        (compare (plus:GPR (match_operand:GPR 1 "nonimmediate_operand" "%0,0,0,0,0")
-			   (match_operand:GPR 2 "general_operand" "d,Op,On,R,T"))
+        (compare (plus:GPR (match_operand:GPR 1 "nonimmediate_operand" "%0,0,0,0,0,0")
+			   (match_operand:GPR 2 "general_operand" "d,Op,On,R,T,C"))
                  (match_dup 1)))
-   (set (match_operand:GPR 0 "register_operand" "=d,d,d,d,d")
+   (set (match_operand:GPR 0 "nonimmediate_operand" "=d,d,d,d,d,d")
         (plus:GPR (match_dup 1) (match_dup 2)))]
   "s390_match_ccmode (insn, CCL1mode)"
   "@
@@ -3828,8 +4417,16 @@
    al<g>fi\t%0,%2
    sl<g>fi\t%0,%n2
    al<g>\t%0,%2
-   al<y>\t%0,%2"
-  [(set_attr "op_type"  "RR<E>,RIL,RIL,RX<Y>,RXY")])
+   al<y>\t%0,%2
+   al<g>si\t%0,%c2"
+  [(set_attr "op_type"      "RR<E>,RIL,RIL,RX<Y>,RXY,SIY")
+   (set_attr "cpu_facility" "*,extimm,extimm,*,*,z10")
+   (set_attr "z10prop" "z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1")])
 
 ; alr, al, aly, algr, alg
 (define_insn "*add<mode>3_carry1_cconly"
@@ -3843,15 +4440,16 @@
    al<g>r\t%0,%2
    al<g>\t%0,%2
    al<y>\t%0,%2"
-  [(set_attr "op_type"  "RR<E>,RX<Y>,RXY")])
+  [(set_attr "op_type"  "RR<E>,RX<Y>,RXY")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1,z10_super_E1")])
 
-; alr, alfi, slfi, al, aly, algr, algfi, slgfi, alg
+; alr, alfi, slfi, al, aly, algr, algfi, slgfi, alg, alsi, algsi
 (define_insn "*add<mode>3_carry2_cc"
   [(set (reg CC_REGNUM)
-        (compare (plus:GPR (match_operand:GPR 1 "nonimmediate_operand" "%0,0,0,0,0")
-			   (match_operand:GPR 2 "general_operand" "d,Op,On,R,T"))
+        (compare (plus:GPR (match_operand:GPR 1 "nonimmediate_operand" "%0,0,0,0,0,0")
+			   (match_operand:GPR 2 "general_operand" "d,Op,On,R,T,C"))
                  (match_dup 2)))
-   (set (match_operand:GPR 0 "register_operand" "=d,d,d,d,d")
+   (set (match_operand:GPR 0 "nonimmediate_operand" "=d,d,d,d,d,RS")
         (plus:GPR (match_dup 1) (match_dup 2)))]
   "s390_match_ccmode (insn, CCL1mode)"
   "@
@@ -3859,8 +4457,16 @@
    al<g>fi\t%0,%2
    sl<g>fi\t%0,%n2
    al<g>\t%0,%2
-   al<y>\t%0,%2"
-  [(set_attr "op_type"  "RR<E>,RIL,RIL,RX<Y>,RXY")])
+   al<y>\t%0,%2
+   al<g>si\t%0,%c2"
+  [(set_attr "op_type"  "RR<E>,RIL,RIL,RX<Y>,RXY,SIY")
+   (set_attr "cpu_facility" "*,extimm,extimm,*,*,z10")
+   (set_attr "z10prop" "z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1")])
 
 ; alr, al, aly, algr, alg
 (define_insn "*add<mode>3_carry2_cconly"
@@ -3874,15 +4480,16 @@
    al<g>r\t%0,%2
    al<g>\t%0,%2
    al<y>\t%0,%2"
-  [(set_attr "op_type"  "RR<E>,RX<Y>,RXY")])
+  [(set_attr "op_type"  "RR<E>,RX<Y>,RXY")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1,z10_super_E1")])
 
-; alr, alfi, slfi, al, aly, algr, algfi, slgfi, alg
+; alr, alfi, slfi, al, aly, algr, algfi, slgfi, alg, alsi, algsi
 (define_insn "*add<mode>3_cc"
   [(set (reg CC_REGNUM)
-        (compare (plus:GPR (match_operand:GPR 1 "nonimmediate_operand" "%0,0,0,0,0")
-			   (match_operand:GPR 2 "general_operand" "d,Op,On,R,T"))
+        (compare (plus:GPR (match_operand:GPR 1 "nonimmediate_operand" "%0,0,0,0,0,0")
+			   (match_operand:GPR 2 "general_operand" "d,Op,On,R,T,C"))
                  (const_int 0)))
-   (set (match_operand:GPR 0 "register_operand" "=d,d,d,d,d")
+   (set (match_operand:GPR 0 "nonimmediate_operand" "=d,d,d,d,d,RS")
         (plus:GPR (match_dup 1) (match_dup 2)))]
   "s390_match_ccmode (insn, CCLmode)"
   "@
@@ -3890,8 +4497,16 @@
    al<g>fi\t%0,%2
    sl<g>fi\t%0,%n2
    al<g>\t%0,%2
-   al<y>\t%0,%2"
-  [(set_attr "op_type"  "RR<E>,RIL,RIL,RX<Y>,RXY")])
+   al<y>\t%0,%2
+   al<g>si\t%0,%c2"
+  [(set_attr "op_type"  "RR<E>,RIL,RIL,RX<Y>,RXY,SIY")
+   (set_attr "cpu_facility" "*,extimm,extimm,*,*,z10")
+   (set_attr "z10prop" "z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1")])
 
 ; alr, al, aly, algr, alg
 (define_insn "*add<mode>3_cconly"
@@ -3905,7 +4520,8 @@
    al<g>r\t%0,%2
    al<g>\t%0,%2
    al<y>\t%0,%2"
-  [(set_attr "op_type"  "RR<E>,RX<Y>,RXY")])
+  [(set_attr "op_type"  "RR<E>,RX<Y>,RXY")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1,z10_super_E1")])
 
 ; alr, al, aly, algr, alg
 (define_insn "*add<mode>3_cconly2"
@@ -3918,24 +4534,29 @@
    al<g>r\t%0,%2
    al<g>\t%0,%2
    al<y>\t%0,%2"
-  [(set_attr "op_type"  "RR<E>,RX<Y>,RXY")])
+  [(set_attr "op_type"  "RR<E>,RX<Y>,RXY")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1,z10_super_E1")])
 
-; ahi, afi, aghi, agfi
+; ahi, afi, aghi, agfi, asi, agsi
 (define_insn "*add<mode>3_imm_cc"
   [(set (reg CC_REGNUM)
-        (compare (plus:GPR (match_operand:GPR 1 "nonimmediate_operand" "0,0")
-			   (match_operand:GPR 2 "const_int_operand" "K,Os"))
+        (compare (plus:GPR (match_operand:GPR 1 "nonimmediate_operand" "0,0,0")
+			   (match_operand:GPR 2 "const_int_operand" "K,Os,C"))
                  (const_int 0)))
-   (set (match_operand:GPR 0 "register_operand" "=d,d")
+   (set (match_operand:GPR 0 "nonimmediate_operand" "=d,d,QS")
         (plus:GPR (match_dup 1) (match_dup 2)))]
   "s390_match_ccmode (insn, CCAmode)
    && (CONST_OK_FOR_CONSTRAINT_P (INTVAL (operands[2]), 'K', \"K\")
-       || CONST_OK_FOR_CONSTRAINT_P (INTVAL (operands[2]), 'O', \"Os\"))
+       || CONST_OK_FOR_CONSTRAINT_P (INTVAL (operands[2]), 'O', \"Os\")
+       || CONST_OK_FOR_CONSTRAINT_P (INTVAL (operands[2]), 'C', \"C\"))
    && INTVAL (operands[2]) != -((HOST_WIDE_INT)1 << (GET_MODE_BITSIZE(<MODE>mode) - 1))"
   "@
    a<g>hi\t%0,%h2
-   a<g>fi\t%0,%2"
-  [(set_attr "op_type"  "RI,RIL")])
+   a<g>fi\t%0,%2
+   a<g>si\t%0,%c2"
+  [(set_attr "op_type"      "RI,RIL,SIY")
+   (set_attr "cpu_facility" "*,extimm,z10")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1,z10_super_E1")])
 
 ;
 ; add(tf|df|sf|td|dd)3 instruction pattern(s).
@@ -3952,7 +4573,7 @@
    a<xde><bt>r\t%0,<op1>%2
    a<xde>b\t%0,%2"
   [(set_attr "op_type"  "<RRer>,RXE")
-   (set_attr "type"     "fsimp<bfp>")])
+   (set_attr "type"     "fsimp<mode>")])
 
 ; axbr, adbr, aebr, axb, adb, aeb, adtr, axtr
 (define_insn "*add<mode>3_cc"
@@ -3967,7 +4588,7 @@
    a<xde><bt>r\t%0,<op1>%2
    a<xde>b\t%0,%2"
   [(set_attr "op_type"  "<RRer>,RXE")
-   (set_attr "type"     "fsimp<bfp>")])
+   (set_attr "type"     "fsimp<mode>")])
 
 ; axbr, adbr, aebr, axb, adb, aeb, adtr, axtr
 (define_insn "*add<mode>3_cconly"
@@ -3981,7 +4602,7 @@
    a<xde><bt>r\t%0,<op1>%2
    a<xde>b\t%0,%2"
   [(set_attr "op_type"  "<RRer>,RXE")
-   (set_attr "type"     "fsimp<bfp>")])
+   (set_attr "type"     "fsimp<mode>")])
 
 
 ;;
@@ -4032,18 +4653,19 @@
 (define_insn "*subdi3_sign"
   [(set (match_operand:DI 0 "register_operand" "=d,d")
         (minus:DI (match_operand:DI 1 "register_operand" "0,0")
-                  (sign_extend:DI (match_operand:SI 2 "general_operand" "d,m"))))
+                  (sign_extend:DI (match_operand:SI 2 "general_operand" "d,RT"))))
    (clobber (reg:CC CC_REGNUM))]
   "TARGET_64BIT"
   "@
    sgfr\t%0,%2
    sgf\t%0,%2"
-  [(set_attr "op_type"  "RRE,RXY")])
+  [(set_attr "op_type"  "RRE,RXY")
+   (set_attr "z10prop" "z10_c,*")])
 
 (define_insn "*subdi3_zero_cc"
   [(set (reg CC_REGNUM)
         (compare (minus:DI (match_operand:DI 1 "register_operand" "0,0")
-                           (zero_extend:DI (match_operand:SI 2 "general_operand" "d,m")))
+                           (zero_extend:DI (match_operand:SI 2 "general_operand" "d,RT")))
                  (const_int 0)))
    (set (match_operand:DI 0 "register_operand" "=d,d")
         (minus:DI (match_dup 1) (zero_extend:DI (match_dup 2))))]
@@ -4051,30 +4673,33 @@
   "@
    slgfr\t%0,%2
    slgf\t%0,%2"
-  [(set_attr "op_type"  "RRE,RXY")])
+  [(set_attr "op_type"  "RRE,RXY")
+   (set_attr "z10prop" "z10_super_c_E1,z10_super_E1")])
 
 (define_insn "*subdi3_zero_cconly"
   [(set (reg CC_REGNUM)
         (compare (minus:DI (match_operand:DI 1 "register_operand" "0,0")
-                           (zero_extend:DI (match_operand:SI 2 "general_operand" "d,m")))
+                           (zero_extend:DI (match_operand:SI 2 "general_operand" "d,RT")))
                  (const_int 0)))
    (clobber (match_scratch:DI 0 "=d,d"))]
   "s390_match_ccmode (insn, CCLmode) && TARGET_64BIT"
   "@
    slgfr\t%0,%2
    slgf\t%0,%2"
-  [(set_attr "op_type"  "RRE,RXY")])
+  [(set_attr "op_type"  "RRE,RXY")
+   (set_attr "z10prop" "z10_super_c_E1,z10_super_E1")])
 
 (define_insn "*subdi3_zero"
   [(set (match_operand:DI 0 "register_operand" "=d,d")
         (minus:DI (match_operand:DI 1 "register_operand" "0,0")
-                  (zero_extend:DI (match_operand:SI 2 "general_operand" "d,m"))))
+                  (zero_extend:DI (match_operand:SI 2 "general_operand" "d,RT"))))
    (clobber (reg:CC CC_REGNUM))]
   "TARGET_64BIT"
   "@
    slgfr\t%0,%2
    slgf\t%0,%2"
-  [(set_attr "op_type"  "RRE,RXY")])
+  [(set_attr "op_type"  "RRE,RXY")
+   (set_attr "z10prop" "z10_super_c_E1,z10_super_E1")])
 
 (define_insn_and_split "*subdi3_31z"
   [(set (match_operand:DI 0 "register_operand" "=&d")
@@ -4171,7 +4796,8 @@
    s<g>r\t%0,%2
    s<g>\t%0,%2
    s<y>\t%0,%2"
-  [(set_attr "op_type"  "RR<E>,RX<Y>,RXY")])
+  [(set_attr "op_type"  "RR<E>,RX<Y>,RXY")
+   (set_attr "z10prop" "z10_super_c_E1,z10_super_E1,z10_super_E1")])
 
 ; slr, sl, sly, slgr, slg
 (define_insn "*sub<mode>3_borrow_cc"
@@ -4186,7 +4812,8 @@
    sl<g>r\t%0,%2
    sl<g>\t%0,%2
    sl<y>\t%0,%2"
-  [(set_attr "op_type"  "RR<E>,RX<Y>,RXY")])
+  [(set_attr "op_type"  "RR<E>,RX<Y>,RXY")
+   (set_attr "z10prop" "z10_super_c_E1,z10_super_E1,z10_super_E1")])
 
 ; slr, sl, sly, slgr, slg
 (define_insn "*sub<mode>3_borrow_cconly"
@@ -4200,7 +4827,8 @@
    sl<g>r\t%0,%2
    sl<g>\t%0,%2
    sl<y>\t%0,%2"
-  [(set_attr "op_type"  "RR<E>,RX<Y>,RXY")])
+  [(set_attr "op_type"  "RR<E>,RX<Y>,RXY")
+   (set_attr "z10prop" "z10_super_c_E1,z10_super_E1,z10_super_E1")])
 
 ; slr, sl, sly, slgr, slg
 (define_insn "*sub<mode>3_cc"
@@ -4215,7 +4843,8 @@
    sl<g>r\t%0,%2
    sl<g>\t%0,%2
    sl<y>\t%0,%2"
-  [(set_attr "op_type"  "RR<E>,RX<Y>,RXY")])
+  [(set_attr "op_type"  "RR<E>,RX<Y>,RXY")
+   (set_attr "z10prop" "z10_super_c_E1,z10_super_E1,z10_super_E1")])
 
 ; slr, sl, sly, slgr, slg
 (define_insn "*sub<mode>3_cc2"
@@ -4229,7 +4858,8 @@
    sl<g>r\t%0,%2
    sl<g>\t%0,%2
    sl<y>\t%0,%2"
-  [(set_attr "op_type"  "RR<E>,RX<Y>,RXY")])
+  [(set_attr "op_type"  "RR<E>,RX<Y>,RXY")
+   (set_attr "z10prop" "z10_super_c_E1,z10_super_E1,z10_super_E1")])
 
 ; slr, sl, sly, slgr, slg
 (define_insn "*sub<mode>3_cconly"
@@ -4243,7 +4873,9 @@
    sl<g>r\t%0,%2
    sl<g>\t%0,%2
    sl<y>\t%0,%2"
-  [(set_attr "op_type"  "RR<E>,RX<Y>,RXY")])
+  [(set_attr "op_type"  "RR<E>,RX<Y>,RXY")
+   (set_attr "z10prop" "z10_super_c_E1,z10_super_E1,z10_super_E1")])
+
 
 ; slr, sl, sly, slgr, slg
 (define_insn "*sub<mode>3_cconly2"
@@ -4256,7 +4888,9 @@
    sl<g>r\t%0,%2
    sl<g>\t%0,%2
    sl<y>\t%0,%2"
-  [(set_attr "op_type"  "RR<E>,RX<Y>,RXY")])
+  [(set_attr "op_type"  "RR<E>,RX<Y>,RXY")
+   (set_attr "z10prop" "z10_super_c_E1,z10_super_E1,z10_super_E1")])
+
 
 ;
 ; sub(tf|df|sf|td|dd)3 instruction pattern(s).
@@ -4273,7 +4907,7 @@
    s<xde><bt>r\t%0,<op1>%2
    s<xde>b\t%0,%2"
   [(set_attr "op_type"  "<RRer>,RXE")
-   (set_attr "type"     "fsimp<bfp>")])
+   (set_attr "type"     "fsimp<mode>")])
 
 ; sxbr, sdbr, sebr, sxb, sdb, seb, sxtr, sdtr
 (define_insn "*sub<mode>3_cc"
@@ -4288,7 +4922,7 @@
    s<xde><bt>r\t%0,<op1>%2
    s<xde>b\t%0,%2"
   [(set_attr "op_type"  "<RRer>,RXE")
-   (set_attr "type"     "fsimp<bfp>")])
+   (set_attr "type"     "fsimp<mode>")])
 
 ; sxbr, sdbr, sebr, sxb, sdb, seb, sxtr, sdtr
 (define_insn "*sub<mode>3_cconly"
@@ -4302,7 +4936,7 @@
    s<xde><bt>r\t%0,<op1>%2
    s<xde>b\t%0,%2"
   [(set_attr "op_type"  "<RRer>,RXE")
-   (set_attr "type"     "fsimp<bfp>")])
+   (set_attr "type"     "fsimp<mode>")])
 
 
 ;;
@@ -4324,7 +4958,7 @@
         (compare
           (plus:GPR (plus:GPR (match_operand:GPR 3 "s390_alc_comparison" "")
                               (match_operand:GPR 1 "nonimmediate_operand" "%0,0"))
-                    (match_operand:GPR 2 "general_operand" "d,m"))
+                    (match_operand:GPR 2 "general_operand" "d,RT"))
           (match_dup 1)))
    (set (match_operand:GPR 0 "register_operand" "=d,d")
         (plus:GPR (plus:GPR (match_dup 3) (match_dup 1)) (match_dup 2)))]
@@ -4340,7 +4974,7 @@
         (compare
           (plus:GPR (plus:GPR (match_operand:GPR 3 "s390_alc_comparison" "")
                               (match_operand:GPR 1 "nonimmediate_operand" "%0,0"))
-                    (match_operand:GPR 2 "general_operand" "d,m"))
+                    (match_operand:GPR 2 "general_operand" "d,RT"))
           (match_dup 1)))
    (clobber (match_scratch:GPR 0 "=d,d"))]
   "s390_match_ccmode (insn, CCL1mode) && TARGET_CPU_ZARCH"
@@ -4357,7 +4991,7 @@
         (compare
           (plus:GPR (plus:GPR (match_operand:GPR 3 "s390_alc_comparison" "")
                               (match_operand:GPR 1 "nonimmediate_operand" "%0,0"))
-                    (match_operand:GPR 2 "general_operand" "d,m"))
+                    (match_operand:GPR 2 "general_operand" "d,RT"))
           (match_dup 2)))
    (set (match_operand:GPR 0 "register_operand" "=d,d")
         (plus:GPR (plus:GPR (match_dup 3) (match_dup 1)) (match_dup 2)))]
@@ -4373,7 +5007,7 @@
         (compare
           (plus:GPR (plus:GPR (match_operand:GPR 3 "s390_alc_comparison" "")
                               (match_operand:GPR 1 "nonimmediate_operand" "%0,0"))
-                    (match_operand:GPR 2 "general_operand" "d,m"))
+                    (match_operand:GPR 2 "general_operand" "d,RT"))
           (match_dup 2)))
    (clobber (match_scratch:GPR 0 "=d,d"))]
   "s390_match_ccmode (insn, CCL1mode) && TARGET_CPU_ZARCH"
@@ -4388,7 +5022,7 @@
         (compare
           (plus:GPR (plus:GPR (match_operand:GPR 3 "s390_alc_comparison" "")
                               (match_operand:GPR 1 "nonimmediate_operand" "%0,0"))
-                    (match_operand:GPR 2 "general_operand" "d,m"))
+                    (match_operand:GPR 2 "general_operand" "d,RT"))
           (const_int 0)))
    (set (match_operand:GPR 0 "register_operand" "=d,d")
         (plus:GPR (plus:GPR (match_dup 3) (match_dup 1)) (match_dup 2)))]
@@ -4403,7 +5037,7 @@
   [(set (match_operand:GPR 0 "register_operand" "=d,d")
         (plus:GPR (plus:GPR (match_operand:GPR 3 "s390_alc_comparison" "")
                             (match_operand:GPR 1 "nonimmediate_operand" "%0,0"))
-                  (match_operand:GPR 2 "general_operand" "d,m")))
+                  (match_operand:GPR 2 "general_operand" "d,RT")))
    (clobber (reg:CC CC_REGNUM))]
   "TARGET_CPU_ZARCH"
   "@
@@ -4416,7 +5050,7 @@
   [(set (reg CC_REGNUM)
         (compare
           (minus:GPR (minus:GPR (match_operand:GPR 1 "nonimmediate_operand" "0,0")
-                                (match_operand:GPR 2 "general_operand" "d,m"))
+                                (match_operand:GPR 2 "general_operand" "d,RT"))
                      (match_operand:GPR 3 "s390_slb_comparison" ""))
           (const_int 0)))
    (set (match_operand:GPR 0 "register_operand" "=d,d")
@@ -4425,20 +5059,22 @@
   "@
    slb<g>r\t%0,%2
    slb<g>\t%0,%2"
-  [(set_attr "op_type"  "RRE,RXY")])
+  [(set_attr "op_type"  "RRE,RXY")
+   (set_attr "z10prop" "z10_c,*")])
 
 ; slbr, slb, slbgr, slbg
 (define_insn "*sub<mode>3_slb"
   [(set (match_operand:GPR 0 "register_operand" "=d,d")
         (minus:GPR (minus:GPR (match_operand:GPR 1 "nonimmediate_operand" "0,0")
-                              (match_operand:GPR 2 "general_operand" "d,m"))
+                              (match_operand:GPR 2 "general_operand" "d,RT"))
                    (match_operand:GPR 3 "s390_slb_comparison" "")))
    (clobber (reg:CC CC_REGNUM))]
   "TARGET_CPU_ZARCH"
   "@
    slb<g>r\t%0,%2
    slb<g>\t%0,%2"
-  [(set_attr "op_type"  "RRE,RXY")])
+  [(set_attr "op_type"  "RRE,RXY")
+   (set_attr "z10prop" "z10_c,*")])
 
 (define_expand "add<mode>cc"
   [(match_operand:GPR 0 "register_operand" "")
@@ -4446,9 +5082,9 @@
    (match_operand:GPR 2 "register_operand" "")
    (match_operand:GPR 3 "const_int_operand" "")]
   "TARGET_CPU_ZARCH"
-  "if (!s390_expand_addcc (GET_CODE (operands[1]), 
-			   s390_compare_op0, s390_compare_op1, 
-			   operands[0], operands[2], 
+  "if (!s390_expand_addcc (GET_CODE (operands[1]),
+			   s390_compare_op0, s390_compare_op1,
+			   operands[0], operands[2],
 			   operands[3])) FAIL; DONE;")
 
 ;
@@ -4504,7 +5140,7 @@
     [(set (match_dup 0) (xor:SI (match_dup 0) (const_int 1)))
      (clobber (reg:CC CC_REGNUM))])]
   ""
-{ 
+{
   if (!s390_compare_emitted || GET_MODE (s390_compare_emitted) != CCZ1mode)
     FAIL;
   operands[1] = s390_emit_compare (NE, s390_compare_op0, s390_compare_op1);
@@ -4513,7 +5149,7 @@
 
 (define_insn_and_split "*sne"
   [(set (match_operand:SI 0 "register_operand" "=d")
-	(ne:SI (match_operand:CCZ1 1 "register_operand" "0") 
+	(ne:SI (match_operand:CCZ1 1 "register_operand" "0")
 	       (const_int 0)))
    (clobber (reg:CC CC_REGNUM))]
   ""
@@ -4534,69 +5170,78 @@
 
 (define_insn "*muldi3_sign"
   [(set (match_operand:DI 0 "register_operand" "=d,d")
-        (mult:DI (sign_extend:DI (match_operand:SI 2 "nonimmediate_operand" "d,m"))
+        (mult:DI (sign_extend:DI (match_operand:SI 2 "general_operand" "d,RT"))
                  (match_operand:DI 1 "register_operand" "0,0")))]
   "TARGET_64BIT"
   "@
    msgfr\t%0,%2
    msgf\t%0,%2"
-  [(set_attr "op_type"  "RRE,RXY")
-   (set_attr "type"     "imuldi")])
+  [(set_attr "op_type"      "RRE,RXY")
+   (set_attr "type"         "imuldi")])
 
 (define_insn "muldi3"
-  [(set (match_operand:DI 0 "register_operand" "=d,d,d")
-        (mult:DI (match_operand:DI 1 "nonimmediate_operand" "%0,0,0")
-                 (match_operand:DI 2 "general_operand" "d,K,m")))]
+  [(set (match_operand:DI 0 "register_operand" "=d,d,d,d")
+        (mult:DI (match_operand:DI 1 "nonimmediate_operand" "%0,0,0,0")
+                 (match_operand:DI 2 "general_operand" "d,K,RT,Os")))]
   "TARGET_64BIT"
   "@
    msgr\t%0,%2
    mghi\t%0,%h2
-   msg\t%0,%2"
-  [(set_attr "op_type"  "RRE,RI,RXY")
-   (set_attr "type"     "imuldi")])
+   msg\t%0,%2
+   msgfi\t%0,%2"
+  [(set_attr "op_type"      "RRE,RI,RXY,RIL")
+   (set_attr "type"         "imuldi")
+   (set_attr "cpu_facility" "*,*,*,z10")])
 
 ;
 ; mulsi3 instruction pattern(s).
 ;
 
 (define_insn "*mulsi3_sign"
-  [(set (match_operand:SI 0 "register_operand" "=d")
-        (mult:SI (sign_extend:SI (match_operand:HI 2 "memory_operand" "R"))
-                 (match_operand:SI 1 "register_operand" "0")))]
+  [(set (match_operand:SI 0 "register_operand" "=d,d")
+        (mult:SI (sign_extend:SI (match_operand:HI 2 "memory_operand" "R,T"))
+                 (match_operand:SI 1 "register_operand" "0,0")))]
   ""
-  "mh\t%0,%2"
-  [(set_attr "op_type"  "RX")
-   (set_attr "type"     "imulhi")])
+  "@
+   mh\t%0,%2
+   mhy\t%0,%2"
+  [(set_attr "op_type"      "RX,RXY")
+   (set_attr "type"         "imulhi")
+   (set_attr "cpu_facility" "*,z10")])
 
 (define_insn "mulsi3"
-  [(set (match_operand:SI 0 "register_operand" "=d,d,d,d")
-        (mult:SI  (match_operand:SI 1 "nonimmediate_operand" "%0,0,0,0")
-                  (match_operand:SI 2 "general_operand" "d,K,R,T")))]
+  [(set (match_operand:SI 0 "register_operand" "=d,d,d,d,d")
+        (mult:SI  (match_operand:SI 1 "nonimmediate_operand" "%0,0,0,0,0")
+                  (match_operand:SI 2 "general_operand" "d,K,R,T,Os")))]
   ""
   "@
    msr\t%0,%2
    mhi\t%0,%h2
    ms\t%0,%2
-   msy\t%0,%2"
-  [(set_attr "op_type"  "RRE,RI,RX,RXY")
-   (set_attr "type"     "imulsi,imulhi,imulsi,imulsi")])
+   msy\t%0,%2
+   msfi\t%0,%2"
+  [(set_attr "op_type"      "RRE,RI,RX,RXY,RIL")
+   (set_attr "type"         "imulsi,imulhi,imulsi,imulsi,imulsi")
+   (set_attr "cpu_facility" "*,*,*,*,z10")])
 
 ;
 ; mulsidi3 instruction pattern(s).
 ;
 
 (define_insn "mulsidi3"
-  [(set (match_operand:DI 0 "register_operand" "=d,d")
+  [(set (match_operand:DI 0 "register_operand" "=d,d,d")
         (mult:DI (sign_extend:DI
-	           (match_operand:SI 1 "register_operand" "%0,0"))
+	           (match_operand:SI 1 "register_operand" "%0,0,0"))
                  (sign_extend:DI
-	           (match_operand:SI 2 "nonimmediate_operand" "d,R"))))]
+	           (match_operand:SI 2 "nonimmediate_operand" "d,R,T"))))]
   "!TARGET_64BIT"
   "@
    mr\t%0,%2
-   m\t%0,%2"
-  [(set_attr "op_type"  "RR,RX")
-   (set_attr "type"     "imulsi")])
+   m\t%0,%2
+   mfy\t%0,%2"
+  [(set_attr "op_type"      "RR,RX,RXY")
+   (set_attr "type"         "imulsi")
+   (set_attr "cpu_facility" "*,*,z10")])
 
 ;
 ; umulsidi3 instruction pattern(s).
@@ -4607,7 +5252,7 @@
         (mult:DI (zero_extend:DI
 	           (match_operand:SI 1 "register_operand" "%0,0"))
                  (zero_extend:DI
-	           (match_operand:SI 2 "nonimmediate_operand" "d,m"))))]
+	           (match_operand:SI 2 "nonimmediate_operand" "d,RT"))))]
   "!TARGET_64BIT && TARGET_CPU_ZARCH"
   "@
    mlr\t%0,%2
@@ -4619,7 +5264,7 @@
 ; mul(tf|df|sf|td|dd)3 instruction pattern(s).
 ;
 
-; mxbr mdbr, meebr, mxb, mxb, meeb, mdtr, mxtr
+; mxbr, mdbr, meebr, mxb, mxb, meeb, mdtr, mxtr
 (define_insn "mul<mode>3"
   [(set (match_operand:FP 0 "register_operand"              "=f,f")
         (mult:FP (match_operand:FP 1 "nonimmediate_operand" "%<f0>,0")
@@ -4629,9 +5274,9 @@
    m<xdee><bt>r\t%0,<op1>%2
    m<xdee>b\t%0,%2"
   [(set_attr "op_type"  "<RRer>,RXE")
-   (set_attr "type"     "fmul<bfp>")])
+   (set_attr "type"     "fmul<mode>")])
 
-; maxbr, madbr, maebr, maxb, madb, maeb
+; madbr, maebr, maxb, madb, maeb
 (define_insn "*fmadd<mode>"
   [(set (match_operand:DSF 0 "register_operand" "=f,f")
 	(plus:DSF (mult:DSF (match_operand:DSF 1 "register_operand" "%f,f")
@@ -4697,7 +5342,7 @@
           (ashift:TI
             (zero_extend:TI
               (mod:DI (match_operand:DI 1 "register_operand" "0,0")
-                      (match_operand:DI 2 "general_operand" "d,m")))
+                      (match_operand:DI 2 "general_operand" "d,RT")))
             (const_int 64))
           (zero_extend:TI (div:DI (match_dup 1) (match_dup 2)))))]
   "TARGET_64BIT"
@@ -4714,7 +5359,7 @@
             (zero_extend:TI
               (mod:DI (match_operand:DI 1 "register_operand" "0,0")
                       (sign_extend:DI
-                        (match_operand:SI 2 "nonimmediate_operand" "d,m"))))
+                        (match_operand:SI 2 "nonimmediate_operand" "d,RT"))))
             (const_int 64))
           (zero_extend:TI
             (div:DI (match_dup 1) (sign_extend:DI (match_dup 2))))))]
@@ -4773,7 +5418,7 @@
               (truncate:DI
                 (umod:TI (match_operand:TI 1 "register_operand" "0,0")
                          (zero_extend:TI
-                           (match_operand:DI 2 "nonimmediate_operand" "d,m")))))
+                           (match_operand:DI 2 "nonimmediate_operand" "d,RT")))))
             (const_int 64))
           (zero_extend:TI
             (truncate:DI
@@ -4891,7 +5536,7 @@
               (truncate:SI
                 (umod:DI (match_operand:DI 1 "register_operand" "0,0")
                          (zero_extend:DI
-                           (match_operand:SI 2 "nonimmediate_operand" "d,m")))))
+                           (match_operand:SI 2 "nonimmediate_operand" "d,RT")))))
             (const_int 32))
           (zero_extend:DI
             (truncate:SI
@@ -5089,7 +5734,7 @@
    d<xde><bt>r\t%0,<op1>%2
    d<xde>b\t%0,%2"
   [(set_attr "op_type"  "<RRer>,RXE")
-   (set_attr "type"     "fdiv<bfp>")])
+   (set_attr "type"     "fdiv<mode>")])
 
 
 ;;
@@ -5111,7 +5756,7 @@
 (define_insn "*anddi3_cc"
   [(set (reg CC_REGNUM)
         (compare (and:DI (match_operand:DI 1 "nonimmediate_operand" "%0,0")
-                         (match_operand:DI 2 "general_operand" "d,m"))
+                         (match_operand:DI 2 "general_operand" "d,RT"))
                  (const_int 0)))
    (set (match_operand:DI 0 "register_operand" "=d,d")
         (and:DI (match_dup 1) (match_dup 2)))]
@@ -5119,12 +5764,13 @@
   "@
    ngr\t%0,%2
    ng\t%0,%2"
-  [(set_attr "op_type"  "RRE,RXY")])
+  [(set_attr "op_type"  "RRE,RXY")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1")])
 
 (define_insn "*anddi3_cconly"
   [(set (reg CC_REGNUM)
         (compare (and:DI (match_operand:DI 1 "nonimmediate_operand" "%0,0")
-                         (match_operand:DI 2 "general_operand" "d,m"))
+                         (match_operand:DI 2 "general_operand" "d,RT"))
                  (const_int 0)))
    (clobber (match_scratch:DI 0 "=d,d"))]
   "s390_match_ccmode(insn, CCTmode) && TARGET_64BIT
@@ -5133,16 +5779,17 @@
   "@
    ngr\t%0,%2
    ng\t%0,%2"
-  [(set_attr "op_type"  "RRE,RXY")])
+  [(set_attr "op_type"  "RRE,RXY")
+   (set_attr "z10prop" "z10_super_E1, z10_super_E1")])
 
-(define_insn "*anddi3_extimm"
+(define_insn "*anddi3"
   [(set (match_operand:DI 0 "nonimmediate_operand" "=d,d,d,d,d,d,d,d,d,d,AQ,Q")
         (and:DI (match_operand:DI 1 "nonimmediate_operand"
                                     "%d,o,0,0,0,0,0,0,0,0,0,0")
                 (match_operand:DI 2 "general_operand"
-                                    "M,M,N0HDF,N1HDF,N2HDF,N3HDF,N0SDF,N1SDF,d,m,NxQDF,Q")))
+                                    "M,M,N0HDF,N1HDF,N2HDF,N3HDF,N0SDF,N1SDF,d,RT,NxQDF,Q")))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_64BIT && TARGET_EXTIMM && s390_logical_operator_ok_p (operands)"
+  "TARGET_64BIT && s390_logical_operator_ok_p (operands)"
   "@
    #
    #
@@ -5156,28 +5803,20 @@
    ng\t%0,%2
    #
    #"
-  [(set_attr "op_type" "RRE,RXE,RI,RI,RI,RI,RIL,RIL,RRE,RXY,SI,SS")])
-
-(define_insn "*anddi3"
-  [(set (match_operand:DI 0 "nonimmediate_operand" "=d,d,d,d,d,d,d,d,AQ,Q")
-        (and:DI (match_operand:DI 1 "nonimmediate_operand"
-                                    "%d,o,0,0,0,0,0,0,0,0")
-                (match_operand:DI 2 "general_operand"
-                                    "M,M,N0HDF,N1HDF,N2HDF,N3HDF,d,m,NxQDF,Q")))
-   (clobber (reg:CC CC_REGNUM))]
-  "TARGET_64BIT && !TARGET_EXTIMM && s390_logical_operator_ok_p (operands)"
-  "@
-   #
-   #
-   nihh\t%0,%j2
-   nihl\t%0,%j2
-   nilh\t%0,%j2
-   nill\t%0,%j2
-   ngr\t%0,%2
-   ng\t%0,%2
-   #
-   #"
-  [(set_attr "op_type" "RRE,RXE,RI,RI,RI,RI,RRE,RXY,SI,SS")])
+  [(set_attr "op_type" "RRE,RXE,RI,RI,RI,RI,RIL,RIL,RRE,RXY,SI,SS")
+   (set_attr "cpu_facility" "*,*,*,*,*,*,extimm,extimm,*,*,*,*")
+   (set_attr "z10prop" "*,
+                        *,
+                        z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1,
+                        *,
+                        *")])
 
 (define_split
   [(set (match_operand:DI 0 "s_operand" "")
@@ -5207,7 +5846,8 @@
    nr\t%0,%2
    n\t%0,%2
    ny\t%0,%2"
-  [(set_attr "op_type"  "RIL,RR,RX,RXY")])
+  [(set_attr "op_type"  "RIL,RR,RX,RXY")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1,z10_super_E1,z10_super_E1")])
 
 (define_insn "*andsi3_cconly"
   [(set (reg CC_REGNUM)
@@ -5223,7 +5863,8 @@
    nr\t%0,%2
    n\t%0,%2
    ny\t%0,%2"
-  [(set_attr "op_type"  "RIL,RR,RX,RXY")])
+  [(set_attr "op_type"  "RIL,RR,RX,RXY")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1,z10_super_E1,z10_super_E1")])
 
 (define_insn "*andsi3_zarch"
   [(set (match_operand:SI 0 "nonimmediate_operand" "=d,d,d,d,d,d,d,d,AQ,Q")
@@ -5244,7 +5885,17 @@
    ny\t%0,%2
    #
    #"
-  [(set_attr "op_type"  "RRE,RXE,RI,RI,RIL,RR,RX,RXY,SI,SS")])
+  [(set_attr "op_type"  "RRE,RXE,RI,RI,RIL,RR,RX,RXY,SI,SS")
+   (set_attr "z10prop" "*,
+                        *,
+                        z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1,
+                        *,
+                        *")])
 
 (define_insn "*andsi3_esa"
   [(set (match_operand:SI 0 "nonimmediate_operand" "=d,d,AQ,Q")
@@ -5257,7 +5908,9 @@
    n\t%0,%2
    #
    #"
-  [(set_attr "op_type"  "RR,RX,SI,SS")])
+  [(set_attr "op_type"  "RR,RX,SI,SS")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1,*,*")])
+
 
 (define_split
   [(set (match_operand:SI 0 "s_operand" "")
@@ -5284,7 +5937,9 @@
    nill\t%0,%x2
    #
    #"
-  [(set_attr "op_type"  "RR,RI,SI,SS")])
+  [(set_attr "op_type"  "RR,RI,SI,SS")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1,*,*")
+])
 
 (define_insn "*andhi3_esa"
   [(set (match_operand:HI 0 "nonimmediate_operand" "=d,AQ,Q")
@@ -5296,7 +5951,9 @@
    nr\t%0,%2
    #
    #"
-  [(set_attr "op_type"  "RR,SI,SS")])
+  [(set_attr "op_type"  "RR,SI,SS")
+   (set_attr "z10prop" "z10_super_E1,*,*")
+])
 
 (define_split
   [(set (match_operand:HI 0 "s_operand" "")
@@ -5324,7 +5981,8 @@
    ni\t%S0,%b2
    niy\t%S0,%b2
    #"
-  [(set_attr "op_type"  "RR,RI,SI,SIY,SS")])
+  [(set_attr "op_type"  "RR,RI,SI,SIY,SS")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1,z10_super,z10_super,*")])
 
 (define_insn "*andqi3_esa"
   [(set (match_operand:QI 0 "nonimmediate_operand" "=d,Q,Q")
@@ -5336,7 +5994,8 @@
    nr\t%0,%2
    ni\t%S0,%b2
    #"
-  [(set_attr "op_type"  "RR,SI,SS")])
+  [(set_attr "op_type"  "RR,SI,SS")
+   (set_attr "z10prop" "z10_super_E1,z10_super,*")])
 
 ;
 ; Block and (NC) patterns.
@@ -5385,7 +6044,7 @@
      (clobber (reg:CC CC_REGNUM))])]
   "s390_offset_p (operands[0], operands[3], operands[2])
    && s390_offset_p (operands[1], operands[4], operands[2])
-   && !s390_overlap_p (operands[0], operands[1], 
+   && !s390_overlap_p (operands[0], operands[1],
                        INTVAL (operands[2]) + INTVAL (operands[5]))
    && INTVAL (operands[2]) + INTVAL (operands[5]) <= 256"
   [(parallel
@@ -5416,7 +6075,7 @@
 (define_insn "*iordi3_cc"
   [(set (reg CC_REGNUM)
         (compare (ior:DI (match_operand:DI 1 "nonimmediate_operand" "%0,0")
-                         (match_operand:DI 2 "general_operand" "d,m"))
+                         (match_operand:DI 2 "general_operand" "d,RT"))
                  (const_int 0)))
    (set (match_operand:DI 0 "register_operand" "=d,d")
         (ior:DI (match_dup 1) (match_dup 2)))]
@@ -5424,27 +6083,29 @@
   "@
    ogr\t%0,%2
    og\t%0,%2"
-  [(set_attr "op_type"  "RRE,RXY")])
+  [(set_attr "op_type"  "RRE,RXY")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1")])
 
 (define_insn "*iordi3_cconly"
   [(set (reg CC_REGNUM)
         (compare (ior:DI (match_operand:DI 1 "nonimmediate_operand" "%0,0")
-                         (match_operand:DI 2 "general_operand" "d,m"))
+                         (match_operand:DI 2 "general_operand" "d,RT"))
                  (const_int 0)))
    (clobber (match_scratch:DI 0 "=d,d"))]
   "s390_match_ccmode(insn, CCTmode) && TARGET_64BIT"
   "@
    ogr\t%0,%2
    og\t%0,%2"
-  [(set_attr "op_type"  "RRE,RXY")])
+  [(set_attr "op_type"  "RRE,RXY")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1")])
 
-(define_insn "*iordi3_extimm"
+(define_insn "*iordi3"
   [(set (match_operand:DI 0 "nonimmediate_operand" "=d,d,d,d,d,d,d,d,AQ,Q")
         (ior:DI (match_operand:DI 1 "nonimmediate_operand" "%0,0,0,0,0,0,0,0,0,0")
                 (match_operand:DI 2 "general_operand"
-                                    "N0HD0,N1HD0,N2HD0,N3HD0,N0SD0,N1SD0,d,m,NxQD0,Q")))
+                                    "N0HD0,N1HD0,N2HD0,N3HD0,N0SD0,N1SD0,d,RT,NxQD0,Q")))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_64BIT && TARGET_EXTIMM && s390_logical_operator_ok_p (operands)"
+  "TARGET_64BIT && s390_logical_operator_ok_p (operands)"
   "@
    oihh\t%0,%i2
    oihl\t%0,%i2
@@ -5456,25 +6117,18 @@
    og\t%0,%2
    #
    #"
-  [(set_attr "op_type"  "RI,RI,RI,RI,RIL,RIL,RRE,RXY,SI,SS")])
-
-(define_insn "*iordi3"
-  [(set (match_operand:DI 0 "nonimmediate_operand" "=d,d,d,d,d,d,AQ,Q")
-        (ior:DI (match_operand:DI 1 "nonimmediate_operand" "%0,0,0,0,0,0,0,0")
-                (match_operand:DI 2 "general_operand"
-                                    "N0HD0,N1HD0,N2HD0,N3HD0,d,m,NxQD0,Q")))
-   (clobber (reg:CC CC_REGNUM))]
-  "TARGET_64BIT && !TARGET_EXTIMM && s390_logical_operator_ok_p (operands)"
-  "@
-   oihh\t%0,%i2
-   oihl\t%0,%i2
-   oilh\t%0,%i2
-   oill\t%0,%i2
-   ogr\t%0,%2
-   og\t%0,%2
-   #
-   #"
-  [(set_attr "op_type"  "RI,RI,RI,RI,RRE,RXY,SI,SS")])
+  [(set_attr "op_type"  "RI,RI,RI,RI,RIL,RIL,RRE,RXY,SI,SS")
+   (set_attr "cpu_facility" "*,*,*,*,extimm,extimm,*,*,*,*")
+   (set_attr "z10prop" "z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1,
+                        *,
+                        *")])
 
 (define_split
   [(set (match_operand:DI 0 "s_operand" "")
@@ -5503,7 +6157,8 @@
    or\t%0,%2
    o\t%0,%2
    oy\t%0,%2"
-  [(set_attr "op_type"  "RIL,RR,RX,RXY")])
+  [(set_attr "op_type"  "RIL,RR,RX,RXY")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1,z10_super_E1,z10_super_E1")])
 
 (define_insn "*iorsi3_cconly"
   [(set (reg CC_REGNUM)
@@ -5517,7 +6172,8 @@
    or\t%0,%2
    o\t%0,%2
    oy\t%0,%2"
-  [(set_attr "op_type"  "RIL,RR,RX,RXY")])
+  [(set_attr "op_type"  "RIL,RR,RX,RXY")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1,z10_super_E1,z10_super_E1")])
 
 (define_insn "*iorsi3_zarch"
   [(set (match_operand:SI 0 "nonimmediate_operand" "=d,d,d,d,d,d,AQ,Q")
@@ -5534,7 +6190,15 @@
    oy\t%0,%2
    #
    #"
-  [(set_attr "op_type"  "RI,RI,RIL,RR,RX,RXY,SI,SS")])
+  [(set_attr "op_type"  "RI,RI,RIL,RR,RX,RXY,SI,SS")
+   (set_attr "z10prop" "z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1,
+                        z10_super_E1,
+                        *,
+                        *")])
 
 (define_insn "*iorsi3_esa"
   [(set (match_operand:SI 0 "nonimmediate_operand" "=d,d,AQ,Q")
@@ -5547,7 +6211,8 @@
    o\t%0,%2
    #
    #"
-  [(set_attr "op_type"  "RR,RX,SI,SS")])
+  [(set_attr "op_type"  "RR,RX,SI,SS")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1,*,*")])
 
 (define_split
   [(set (match_operand:SI 0 "s_operand" "")
@@ -5574,7 +6239,8 @@
    oill\t%0,%x2
    #
    #"
-  [(set_attr "op_type"  "RR,RI,SI,SS")])
+  [(set_attr "op_type"  "RR,RI,SI,SS")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1,*,*")])
 
 (define_insn "*iorhi3_esa"
   [(set (match_operand:HI 0 "nonimmediate_operand" "=d,AQ,Q")
@@ -5586,7 +6252,8 @@
    or\t%0,%2
    #
    #"
-  [(set_attr "op_type"  "RR,SI,SS")])
+  [(set_attr "op_type"  "RR,SI,SS")
+   (set_attr "z10prop" "z10_super_E1,*,*")])
 
 (define_split
   [(set (match_operand:HI 0 "s_operand" "")
@@ -5614,7 +6281,8 @@
    oi\t%S0,%b2
    oiy\t%S0,%b2
    #"
-  [(set_attr "op_type"  "RR,RI,SI,SIY,SS")])
+  [(set_attr "op_type"  "RR,RI,SI,SIY,SS")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1,z10_super,z10_super,*")])
 
 (define_insn "*iorqi3_esa"
   [(set (match_operand:QI 0 "nonimmediate_operand" "=d,Q,Q")
@@ -5626,7 +6294,8 @@
    or\t%0,%2
    oi\t%S0,%b2
    #"
-  [(set_attr "op_type"  "RR,SI,SS")])
+  [(set_attr "op_type"  "RR,SI,SS")
+   (set_attr "z10prop" "z10_super_E1,z10_super,*")])
 
 ;
 ; Block inclusive or (OC) patterns.
@@ -5675,7 +6344,7 @@
      (clobber (reg:CC CC_REGNUM))])]
   "s390_offset_p (operands[0], operands[3], operands[2])
    && s390_offset_p (operands[1], operands[4], operands[2])
-   && !s390_overlap_p (operands[0], operands[1], 
+   && !s390_overlap_p (operands[0], operands[1],
                        INTVAL (operands[2]) + INTVAL (operands[5]))
    && INTVAL (operands[2]) + INTVAL (operands[5]) <= 256"
   [(parallel
@@ -5706,7 +6375,7 @@
 (define_insn "*xordi3_cc"
   [(set (reg CC_REGNUM)
         (compare (xor:DI (match_operand:DI 1 "nonimmediate_operand" "%0,0")
-                         (match_operand:DI 2 "general_operand" "d,m"))
+                         (match_operand:DI 2 "general_operand" "d,RT"))
                  (const_int 0)))
    (set (match_operand:DI 0 "register_operand" "=d,d")
         (xor:DI (match_dup 1) (match_dup 2)))]
@@ -5714,26 +6383,28 @@
   "@
    xgr\t%0,%2
    xg\t%0,%2"
-  [(set_attr "op_type"  "RRE,RXY")])
+  [(set_attr "op_type"  "RRE,RXY")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1")])
 
 (define_insn "*xordi3_cconly"
   [(set (reg CC_REGNUM)
         (compare (xor:DI (match_operand:DI 1 "nonimmediate_operand" "%0,0")
-                         (match_operand:DI 2 "general_operand" "d,m"))
+                         (match_operand:DI 2 "general_operand" "d,RT"))
                  (const_int 0)))
    (clobber (match_scratch:DI 0 "=d,d"))]
   "s390_match_ccmode(insn, CCTmode) && TARGET_64BIT"
   "@
    xgr\t%0,%2
    xg\t%0,%2"
-  [(set_attr "op_type"  "RRE,RXY")])
+  [(set_attr "op_type"  "RRE,RXY")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1")])
 
-(define_insn "*xordi3_extimm"
+(define_insn "*xordi3"
   [(set (match_operand:DI 0 "nonimmediate_operand" "=d,d,d,d,AQ,Q")
         (xor:DI (match_operand:DI 1 "nonimmediate_operand" "%0,0,0,0,0,0")
-                (match_operand:DI 2 "general_operand" "N0SD0,N1SD0,d,m,NxQD0,Q")))
+                (match_operand:DI 2 "general_operand" "N0SD0,N1SD0,d,RT,NxQD0,Q")))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_64BIT && TARGET_EXTIMM && s390_logical_operator_ok_p (operands)"
+  "TARGET_64BIT && s390_logical_operator_ok_p (operands)"
   "@
    xihf\t%0,%k2
    xilf\t%0,%k2
@@ -5741,20 +6412,9 @@
    xg\t%0,%2
    #
    #"
-  [(set_attr "op_type"  "RIL,RIL,RRE,RXY,SI,SS")])
-
-(define_insn "*xordi3"
-  [(set (match_operand:DI 0 "nonimmediate_operand" "=d,d,AQ,Q")
-        (xor:DI (match_operand:DI 1 "nonimmediate_operand" "%0,0,0,0")
-                (match_operand:DI 2 "general_operand" "d,m,NxQD0,Q")))
-   (clobber (reg:CC CC_REGNUM))]
-  "TARGET_64BIT && !TARGET_EXTIMM && s390_logical_operator_ok_p (operands)"
-  "@
-   xgr\t%0,%2
-   xg\t%0,%2
-   #
-   #"
-  [(set_attr "op_type"  "RRE,RXY,SI,SS")])
+  [(set_attr "op_type"  "RIL,RIL,RRE,RXY,SI,SS")
+   (set_attr "cpu_facility" "extimm,extimm,*,*,*,*")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1,z10_super_E1,z10_super_E1,*,*")])
 
 (define_split
   [(set (match_operand:DI 0 "s_operand" "")
@@ -5783,7 +6443,8 @@
    xr\t%0,%2
    x\t%0,%2
    xy\t%0,%2"
-  [(set_attr "op_type"  "RIL,RR,RX,RXY")])
+  [(set_attr "op_type"  "RIL,RR,RX,RXY")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1,z10_super_E1,z10_super_E1")])
 
 (define_insn "*xorsi3_cconly"
   [(set (reg CC_REGNUM)
@@ -5797,7 +6458,8 @@
    xr\t%0,%2
    x\t%0,%2
    xy\t%0,%2"
-  [(set_attr "op_type"  "RIL,RR,RX,RXY")])
+  [(set_attr "op_type"  "RIL,RR,RX,RXY")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1,z10_super_E1,z10_super_E1")])
 
 (define_insn "*xorsi3"
   [(set (match_operand:SI 0 "nonimmediate_operand" "=d,d,d,d,AQ,Q")
@@ -5812,7 +6474,8 @@
    xy\t%0,%2
    #
    #"
-  [(set_attr "op_type"  "RIL,RR,RX,RXY,SI,SS")])
+  [(set_attr "op_type"  "RIL,RR,RX,RXY,SI,SS")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1,z10_super_E1,z10_super_E1,*,*")])
 
 (define_split
   [(set (match_operand:SI 0 "s_operand" "")
@@ -5839,7 +6502,8 @@
    xr\t%0,%2
    #
    #"
-  [(set_attr "op_type"  "RIL,RR,SI,SS")])
+  [(set_attr "op_type"  "RIL,RR,SI,SS")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1,*,*")])
 
 (define_split
   [(set (match_operand:HI 0 "s_operand" "")
@@ -5867,7 +6531,9 @@
    xi\t%S0,%b2
    xiy\t%S0,%b2
    #"
-  [(set_attr "op_type"  "RIL,RR,SI,SIY,SS")])
+  [(set_attr "op_type"  "RIL,RR,SI,SIY,SS")
+   (set_attr "z10prop" "z10_super_E1,z10_super_E1,z10_super,z10_super,*")])
+
 
 ;
 ; Block exclusive or (XC) patterns.
@@ -5916,7 +6582,7 @@
      (clobber (reg:CC CC_REGNUM))])]
   "s390_offset_p (operands[0], operands[3], operands[2])
    && s390_offset_p (operands[1], operands[4], operands[2])
-   && !s390_overlap_p (operands[0], operands[1], 
+   && !s390_overlap_p (operands[0], operands[1],
                        INTVAL (operands[2]) + INTVAL (operands[5]))
    && INTVAL (operands[2]) + INTVAL (operands[5]) <= 256"
   [(parallel
@@ -5988,7 +6654,7 @@
   "TARGET_64BIT && s390_match_ccmode (insn, CCAmode)"
   "lcgfr\t%0,%1"
   [(set_attr "op_type"  "RRE")])
-  
+
 (define_insn "*negdi2_sign"
   [(set (match_operand:DI 0 "register_operand" "=d")
         (neg:DI (sign_extend:DI (match_operand:SI 1 "register_operand" "d"))))
@@ -6006,7 +6672,8 @@
         (neg:GPR (match_dup 1)))]
   "s390_match_ccmode (insn, CCAmode)"
   "lc<g>r\t%0,%1"
-  [(set_attr "op_type"  "RR<E>")])
+  [(set_attr "op_type"  "RR<E>")
+   (set_attr "z10prop" "z10_super_c_E1")])
 
 ; lcr, lcgr
 (define_insn "*neg<mode>2_cconly"
@@ -6016,7 +6683,8 @@
    (clobber (match_scratch:GPR 0 "=d"))]
   "s390_match_ccmode (insn, CCAmode)"
   "lc<g>r\t%0,%1"
-  [(set_attr "op_type"  "RR<E>")])
+  [(set_attr "op_type"  "RR<E>")
+   (set_attr "z10prop" "z10_super_c_E1")])
 
 ; lcr, lcgr
 (define_insn "*neg<mode>2"
@@ -6025,7 +6693,8 @@
    (clobber (reg:CC CC_REGNUM))]
   ""
   "lc<g>r\t%0,%1"
-  [(set_attr "op_type"  "RR<E>")])
+  [(set_attr "op_type"  "RR<E>")
+   (set_attr "z10prop" "z10_super_c_E1")])
 
 (define_insn_and_split "*negdi2_31"
   [(set (match_operand:DI 0 "register_operand" "=d")
@@ -6094,10 +6763,10 @@
 (define_insn "*neg<mode>2_nocc"
   [(set (match_operand:FP 0 "register_operand"         "=f")
         (neg:FP (match_operand:FP 1 "register_operand" "<fT0>")))]
-  "TARGET_HARD_FLOAT && TARGET_DFP"
+  "TARGET_DFP"
   "lcdfr\t%0,%1"
   [(set_attr "op_type"  "RRE")
-   (set_attr "type"     "fsimp<bfp>")])
+   (set_attr "type"     "fsimp<mode>")])
 
 ; lcxbr, lcdbr, lcebr
 (define_insn "*neg<mode>2"
@@ -6147,9 +6816,10 @@
         (abs:GPR (match_dup 1)))]
   "s390_match_ccmode (insn, CCAmode)"
   "lp<g>r\t%0,%1"
-  [(set_attr "op_type"  "RR<E>")])
+  [(set_attr "op_type"  "RR<E>")
+   (set_attr "z10prop" "z10_c")])
 
-; lpr, lpgr  
+; lpr, lpgr
 (define_insn "*abs<mode>2_cconly"
   [(set (reg CC_REGNUM)
         (compare (abs:GPR (match_operand:GPR 1 "register_operand" "d"))
@@ -6157,7 +6827,8 @@
    (clobber (match_scratch:GPR 0 "=d"))]
   "s390_match_ccmode (insn, CCAmode)"
   "lp<g>r\t%0,%1"
-  [(set_attr "op_type"  "RR<E>")])
+  [(set_attr "op_type"  "RR<E>")
+   (set_attr "z10prop" "z10_c")])
 
 ; lpr, lpgr
 (define_insn "abs<mode>2"
@@ -6166,7 +6837,8 @@
    (clobber (reg:CC CC_REGNUM))]
   ""
   "lp<g>r\t%0,%1"
-  [(set_attr "op_type"  "RR<E>")])
+  [(set_attr "op_type"  "RR<E>")
+   (set_attr "z10prop" "z10_c")])
 
 ;
 ; abs(df|sf)2 instruction pattern(s).
@@ -6207,10 +6879,10 @@
 (define_insn "*abs<mode>2_nocc"
   [(set (match_operand:FP 0 "register_operand"         "=f")
         (abs:FP (match_operand:FP 1 "register_operand" "<fT0>")))]
-  "TARGET_HARD_FLOAT && TARGET_DFP"
+  "TARGET_DFP"
   "lpdfr\t%0,%1"
   [(set_attr "op_type"  "RRE")
-   (set_attr "type"     "fsimp<bfp>")])
+   (set_attr "type"     "fsimp<mode>")])
 
 ; lpxbr, lpdbr, lpebr
 (define_insn "*abs<mode>2"
@@ -6242,7 +6914,7 @@
   "TARGET_64BIT && s390_match_ccmode (insn, CCAmode)"
   "lngfr\t%0,%1"
   [(set_attr "op_type"  "RRE")])
- 
+
 (define_insn "*negabsdi2_sign"
   [(set (match_operand:DI 0 "register_operand" "=d")
 	(neg:DI (abs:DI (sign_extend:DI
@@ -6261,7 +6933,8 @@
         (neg:GPR (abs:GPR (match_dup 1))))]
   "s390_match_ccmode (insn, CCAmode)"
   "ln<g>r\t%0,%1"
-  [(set_attr "op_type"  "RR<E>")])
+  [(set_attr "op_type"  "RR<E>")
+   (set_attr "z10prop" "z10_c")])
 
 ; lnr, lngr
 (define_insn "*negabs<mode>2_cconly"
@@ -6271,7 +6944,8 @@
    (clobber (match_scratch:GPR 0 "=d"))]
   "s390_match_ccmode (insn, CCAmode)"
   "ln<g>r\t%0,%1"
-  [(set_attr "op_type"  "RR<E>")])
+  [(set_attr "op_type"  "RR<E>")
+   (set_attr "z10prop" "z10_c")])
 
 ; lnr, lngr
 (define_insn "*negabs<mode>2"
@@ -6280,7 +6954,8 @@
    (clobber (reg:CC CC_REGNUM))]
   ""
   "ln<g>r\t%0,%1"
-  [(set_attr "op_type" "RR<E>")])
+  [(set_attr "op_type" "RR<E>")
+   (set_attr "z10prop" "z10_c")])
 
 ;
 ; Floating point
@@ -6313,10 +6988,10 @@
 (define_insn "*negabs<mode>2_nocc"
   [(set (match_operand:FP 0 "register_operand"                  "=f")
         (neg:FP (abs:FP (match_operand:BFP 1 "register_operand" "<fT0>"))))]
-  "TARGET_HARD_FLOAT && TARGET_DFP"
+  "TARGET_DFP"
   "lndfr\t%0,%1"
   [(set_attr "op_type"  "RRE")
-   (set_attr "type"     "fsimp<bfp>")])
+   (set_attr "type"     "fsimp<mode>")])
 
 ; lnxbr, lndbr, lnebr
 (define_insn "*negabs<mode>2"
@@ -6336,12 +7011,12 @@
 (define_insn "copysign<mode>3"
   [(set (match_operand:FP 0 "register_operand" "=f")
 	(unspec:FP [(match_operand:FP 1 "register_operand" "<fT0>")
-		    (match_operand:FP 2 "register_operand" "f")] 
+		    (match_operand:FP 2 "register_operand" "f")]
 		    UNSPEC_COPYSIGN))]
-  "TARGET_HARD_FLOAT && TARGET_DFP"
+  "TARGET_DFP"
   "cpsdr\t%0,%2,%1"
   [(set_attr "op_type"  "RRF")
-   (set_attr "type"     "fsimp<bfp>")])
+   (set_attr "type"     "fsimp<mode>")])
 
 ;;
 ;;- Square root instructions.
@@ -6351,7 +7026,7 @@
 ; sqrt(df|sf)2 instruction pattern(s).
 ;
 
-; sqxbr, sqdbr, sqebr, sqxb, sqdb, sqeb
+; sqxbr, sqdbr, sqebr, sqdb, sqeb
 (define_insn "sqrt<mode>2"
   [(set (match_operand:BFP 0 "register_operand" "=f,f")
 	(sqrt:BFP (match_operand:BFP 1 "general_operand" "f,<Rf>")))]
@@ -6398,7 +7073,7 @@
 
   emit_insn (gen_clztidi2 (wide_reg, operands[1], msb));
 
-  insn = emit_move_insn (operands[0], gen_highpart (DImode, wide_reg));  
+  insn = emit_move_insn (operands[0], gen_highpart (DImode, wide_reg));
   set_unique_reg_note (insn, REG_EQUAL, clz_equal);
 
   DONE;
@@ -6407,16 +7082,16 @@
 (define_insn "clztidi2"
   [(set (match_operand:TI 0 "register_operand" "=d")
 	(ior:TI
-	  (ashift:TI 
-            (zero_extend:TI 
+	  (ashift:TI
+            (zero_extend:TI
    	      (xor:DI (match_operand:DI 1 "register_operand" "d")
                       (lshiftrt (match_operand:DI 2 "const_int_operand" "")
 				(subreg:SI (clz:DI (match_dup 1)) 4))))
-	    
+
 	    (const_int 64))
           (zero_extend:TI (clz:DI (match_dup 1)))))
    (clobber (reg:CC CC_REGNUM))]
-  "(unsigned HOST_WIDE_INT) INTVAL (operands[2]) 
+  "(unsigned HOST_WIDE_INT) INTVAL (operands[2])
    == (unsigned HOST_WIDE_INT) 1 << 63
    && TARGET_EXTIMM && TARGET_64BIT"
   "flogr\t%0,%1"
@@ -6439,7 +7114,8 @@
   "TARGET_CPU_ZARCH"
   "rll<g>\t%0,%1,%Y2"
   [(set_attr "op_type"  "RSE")
-   (set_attr "atype"    "reg")])
+   (set_attr "atype"    "reg")
+   (set_attr "z10prop" "z10_super_E1")])
 
 ; rll, rllg
 (define_insn "*rotl<mode>3_and"
@@ -6450,7 +7126,8 @@
   "TARGET_CPU_ZARCH && (INTVAL (operands[3]) & 63) == 63"
   "rll<g>\t%0,%1,%Y2"
   [(set_attr "op_type"  "RSE")
-   (set_attr "atype"    "reg")])
+   (set_attr "atype"    "reg")
+   (set_attr "z10prop" "z10_super_E1")])
 
 
 ;;
@@ -6486,7 +7163,8 @@
   ""
   "s<lr>l<g>\t%0,<1>%Y2"
   [(set_attr "op_type"  "RS<E>")
-   (set_attr "atype"    "reg")])
+   (set_attr "atype"    "reg")
+   (set_attr "z10prop" "z10_super_E1")])
 
 ; sldl, srdl
 (define_insn "*<shift>di3_31_and"
@@ -6508,7 +7186,8 @@
   "(INTVAL (operands[3]) & 63) == 63"
   "s<lr>l<g>\t%0,<1>%Y2"
   [(set_attr "op_type"  "RS<E>")
-   (set_attr "atype"    "reg")])
+   (set_attr "atype"    "reg")
+   (set_attr "z10prop" "z10_super_E1")])
 
 ;
 ; ashr(di|si)3 instruction pattern(s).
@@ -6567,7 +7246,8 @@
   "s390_match_ccmode(insn, CCSmode)"
   "sra<g>\t%0,<1>%Y2"
   [(set_attr "op_type"  "RS<E>")
-   (set_attr "atype"    "reg")])
+   (set_attr "atype"    "reg")
+   (set_attr "z10prop" "z10_super_E1")])
 
 ; sra, srag
 (define_insn "*ashr<mode>3_cconly"
@@ -6579,7 +7259,8 @@
   "s390_match_ccmode(insn, CCSmode)"
   "sra<g>\t%0,<1>%Y2"
   [(set_attr "op_type"  "RS<E>")
-   (set_attr "atype"    "reg")])
+   (set_attr "atype"    "reg")
+   (set_attr "z10prop" "z10_super_E1")])
 
 ; sra, srag
 (define_insn "*ashr<mode>3"
@@ -6590,7 +7271,8 @@
   ""
   "sra<g>\t%0,<1>%Y2"
   [(set_attr "op_type"  "RS<E>")
-   (set_attr "atype"    "reg")])
+   (set_attr "atype"    "reg")
+   (set_attr "z10prop" "z10_super_E1")])
 
 
 ; shift pattern with implicit ANDs
@@ -6645,7 +7327,8 @@
   "s390_match_ccmode(insn, CCSmode) && (INTVAL (operands[3]) & 63) == 63"
   "sra<g>\t%0,<1>%Y2"
   [(set_attr "op_type"  "RS<E>")
-   (set_attr "atype"    "reg")])
+   (set_attr "atype"    "reg")
+   (set_attr "z10prop" "z10_super_E1")])
 
 ; sra, srag
 (define_insn "*ashr<mode>3_cconly_and"
@@ -6658,7 +7341,8 @@
   "s390_match_ccmode(insn, CCSmode) && (INTVAL (operands[3]) & 63) == 63"
   "sra<g>\t%0,<1>%Y2"
   [(set_attr "op_type"  "RS<E>")
-   (set_attr "atype"    "reg")])
+   (set_attr "atype"    "reg")
+   (set_attr "z10prop" "z10_super_E1")])
 
 ; sra, srag
 (define_insn "*ashr<mode>3_and"
@@ -6670,7 +7354,8 @@
   "(INTVAL (operands[3]) & 63) == 63"
   "sra<g>\t%0,<1>%Y2"
   [(set_attr "op_type"  "RS<E>")
-   (set_attr "atype"    "reg")])
+   (set_attr "atype"    "reg")
+   (set_attr "z10prop" "z10_super_E1")])
 
 
 ;;
@@ -6830,7 +7515,7 @@
   ""
 {
   if (operands[1] != const0_rtx) FAIL;
-  operands[0] = s390_emit_compare (GET_CODE (operands[0]), 
+  operands[0] = s390_emit_compare (GET_CODE (operands[0]),
                                    s390_compare_op0, s390_compare_op1);
 })
 
@@ -6842,6 +7527,34 @@
   [(set_attr "op_type" "RI")
    (set_attr "type"  "branch")])
 
+; crt, cgrt, cit, cgit
+(define_insn "*cmp_and_trap_signed_int<mode>"
+  [(trap_if (match_operator 0 "s390_signed_integer_comparison"
+	       [(match_operand:GPR 1 "register_operand"  "d,d")
+		(match_operand:GPR 2 "nonmemory_operand" "d,K")])
+	    (const_int 0))]
+  "TARGET_Z10"
+  "@
+   c<g>rt%C0\t%1,%2
+   c<g>it%C0\t%1,%h2"
+  [(set_attr "op_type" "RRF,RIE")
+   (set_attr "type"    "branch")
+   (set_attr "z10prop" "z10_c,*")])
+
+; clrt, clgrt, clfit, clgit
+(define_insn "*cmp_and_trap_unsigned_int<mode>"
+  [(trap_if (match_operator 0 "s390_unsigned_integer_comparison"
+	       [(match_operand:GPR 1 "register_operand"  "d,d")
+		(match_operand:GPR 2 "nonmemory_operand" "d,D")])
+	    (const_int 0))]
+  "TARGET_Z10"
+  "@
+   cl<g>rt%C0\t%1,%2
+   cl<gf>it%C0\t%1,%x2"
+  [(set_attr "op_type" "RRF,RIE")
+   (set_attr "type"    "branch")
+   (set_attr "z10prop" "z10_c,*")])
+
 ;;
 ;;- Loop instructions.
 ;;
@@ -6902,6 +7615,9 @@
                            (pc)))]
   ""
   [(set_attr "op_type"  "RI")
+   ; Strictly speaking, the z10 properties are valid for brct only, however, it does not
+   ; hurt us in the (rare) case of ahi.
+   (set_attr "z10prop"  "z10_super")
    (set_attr "type"  "branch")
    (set (attr "length")
         (if_then_else (lt (abs (minus (pc) (match_dup 0))) (const_int 60000))
@@ -6941,6 +7657,9 @@
                            (pc)))]
   ""
   [(set_attr "op_type"  "RI")
+   ; Strictly speaking, the z10 properties are valid for brct only, however, it does not
+   ; hurt us in the (rare) case of ahi.
+   (set_attr "z10prop"  "z10_super")
    (set_attr "type"  "branch")
    (set (attr "length")
         (if_then_else (eq (symbol_ref "flag_pic") (const_int 0))
@@ -7007,6 +7726,9 @@
                            (pc)))]
   ""
   [(set_attr "op_type"  "RI")
+   ; Strictly speaking, the z10 properties are valid for brct only, however, it does not
+   ; hurt us in the (rare) case of ahi.
+   (set_attr "z10prop"  "z10_super")
    (set_attr "type"  "branch")
    (set (attr "length")
         (if_then_else (lt (abs (minus (pc) (match_dup 0))) (const_int 60000))
@@ -7073,7 +7795,8 @@
         (if_then_else (match_operand 0 "register_operand" "")
                       (const_string "RR") (const_string "RX")))
    (set_attr "type"  "branch")
-   (set_attr "atype" "agen")])
+   (set_attr "atype" "agen")
+   (set_attr "z10prop" "z10_super")])
 
 ;
 ; casesi instruction pattern(s).
@@ -7411,12 +8134,13 @@
 
 (define_insn "*tls_load_64"
   [(set (match_operand:DI 0 "register_operand" "=d")
-        (unspec:DI [(match_operand:DI 1 "memory_operand" "m")
+        (unspec:DI [(match_operand:DI 1 "memory_operand" "RT")
                     (match_operand:DI 2 "" "")]
 		   UNSPEC_TLS_LOAD))]
   "TARGET_64BIT"
   "lg\t%0,%1%J2"
-  [(set_attr "op_type" "RXE")])
+  [(set_attr "op_type" "RXE")
+   (set_attr "z10prop" "z10_fwd_A3")])
 
 (define_insn "*tls_load_31"
   [(set (match_operand:SI 0 "register_operand" "=d,d")
@@ -7427,7 +8151,8 @@
   "@
    l\t%0,%1%J2
    ly\t%0,%1%J2"
-  [(set_attr "op_type" "RX,RXY")])
+  [(set_attr "op_type" "RX,RXY")
+   (set_attr "z10prop" "z10_fwd_A3,z10_fwd_A3")])
 
 (define_insn "*bras_tls"
   [(set (match_operand 0 "" "")
@@ -7497,6 +8222,8 @@
   ""
   "bcr\t15,0"
   [(set_attr "op_type" "RR")])
+; Although bcr is superscalar on Z10, this variant will never become part of
+; an execution group.
 
 ;
 ; compare and swap patterns.
@@ -7529,7 +8256,7 @@
      (set (reg:CCZ1 CC_REGNUM)
 	  (compare:CCZ1 (match_dup 1) (match_dup 2)))])]
   ""
-  "s390_expand_cs_hqi (<MODE>mode, operands[0], operands[1], 
+  "s390_expand_cs_hqi (<MODE>mode, operands[0], operands[1],
 		       operands[2], operands[3]); DONE;")
 
 (define_expand "sync_compare_and_swap_cc<mode>"
@@ -7582,7 +8309,7 @@
 	  UNSPECV_CAS))
    (set (reg:CCZ1 CC_REGNUM)
 	(compare:CCZ1 (match_dup 1) (match_dup 2)))]
-  "" 
+  ""
   "cs<g>\t%0,%3,%S1"
   [(set_attr "op_type" "RS<E>")
    (set_attr "type"   "sem")])
@@ -7597,7 +8324,7 @@
    (match_operand:HQI 1 "memory_operand")
    (match_operand:HQI 2 "general_operand")]
   ""
-  "s390_expand_atomic (<MODE>mode, SET, operands[0], operands[1], 
+  "s390_expand_atomic (<MODE>mode, SET, operands[0], operands[1],
 		       operands[2], false); DONE;")
 
 (define_expand "sync_<atomic><mode>"
@@ -7605,7 +8332,7 @@
 	(ATOMIC:HQI (match_dup 0)
 		    (match_operand:HQI 1 "general_operand")))]
   ""
-  "s390_expand_atomic (<MODE>mode, <CODE>, NULL_RTX, operands[0], 
+  "s390_expand_atomic (<MODE>mode, <CODE>, NULL_RTX, operands[0],
 		       operands[1], false); DONE;")
 
 (define_expand "sync_old_<atomic><mode>"
@@ -7615,16 +8342,16 @@
 	(ATOMIC:HQI (match_dup 1)
 		    (match_operand:HQI 2 "general_operand")))]
   ""
-  "s390_expand_atomic (<MODE>mode, <CODE>, operands[0], operands[1], 
+  "s390_expand_atomic (<MODE>mode, <CODE>, operands[0], operands[1],
 		       operands[2], false); DONE;")
 
 (define_expand "sync_new_<atomic><mode>"
   [(set (match_operand:HQI 0 "register_operand")
 	(ATOMIC:HQI (match_operand:HQI 1 "memory_operand")
-		    (match_operand:HQI 2 "general_operand"))) 
+		    (match_operand:HQI 2 "general_operand")))
    (set (match_dup 1) (ATOMIC:HQI (match_dup 1) (match_dup 2)))]
   ""
-  "s390_expand_atomic (<MODE>mode, <CODE>, operands[0], operands[1], 
+  "s390_expand_atomic (<MODE>mode, <CODE>, operands[0], operands[1],
 		       operands[2], true); DONE;")
 
 ;;
@@ -7736,7 +8463,7 @@
 
   if (TARGET_BACKCHAIN)
     temp = force_reg (Pmode, operand_subword (operands[1], 0, 0, mode));
-    
+
   emit_move_insn (base, operand_subword (operands[1], 2, 0, mode));
   emit_move_insn (operands[0], operand_subword (operands[1], 1, 0, mode));
 
@@ -7824,7 +8551,8 @@
   "TARGET_CPU_ZARCH && GET_MODE (operands[0]) == Pmode"
   "larl\t%0,%1"
   [(set_attr "op_type" "RIL")
-   (set_attr "type"    "larl")])
+   (set_attr "type"    "larl")
+   (set_attr "z10prop" "z10_super_A1")])
 
 (define_insn "main_pool"
   [(set (match_operand 0 "register_operand" "=a")
@@ -7833,7 +8561,7 @@
 {
   gcc_unreachable ();
 }
-  [(set (attr "type") 
+  [(set (attr "type")
         (if_then_else (ne (symbol_ref "TARGET_CPU_ZARCH") (const_int 0))
                       (const_string "larl") (const_string "la")))])
 
@@ -7851,7 +8579,8 @@
   "TARGET_CPU_ZARCH && GET_MODE (operands[0]) == Pmode"
   "larl\t%0,%1"
   [(set_attr "op_type" "RIL")
-   (set_attr "type"    "larl")])
+   (set_attr "type"    "larl")
+   (set_attr "z10prop" "z10_super_A1")])
 
 (define_insn "pool"
   [(unspec_volatile [(match_operand 0 "const_int_operand" "n")] UNSPECV_POOL)]
@@ -7988,3 +8717,31 @@
   ""
   ""
   [(set_attr "length" "0")])
+
+
+;
+; Data prefetch patterns
+;
+
+(define_insn "prefetch"
+  [(prefetch (match_operand 0 "address_operand" "UW,X")
+	     (match_operand:SI 1 "const_int_operand" "n,n")
+	     (match_operand:SI 2 "const_int_operand" "n,n"))]
+  "TARGET_Z10"
+{
+  if (larl_operand (operands[0], Pmode))
+    return INTVAL (operands[1]) == 1 ? "pfdrl\t2,%a0" : "pfdrl\t1,%a0";
+
+  if (s390_mem_constraint ("W", operands[0])
+      || s390_mem_constraint ("U", operands[0]))
+    return INTVAL (operands[1]) == 1 ? "pfd\t2,%a0" : "pfd\t1,%a0";
+
+  /* This point might be reached if op0 is a larl operand with an
+     uneven addend.  In this case we simply omit issuing a prefetch
+     instruction.  */
+
+  return "";
+}
+  [(set_attr "type" "load,larl")
+   (set_attr "op_type" "RXY,RIL")
+   (set_attr "z10prop" "z10_super")])
diff --git a/gcc/config/sh/lib1funcs.asm b/gcc/config/sh/lib1funcs.asm
index f90374ce..923deb43 100644
--- a/gcc/config/sh/lib1funcs.asm
+++ b/gcc/config/sh/lib1funcs.asm
@@ -34,6 +34,11 @@ Boston, MA 02110-1301, USA.  */
 !! recoded in assembly by Toshiyasu Morita
 !! tm@netcom.com
 
+#if defined(__ELF__) && defined(__linux__)
+.section .note.GNU-stack,"",%progbits
+.previous
+#endif
+
 /* SH2 optimizations for ___ashrsi3, ___ashlsi3, ___lshrsi3 and
    ELF local label prefixes by J"orn Rennecke
    amylaar@cygnus.com  */
diff --git a/gcc/config/sh/linux-atomic.asm b/gcc/config/sh/linux-atomic.asm
index d181fb3f..c01095e4 100644
--- a/gcc/config/sh/linux-atomic.asm
+++ b/gcc/config/sh/linux-atomic.asm
@@ -136,3 +136,6 @@ ATOMIC_FETCH_AND_COMBOP(nand,and,not,2,w)
 ATOMIC_FETCH_AND_COMBOP(nand,and,not,4,l)
 
 #endif /* ! __SH5__ */
+
+.section .note.GNU-stack,"",%progbits
+.previous
diff --git a/gcc/config/sh/linux-unwind.h b/gcc/config/sh/linux-unwind.h
index 3a3e9aa3..b9b7f869 100644
--- a/gcc/config/sh/linux-unwind.h
+++ b/gcc/config/sh/linux-unwind.h
@@ -80,9 +80,9 @@ shmedia_fallback_frame_state (struct _Unwind_Context *context,
 	   && (*(unsigned long *) (pc+11)  == 0x6ff0fff0))
     {
       struct rt_sigframe {
-	struct siginfo *pinfo;
+	siginfo_t *pinfo;
 	void *puc;
-	struct siginfo info;
+	siginfo_t info;
 	struct ucontext uc;
       } *rt_ = context->cfa;
       /* The void * cast is necessary to avoid an aliasing warning.
@@ -179,8 +179,8 @@ sh_fallback_frame_state (struct _Unwind_Context *context,
 		&& (*(unsigned short *) (pc+14)  == 0x00ad))))
     {
       struct rt_sigframe {
-	struct siginfo info;
-	struct ucontext uc;
+	siginfo_t info;
+	ucontext_t uc;
       } *rt_ = context->cfa;
       /* The void * cast is necessary to avoid an aliasing warning.
          The aliasing warning is correct, but should not be a problem
diff --git a/gcc/config/sparc/freebsd.h b/gcc/config/sparc/freebsd.h
index 9c86f5c9..ce60d6cb 100644
--- a/gcc/config/sparc/freebsd.h
+++ b/gcc/config/sparc/freebsd.h
@@ -25,9 +25,22 @@ along with GCC; see the file COPYING3.  If not see
 /* FreeBSD needs the platform name (sparc64) defined.
    Emacs needs to know if the arch is 64 or 32-bits.  */
 
-#undef  CPP_CPU64_DEFAULT_SPEC
-#define CPP_CPU64_DEFAULT_SPEC \
-  "-D__sparc64__ -D__sparc_v9__ -D__sparcv9 -D__arch64__"
+#undef  FBSD_TARGET_CPU_CPP_BUILTINS
+#define FBSD_TARGET_CPU_CPP_BUILTINS()                  \
+  do                                                    \
+    {                                                   \
+      if (TARGET_ARCH64)                                \
+        {                                               \
+          builtin_define ("__sparc64__");               \
+          builtin_define ("__sparc_v9__");              \
+          builtin_define ("__sparcv9");                 \
+        }                                               \
+      else                                              \
+        builtin_define ("__sparc");                     \
+      builtin_define ("__sparc__");                     \
+    }                                                   \
+  while (0)
+
 
 #define LINK_SPEC "%(link_arch)						\
   %{!mno-relax:%{!r:-relax}}						\
diff --git a/gcc/config/sparc/linux.h b/gcc/config/sparc/linux.h
index fabd4150..7d1d76e7 100644
--- a/gcc/config/sparc/linux.h
+++ b/gcc/config/sparc/linux.h
@@ -22,39 +22,12 @@ along with GCC; see the file COPYING3.  If not see
 #define TARGET_OS_CPP_BUILTINS()		\
   do						\
     {						\
-      builtin_define_std ("unix");		\
-      builtin_define_std ("linux");		\
-      builtin_define ("__gnu_linux__");		\
-      builtin_assert ("system=linux");		\
-      builtin_assert ("system=unix");		\
-      builtin_assert ("system=posix");		\
+      LINUX_TARGET_OS_CPP_BUILTINS();		\
       if (TARGET_LONG_DOUBLE_128)       	\
 	builtin_define ("__LONG_DOUBLE_128__");	\
     }						\
   while (0)
 
-/* Don't assume anything about the header files.  */
-#define NO_IMPLICIT_EXTERN_C
-
-#undef MD_EXEC_PREFIX
-#undef MD_STARTFILE_PREFIX
-
-/* Provide a STARTFILE_SPEC appropriate for GNU/Linux.  Here we add
-   the GNU/Linux magical crtbegin.o file (see crtstuff.c) which
-   provides part of the support for getting C++ file-scope static
-   object constructed before entering `main'.  */
-   
-#undef  STARTFILE_SPEC
-#if defined HAVE_LD_PIE
-#define STARTFILE_SPEC \
-  "%{!shared: %{pg|p:gcrt1.o%s;pie:Scrt1.o%s;:crt1.o%s}}\
-   crti.o%s %{static:crtbeginT.o%s;shared|pie:crtbeginS.o%s;:crtbegin.o%s}"
-#else
-#define STARTFILE_SPEC \
-  "%{!shared: %{pg|p:gcrt1.o%s;:crt1.o%s}}\
-   crti.o%s %{static:crtbeginT.o%s;shared|pie:crtbeginS.o%s;:crtbegin.o%s}"
-#endif
-
 /* Provide a ENDFILE_SPEC appropriate for GNU/Linux.  Here we tack on
    the GNU/Linux magical crtend.o file (see crtstuff.c) which
    provides part of the support for getting C++ file-scope static
@@ -63,8 +36,8 @@ along with GCC; see the file COPYING3.  If not see
 
 #undef  ENDFILE_SPEC
 #define ENDFILE_SPEC \
-  "%{ffast-math|funsafe-math-optimizations:crtfastmath.o%s} \
-   %{shared|pie:crtendS.o%s;:crtend.o%s} crtn.o%s"
+  "%{shared|pie:crtendS.o%s;:crtend.o%s} crtn.o%s\
+   %{ffast-math|funsafe-math-optimizations:crtfastmath.o%s}"
 
 /* This is for -profile to use -lc_p instead of -lc.  */
 #undef	CC1_SPEC
@@ -75,10 +48,6 @@ along with GCC; see the file COPYING3.  If not see
 %{mv8:-mcpu=v8} %{msupersparc:-mcpu=supersparc} \
 "
 
-/* The GNU C++ standard library requires that these macros be defined.  */
-#undef CPLUSPLUS_CPP_SPEC
-#define CPLUSPLUS_CPP_SPEC "-D_GNU_SOURCE %(cpp)"
-
 #undef TARGET_VERSION
 #define TARGET_VERSION fprintf (stderr, " (sparc GNU/Linux with ELF)");
 
@@ -98,12 +67,6 @@ along with GCC; see the file COPYING3.  If not see
 #define CPP_SUBTARGET_SPEC \
 "%{posix:-D_POSIX_SOURCE} %{pthread:-D_REENTRANT}"
 
-#undef LIB_SPEC
-#define LIB_SPEC \
-  "%{pthread:-lpthread} \
-   %{shared:-lc} \
-   %{!shared:%{mieee-fp:-lieee} %{profile:-lc_p}%{!profile:-lc}}"
-
 /* Provide a LINK_SPEC appropriate for GNU/Linux.  Here we provide support
    for the special GCC options -static and -shared, which allow us to
    link things in one of these three modes by applying the appropriate
@@ -121,15 +84,6 @@ along with GCC; see the file COPYING3.  If not see
 /* If ELF is the default format, we should not use /lib/elf.  */
 
 #define GLIBC_DYNAMIC_LINKER "/lib/ld-linux.so.2"
-#define UCLIBC_DYNAMIC_LINKER "/lib/ld-uClibc.so.0"
-#if UCLIBC_DEFAULT
-#define CHOOSE_DYNAMIC_LINKER(G, U) "%{mglibc:%{muclibc:%e-mglibc and -muclibc used together}" G ";:" U "}"
-#else
-#define CHOOSE_DYNAMIC_LINKER(G, U) "%{muclibc:%{mglibc:%e-mglibc and -muclibc used together}" U ";:" G "}"
-#endif
-#define LINUX_DYNAMIC_LINKER \
-  CHOOSE_DYNAMIC_LINKER (GLIBC_DYNAMIC_LINKER, UCLIBC_DYNAMIC_LINKER)
-
 
 #undef  LINK_SPEC
 #define LINK_SPEC "-m elf32_sparc -Y P,/usr/lib %{shared:-shared} \
@@ -187,10 +141,6 @@ do {									\
 
 #undef DITF_CONVERSION_LIBFUNCS
 #define DITF_CONVERSION_LIBFUNCS 1
-
-#if defined(HAVE_LD_EH_FRAME_HDR)
-#define LINK_EH_SPEC "%{!static:--eh-frame-hdr} "
-#endif
 
 #ifdef HAVE_AS_TLS
 #undef TARGET_SUN_TLS
@@ -199,31 +149,10 @@ do {									\
 #define TARGET_GNU_TLS 1
 #endif
 
-/* Don't be different from other Linux platforms in this regard.  */
-#define HANDLE_PRAGMA_PACK_PUSH_POP
-
 /* We use GNU ld so undefine this so that attribute((init_priority)) works.  */
 #undef CTORS_SECTION_ASM_OP
 #undef DTORS_SECTION_ASM_OP
 
-/* Determine whether the entire c99 runtime is present in the
-   runtime library.  */
-#define TARGET_C99_FUNCTIONS (OPTION_GLIBC)
-
-/* Whether we have sincos that follows the GNU extension.  */
-#define TARGET_HAS_SINCOS (OPTION_GLIBC)
-
-#define TARGET_POSIX_IO
-
-#undef LINK_GCC_C_SEQUENCE_SPEC
-#define LINK_GCC_C_SEQUENCE_SPEC \
-  "%{static:--start-group} %G %L %{static:--end-group}%{!static:%G}"
-
-/* Use --as-needed -lgcc_s for eh support.  */
-#ifdef HAVE_LD_AS_NEEDED
-#define USE_LD_AS_NEEDED 1
-#endif
-
 #define MD_UNWIND_SUPPORT "config/sparc/linux-unwind.h"
 
 /* Linux currently uses RMO in uniprocessor mode, which is equivalent to
diff --git a/gcc/config/sparc/linux64.h b/gcc/config/sparc/linux64.h
index d6759bf5..e7084b41 100644
--- a/gcc/config/sparc/linux64.h
+++ b/gcc/config/sparc/linux64.h
@@ -34,12 +34,6 @@ along with GCC; see the file COPYING3.  If not see
     }							\
   while (0)
 
-/* Don't assume anything about the header files.  */
-#define NO_IMPLICIT_EXTERN_C
-
-#undef MD_EXEC_PREFIX
-#undef MD_STARTFILE_PREFIX
-
 #if TARGET_CPU_DEFAULT == TARGET_CPU_v9 \
     || TARGET_CPU_DEFAULT == TARGET_CPU_ultrasparc \
     || TARGET_CPU_DEFAULT == TARGET_CPU_ultrasparc3 \
@@ -54,25 +48,10 @@ along with GCC; see the file COPYING3.  If not see
    + MASK_STACK_BIAS + MASK_APP_REGS + MASK_FPU + MASK_LONG_DOUBLE_128)
 #endif
 
-#undef ASM_CPU_DEFAULT_SPEC
-#define ASM_CPU_DEFAULT_SPEC "-Av9a"
-
-/* Provide a STARTFILE_SPEC appropriate for GNU/Linux.  Here we add
-   the GNU/Linux magical crtbegin.o file (see crtstuff.c) which
-   provides part of the support for getting C++ file-scope static
-   object constructed before entering `main'.  */
-   
-#undef  STARTFILE_SPEC
-
-#ifdef HAVE_LD_PIE
-#define STARTFILE_SPEC \
-  "%{!shared:%{pg|p:gcrt1.o%s;pie:Scrt1.o%s;:crt1.o%s}}\
-   crti.o%s %{static:crtbeginT.o%s;shared|pie:crtbeginS.o%s;:crtbeginS.o%s}"
-#else
-#define STARTFILE_SPEC \
-  "%{!shared:%{pg|p:gcrt1.o%s;:crt1.o%s}}\
-   crti.o%s %{static:crtbeginT.o%s;shared|pie:crtbeginS.o%s;:crtbeginS.o%s}"
-#endif
+/* This must be v9a not just v9 because by default we enable
+   -mvis.  */
+#undef ASM_CPU64_DEFAULT_SPEC
+#define ASM_CPU64_DEFAULT_SPEC "-Av9a"
 
 /* Provide a ENDFILE_SPEC appropriate for GNU/Linux.  Here we tack on
    the GNU/Linux magical crtend.o file (see crtstuff.c) which
@@ -81,15 +60,10 @@ along with GCC; see the file COPYING3.  If not see
    GNU/Linux "finalizer" file, `crtn.o'.  */
 
 #undef  ENDFILE_SPEC
-
 #define ENDFILE_SPEC \
   "%{shared|pie:crtendS.o%s;:crtend.o%s} crtn.o%s\
    %{ffast-math|funsafe-math-optimizations:crtfastmath.o%s}"
 
-/* The GNU C++ standard library requires that these macros be defined.  */
-#undef CPLUSPLUS_CPP_SPEC
-#define CPLUSPLUS_CPP_SPEC "-D_GNU_SOURCE %(cpp)"
-
 #undef TARGET_VERSION
 #define TARGET_VERSION fprintf (stderr, " (sparc64 GNU/Linux with ELF)");
 
@@ -122,12 +96,6 @@ along with GCC; see the file COPYING3.  If not see
 %{pthread:-D_REENTRANT} \
 "
 
-#undef LIB_SPEC
-#define LIB_SPEC \
-  "%{pthread:-lpthread} \
-   %{shared:-lc} \
-   %{!shared: %{mieee-fp:-lieee} %{profile:-lc_p}%{!profile:-lc}}"
-
 /* Provide a LINK_SPEC appropriate for GNU/Linux.  Here we provide support
    for the special GCC options -static and -shared, which allow us to
    link things in one of these three modes by applying the appropriate
@@ -146,17 +114,6 @@ along with GCC; see the file COPYING3.  If not see
 
 #define GLIBC_DYNAMIC_LINKER32 "/lib/ld-linux.so.2"
 #define GLIBC_DYNAMIC_LINKER64 "/lib64/ld-linux.so.2"
-#define UCLIBC_DYNAMIC_LINKER32 "/lib/ld-uClibc.so.0"
-#define UCLIBC_DYNAMIC_LINKER64 "/lib/ld64-uClibc.so.0"
-#if UCLIBC_DEFAULT
-#define CHOOSE_DYNAMIC_LINKER(G, U) "%{mglibc:%{muclibc:%e-mglibc and -muclibc used together}" G ";:" U "}"
-#else
-#define CHOOSE_DYNAMIC_LINKER(G, U) "%{muclibc:%{mglibc:%e-mglibc and -muclibc used together}" U ";:" G "}"
-#endif
-#define LINUX_DYNAMIC_LINKER32 \
-  CHOOSE_DYNAMIC_LINKER (GLIBC_DYNAMIC_LINKER32, UCLIBC_DYNAMIC_LINKER32)
-#define LINUX_DYNAMIC_LINKER64 \
-  CHOOSE_DYNAMIC_LINKER (GLIBC_DYNAMIC_LINKER64, UCLIBC_DYNAMIC_LINKER64)
 
 #ifdef SPARC_BI_ARCH
 
@@ -203,7 +160,7 @@ along with GCC; see the file COPYING3.  If not see
 
 #undef	CC1_SPEC
 #if DEFAULT_ARCH32_P
-#define CC1_SPEC "\
+#define CC1_SPEC "%{profile:-p} \
 %{sun4:} %{target:} \
 %{mcypress:-mcpu=cypress} \
 %{msparclite:-mcpu=sparclite} %{mf930:-mcpu=f930} %{mf934:-mcpu=f934} \
@@ -214,7 +171,7 @@ along with GCC; see the file COPYING3.  If not see
   %{!mno-vis:%{!mcpu=v9:-mvis}}} \
 "
 #else
-#define CC1_SPEC "\
+#define CC1_SPEC "%{profile:-p} \
 %{sun4:} %{target:} \
 %{mcypress:-mcpu=cypress} \
 %{msparclite:-mcpu=sparclite} %{mf930:-mcpu=f930} %{mf934:-mcpu=f934} \
@@ -321,9 +278,6 @@ do {									\
 #undef DITF_CONVERSION_LIBFUNCS
 #define DITF_CONVERSION_LIBFUNCS 1
 
-#if defined(HAVE_LD_EH_FRAME_HDR)
-#define LINK_EH_SPEC "%{!static:--eh-frame-hdr} "
-#endif
 
 #ifdef HAVE_AS_TLS
 #undef TARGET_SUN_TLS
@@ -332,31 +286,10 @@ do {									\
 #define TARGET_GNU_TLS 1
 #endif
 
-/* Don't be different from other Linux platforms in this regard.  */
-#define HANDLE_PRAGMA_PACK_PUSH_POP
-
 /* We use GNU ld so undefine this so that attribute((init_priority)) works.  */
 #undef CTORS_SECTION_ASM_OP
 #undef DTORS_SECTION_ASM_OP
 
-/* Determine whether the entire c99 runtime is present in the
-   runtime library.  */
-#define TARGET_C99_FUNCTIONS (OPTION_GLIBC)
-
-/* Whether we have sincos that follows the GNU extension.  */
-#define TARGET_HAS_SINCOS (OPTION_GLIBC)
-
-#define TARGET_POSIX_IO
-
-#undef LINK_GCC_C_SEQUENCE_SPEC
-#define LINK_GCC_C_SEQUENCE_SPEC \
-  "%{static:--start-group} %G %L %{static:--end-group}%{!static:%G}"
-
-/* Use --as-needed -lgcc_s for eh support.  */
-#ifdef HAVE_LD_AS_NEEDED
-#define USE_LD_AS_NEEDED 1
-#endif
-
 #define MD_UNWIND_SUPPORT "config/sparc/linux-unwind.h"
 
 /* Linux currently uses RMO in uniprocessor mode, which is equivalent to
diff --git a/gcc/config/sparc/sparc.c b/gcc/config/sparc/sparc.c
index bec731ff..70ceb61c 100644
--- a/gcc/config/sparc/sparc.c
+++ b/gcc/config/sparc/sparc.c
@@ -2356,6 +2356,8 @@ emit_soft_tfmode_cvt (enum rtx_code code, rtx *operands)
 	{
 	case SImode:
 	  func = "_Qp_itoq";
+	  if (TARGET_ARCH64)
+	    operands[1] = gen_rtx_SIGN_EXTEND (DImode, operands[1]);
 	  break;
 	case DImode:
 	  func = "_Qp_xtoq";
@@ -2370,6 +2372,8 @@ emit_soft_tfmode_cvt (enum rtx_code code, rtx *operands)
 	{
 	case SImode:
 	  func = "_Qp_uitoq";
+	  if (TARGET_ARCH64)
+	    operands[1] = gen_rtx_ZERO_EXTEND (DImode, operands[1]);
 	  break;
 	case DImode:
 	  func = "_Qp_uxtoq";
diff --git a/gcc/config/t-freebsd-eh b/gcc/config/t-freebsd-eh
new file mode 100644
index 00000000..d31d9312
--- /dev/null
+++ b/gcc/config/t-freebsd-eh
@@ -0,0 +1,4 @@
+# Use unwind-dw2-fde-glibc
+LIB2ADDEH = $(srcdir)/unwind-dw2.c $(srcdir)/unwind-dw2-fde-glibc.c \
+  $(srcdir)/unwind-sjlj.c $(srcdir)/gthr-gnat.c $(srcdir)/unwind-c.c
+LIB2ADDEHDEP = unwind.inc unwind-dw2-fde.h unwind-dw2-fde.c
diff --git a/gcc/config/xtensa/linux-unwind.h b/gcc/config/xtensa/linux-unwind.h
index 18daff2d..33402f05 100644
--- a/gcc/config/xtensa/linux-unwind.h
+++ b/gcc/config/xtensa/linux-unwind.h
@@ -66,8 +66,8 @@ xtensa_fallback_frame_state (struct _Unwind_Context *context,
   struct sigcontext *sc;
 
   struct rt_sigframe {
-    struct siginfo info;
-    struct ucontext uc;
+    siginfo_t info;
+    ucontext_t uc;
   } *rt_;
 
   /* movi a2, __NR_rt_sigreturn; syscall */
diff --git a/gcc/configure b/gcc/configure
index 3e2fa4ea..3366b29c 100755
--- a/gcc/configure
+++ b/gcc/configure
@@ -13442,7 +13442,7 @@ then
 	    | powerpc*-*-*,powerpc64*-*-*)
 		CROSS="$CROSS -DNATIVE_CROSS" ;;
 	esac
-elif test "x$TARGET_SYSTEM_ROOT" != x; then
+elif test "x$TARGET_SYSTEM_ROOT" != x -o $build != $host; then
         SYSTEM_HEADER_DIR=$build_system_header_dir
 fi
 
@@ -20689,7 +20689,7 @@ foo:	.long	25
 	tls_first_minor=14
 	tls_as_opt="-m64 -Aesame --fatal-warnings"
 	;;
-  sh-*-* | sh[34]-*-*)
+  sh-*-* | sh[34]*-*-*)
     conftest_s='
 	.section ".tdata","awT",@progbits
 foo:	.long	25
diff --git a/gcc/configure.ac b/gcc/configure.ac
index 5a7f2440..16656083 100644
--- a/gcc/configure.ac
+++ b/gcc/configure.ac
@@ -1749,7 +1749,7 @@ then
 	    | powerpc*-*-*,powerpc64*-*-*)
 		CROSS="$CROSS -DNATIVE_CROSS" ;;
 	esac
-elif test "x$TARGET_SYSTEM_ROOT" != x; then
+elif test "x$TARGET_SYSTEM_ROOT" != x -o $build != $host; then
         SYSTEM_HEADER_DIR=$build_system_header_dir 
 fi
 
@@ -2552,7 +2552,7 @@ foo:	.long	25
 	tls_first_minor=14
 	tls_as_opt="-m64 -Aesame --fatal-warnings"
 	;;
-  sh-*-* | sh[34]-*-*)
+  sh-*-* | sh[34]*-*-*)
     conftest_s='
 	.section ".tdata","awT",@progbits
 foo:	.long	25
diff --git a/gcc/crtstuff.c b/gcc/crtstuff.c
index 49e68cde..6e8ed322 100644
--- a/gcc/crtstuff.c
+++ b/gcc/crtstuff.c
@@ -90,13 +90,15 @@ call_ ## FUNC (void)					\
     && !defined(OBJECT_FORMAT_FLAT) \
     && defined(HAVE_LD_EH_FRAME_HDR) \
     && !defined(inhibit_libc) && !defined(CRTSTUFFT_O) \
-    && defined(__GLIBC__) && __GLIBC__ >= 2
+    && ((defined(__GLIBC__) && __GLIBC__ >= 2) \
+    || (defined(__FreeBSD_version) && __FreeBSD_version >= 700022))
 #include <link.h>
 /* uClibc pretends to be glibc 2.2 and DT_CONFIG is defined in its link.h.
    But it doesn't use PT_GNU_EH_FRAME ELF segment currently.  */
 # if !defined(__UCLIBC__) \
-     && (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2) \
-     || (__GLIBC__ == 2 && __GLIBC_MINOR__ == 2 && defined(DT_CONFIG)))
+     || (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2) \
+     || (__GLIBC__ == 2 && __GLIBC_MINOR__ == 2 && defined(DT_CONFIG))) \
+     || (__FreeBSD_version >= 700022)
 #  define USE_PT_GNU_EH_FRAME
 # endif
 #endif
diff --git a/gcc/defaults.h b/gcc/defaults.h
index ef2dcb76..ce2be3e3 100644
--- a/gcc/defaults.h
+++ b/gcc/defaults.h
@@ -902,6 +902,10 @@ along with GCC; see the file COPYING3.  If not see
 #define LEGITIMATE_PIC_OPERAND_P(X) 1
 #endif
 
+#ifndef TARGET_MEM_CONSTRAINT
+#define TARGET_MEM_CONSTRAINT 'm'
+#endif
+
 #ifndef REVERSIBLE_CC_MODE
 #define REVERSIBLE_CC_MODE(MODE) 0
 #endif
diff --git a/gcc/doc/extend.texi b/gcc/doc/extend.texi
index 61376ce3..77e2e4af 100644
--- a/gcc/doc/extend.texi
+++ b/gcc/doc/extend.texi
@@ -6713,6 +6713,7 @@ instructions, but allow the compiler to schedule those calls.
 * X86 Built-in Functions::
 * MIPS DSP Built-in Functions::
 * MIPS Paired-Single Support::
+* Other MIPS Built-in Functions::
 * PowerPC AltiVec Built-in Functions::
 * SPARC VIS Built-in Functions::
 * SPU Built-in Functions::
@@ -8830,6 +8831,18 @@ else
 @end smallexample
 @end table
 
+@node Other MIPS Built-in Functions
+@subsection Other MIPS Built-in Functions
+
+GCC provides other MIPS-specific built-in functions:
+
+@table @code
+@item void __builtin_mips_cache (int @var{op}, const volatile void *@var{addr})
+Insert a @samp{cache} instruction with operands @var{op} and @var{addr}.
+GCC defines the preprocessor macro @code{___GCC_HAVE_BUILTIN_MIPS_CACHE}
+when this function is available.
+@end table
+
 @node PowerPC AltiVec Built-in Functions
 @subsection PowerPC AltiVec Built-in Functions
 
diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
index 7983dd68..dd624b77 100644
--- a/gcc/doc/invoke.texi
+++ b/gcc/doc/invoke.texi
@@ -641,8 +641,8 @@ Objective-C and Objective-C++ Dialects}.
 -mmemcpy  -mno-memcpy  -mlong-calls  -mno-long-calls @gol
 -mmad  -mno-mad  -mfused-madd  -mno-fused-madd  -nocpp @gol
 -mfix-r4000  -mno-fix-r4000  -mfix-r4400  -mno-fix-r4400 @gol
--mfix-vr4120  -mno-fix-vr4120  -mfix-vr4130  -mno-fix-vr4130 @gol
--mfix-sb1  -mno-fix-sb1 @gol
+-mfix-r10000 -mno-fix-r10000  -mfix-vr4120  -mno-fix-vr4120 @gol
+-mfix-vr4130  -mno-fix-vr4130  -mfix-sb1  -mno-fix-sb1 @gol
 -mflush-func=@var{func}  -mno-flush-func @gol
 -mbranch-cost=@var{num}  -mbranch-likely  -mno-branch-likely @gol
 -mfp-exceptions -mno-fp-exceptions @gol
@@ -11877,6 +11877,7 @@ The processor names are:
 @samp{r2000}, @samp{r3000}, @samp{r3900}, @samp{r4000}, @samp{r4400},
 @samp{r4600}, @samp{r4650}, @samp{r6000}, @samp{r8000},
 @samp{rm7000}, @samp{rm9000},
+@samp{r10000}, @samp{r12000}, @samp{r14000}, @samp{r16000},
 @samp{sb1},
 @samp{sr71000},
 @samp{vr4100}, @samp{vr4111}, @samp{vr4120}, @samp{vr4130}, @samp{vr4300},
@@ -12428,6 +12429,22 @@ A double-word or a variable shift may give an incorrect result if executed
 immediately after starting an integer division.
 @end itemize
 
+@item -mfix-r10000
+@itemx -mno-fix-r10000
+@opindex mfix-r10000
+@opindex mno-fix-r10000
+Work around certain R10000 errata:
+@itemize @minus
+@item
+@code{ll}/@code{sc} sequences may not behave atomically on revisions
+prior to 3.0.  They may deadlock on revisions 2.6 and earlier.
+@end itemize
+
+This option can only be used if the target architecture supports
+branch-likely instructions.  @option{-mfix-r10000} is the default when
+@option{-march=r10000} is used; @option{-mno-fix-r10000} is the default
+otherwise.
+
 @item -mfix-vr4120
 @itemx -mno-fix-vr4120
 @opindex mfix-vr4120
@@ -12461,6 +12478,73 @@ Work around certain SB-1 CPU core errata.
 (This flag currently works around the SB-1 revision 2
 ``F1'' and ``F2'' floating point errata.)
 
+@item -mr10k-cache-barrier=@var{setting}
+@opindex mr10k-cache-barrier
+Specify whether GCC should insert cache barriers to avoid the
+side-effects of speculation on R10K processors.
+
+In common with many processors, the R10K tries to predict the outcome
+of a conditional branch and speculatively executes instructions from
+the ``taken'' branch.  It later aborts these instructions if the
+predicted outcome was wrong.  However, on the R10K, even aborted
+instructions can have side effects.
+
+This problem only affects kernel stores and, depending on the system,
+kernel loads.  As an example, a speculatively-executed store may load
+the target memory into cache and mark the cache line as dirty, even if
+the store itself is later aborted.  If a DMA operation writes to the
+same area of memory before the ``dirty'' line is flushed, the cached
+data will overwrite the DMA-ed data.  See the R10K processor manual
+for a full description, including other potential problems.
+
+One workaround is to insert cache barrier instructions before every memory
+access that might be speculatively executed and that might have side
+effects even if aborted.  @option{-mr10k-cache-barrier=@var{setting}}
+controls GCC's implementation of this workaround.  It assumes that
+aborted accesses to any byte in the following regions will not have
+side effects:
+
+@enumerate
+@item
+the memory occupied by the current function's stack frame;
+
+@item
+the memory occupied by an incoming stack argument;
+
+@item
+the memory occupied by an object with a link-time-constant address.
+@end enumerate
+
+It is the kernel's responsibility to ensure that speculative
+accesses to these regions are indeed safe.
+
+If the input program contains a function declaration such as:
+
+@smallexample
+void foo (void);
+@end smallexample
+
+then the implementation of @code{foo} must allow @code{j foo} and
+@code{jal foo} to be executed speculatively.  GCC honors this
+restriction for functions it compiles itself.  It expects non-GCC
+functions (such as hand-written assembly code) to do the same.
+
+The option has three forms:
+
+@table @gcctabopt
+@item -mr10k-cache-barrier=load-store
+Insert a cache barrier before a load or store that might be
+speculatively executed and that might have side effects even
+if aborted.
+
+@item -mr10k-cache-barrier=store
+Insert a cache barrier before a store that might be speculatively
+executed and that might have side effects even if aborted.
+
+@item -mr10k-cache-barrier=none
+Disable the insertion of cache barriers.  This is the default setting.
+@end table
+
 @item -mflush-func=@var{func}
 @itemx -mno-flush-func
 @opindex mflush-func
diff --git a/gcc/doc/md.texi b/gcc/doc/md.texi
index fb7520b7..5d044502 100644
--- a/gcc/doc/md.texi
+++ b/gcc/doc/md.texi
@@ -1050,6 +1050,7 @@ have.  Constraints can also require two operands to match.
 * Multi-Alternative::   When an insn has two alternative constraint-patterns.
 * Class Preferences::   Constraints guide which hard register to put things in.
 * Modifiers::           More precise control over effects of constraints.
+* Disable Insn Alternatives:: Disable insn alternatives using the @code{enabled} attribute.
 * Machine Constraints:: Existing constraints for some particular machines.
 * Define Constraints::  How to define machine-specific constraints.
 * C Constraint Interface:: How to test constraints from C code.
@@ -1085,6 +1086,8 @@ number of constraints and modifiers.
 @item @samp{m}
 A memory operand is allowed, with any kind of address that the machine
 supports in general.
+Note that the letter used for the general memory constraint can be
+re-defined by a back end using the @code{TARGET_MEM_CONSTRAINT} macro.
 
 @cindex offsettable address
 @cindex @samp{o} in constraint
@@ -3102,6 +3105,99 @@ Unsigned constant valid for BccUI instructions
 
 @end table
 
+@ifset INTERNALS
+@node Disable Insn Alternatives
+@subsection Disable insn alternatives using the @code{enabled} attribute
+@cindex enabled
+
+The @code{enabled} insn attribute may be used to disable certain insn
+alternatives for machine-specific reasons.  This is useful when adding
+new instructions to an existing pattern which are only available for
+certain cpu architecture levels as specified with the @code{-march=}
+option.
+
+If an insn alternative is disabled, then it will never be used.  The
+compiler treats the constraints for the disabled alternative as
+unsatisfiable.
+
+In order to make use of the @code{enabled} attribute a back end has to add
+in the machine description files:
+
+@enumerate
+@item
+A definition of the @code{enabled} insn attribute.  The attribute is
+defined as usual using the @code{define_attr} command.  This
+definition should be based on other insn attributes and/or target flags.
+The @code{enabled} attribute is a numeric attribute and should evaluate to
+@code{(const_int 1)} for an enabled alternative and to
+@code{(const_int 0)} otherwise.
+@item
+A definition of another insn attribute used to describe for what
+reason an insn alternative might be available or
+not.  E.g. @code{cpu_facility} as in the example below.
+@item
+An assignement for the second attribute to each insn definition
+combining instructions which are not all available under the same
+circumstances.  (Note: It obviously only makes sense for definitions
+with more than one alternative.  Otherwise the insn pattern should be
+disabled or enabled using the insn condition.)
+@end enumerate
+
+E.g. the following two patterns could easily be merged using the @code{enabled}
+attribute:
+
+@smallexample
+
+(define_insn "*movdi_old"
+  [(set (match_operand:DI 0 "register_operand" "=d")
+        (match_operand:DI 1 "register_operand" " d"))]
+  "!TARGET_NEW"
+  "lgr %0,%1")
+
+(define_insn "*movdi_new"
+  [(set (match_operand:DI 0 "register_operand" "=d,f,d")
+        (match_operand:DI 1 "register_operand" " d,d,f"))]
+  "TARGET_NEW"
+  "@@
+   lgr  %0,%1
+   ldgr %0,%1
+   lgdr %0,%1")
+
+@end smallexample
+
+to:
+
+@smallexample
+
+(define_insn "*movdi_combined"
+  [(set (match_operand:DI 0 "register_operand" "=d,f,d")
+        (match_operand:DI 1 "register_operand" " d,d,f"))]
+  ""
+  "@@
+   lgr  %0,%1
+   ldgr %0,%1
+   lgdr %0,%1"
+  [(set_attr "cpu_facility" "*,new,new")])
+
+@end smallexample
+
+with the @code{enabled} attribute defined like this:
+
+@smallexample
+
+(define_attr "cpu_facility" "standard,new" (const_string "standard"))
+
+(define_attr "enabled" ""
+  (cond [(eq_attr "cpu_facility" "standard") (const_int 1)
+         (and (eq_attr "cpu_facility" "new")
+              (ne (symbol_ref "TARGET_NEW") (const_int 0)))
+         (const_int 1)]
+        (const_int 0)))
+
+@end smallexample
+
+@end ifset
+
 @ifset INTERNALS
 @node Define Constraints
 @subsection Defining Machine-Specific Constraints
@@ -6526,6 +6622,22 @@ If the attribute takes numeric values, no @code{enum} type will be
 defined and the function to obtain the attribute's value will return
 @code{int}.
 
+There are attributes which are tied to a specific meaning.  These
+attributes are not free to use for other purposes:
+
+@table @code
+@item length
+The @code{length} attribute is used to calculate the length of emitted
+code chunks.  This is especially important when verifying branch
+distances. @xref{Insn Lengths}.
+
+@item enabled
+The @code{enabled} attribute can be defined to prevent certain
+alternatives of an insn definition from being used during code
+generation. @xref{Disable Insn Alternatives}.
+
+@end table
+
 @end ifset
 @ifset INTERNALS
 @node Expressions
diff --git a/gcc/doc/tm.texi b/gcc/doc/tm.texi
index 2c1446f3..68d181bb 100644
--- a/gcc/doc/tm.texi
+++ b/gcc/doc/tm.texi
@@ -5297,6 +5297,17 @@ into the @code{symbol_ref}, and then check for it here.  When you see a
 Format}.
 @end defmac
 
+@defmac TARGET_MEM_CONSTRAINT
+A single character to be used instead of the default @code{'m'}
+character for general memory addresses.  This defines the constraint
+letter which matches the memory addresses accepted by
+@code{GO_IF_LEGITIMATE_ADDRESS_P}.  Define this macro if you want to
+support new address formats in your back end without changing the
+semantics of the @code{'m'} constraint.  This is necessary in order to
+preserve functionality of inline assembly constructs using the
+@code{'m'} constraint.
+@end defmac
+
 @defmac FIND_BASE_TERM (@var{x})
 A C expression to determine the base term of address @var{x}.
 This macro is used in only one place: `find_base_term' in alias.c.
diff --git a/gcc/genoutput.c b/gcc/genoutput.c
index ba7fd4c2..be4fb00b 100644
--- a/gcc/genoutput.c
+++ b/gcc/genoutput.c
@@ -1122,7 +1122,10 @@ note_constraint (rtx exp, int lineno)
   unsigned int namelen = strlen (name);
   struct constraint_data **iter, **slot, *new;
 
-  if (strchr (indep_constraints, name[0]))
+  /* The 'm' constraint is special here since that constraint letter
+     can be overridden by the back end by defining the
+     TARGET_MEM_CONSTRAINT macro.  */
+  if (strchr (indep_constraints, name[0]) && name[0] != 'm')
     {
       if (name[1] == '\0')
 	message_with_line (lineno, "constraint letter '%s' cannot be "
diff --git a/gcc/genpreds.c b/gcc/genpreds.c
index bc20b16f..b2927842 100644
--- a/gcc/genpreds.c
+++ b/gcc/genpreds.c
@@ -690,8 +690,11 @@ static struct constraint_data **last_constraint_ptr = &first_constraint;
   for (iter_ = first_constraint; iter_; iter_ = iter_->next_textual)
 
 /* These letters, and all names beginning with them, are reserved for
-   generic constraints.  */
-static const char generic_constraint_letters[] = "EFVXgimnoprs";
+   generic constraints.
+   The 'm' constraint is not mentioned here since that constraint
+   letter can be overridden by the back end by defining the
+   TARGET_MEM_CONSTRAINT macro.  */
+static const char generic_constraint_letters[] = "EFVXginoprs";
 
 /* Machine-independent code expects that constraints with these
    (initial) letters will allow only (a subset of all) CONST_INTs.  */
diff --git a/gcc/postreload.c b/gcc/postreload.c
index 674160b0..27ffd9ff 100644
--- a/gcc/postreload.c
+++ b/gcc/postreload.c
@@ -542,12 +542,12 @@ reload_cse_simplify_operands (rtx insn, rtx testreg)
 		case '*':  case '%':
 		case '0':  case '1':  case '2':  case '3':  case '4':
 		case '5':  case '6':  case '7':  case '8':  case '9':
-		case 'm':  case '<':  case '>':  case 'V':  case 'o':
+		case '<':  case '>':  case 'V':  case 'o':
 		case 'E':  case 'F':  case 'G':  case 'H':
 		case 's':  case 'i':  case 'n':
 		case 'I':  case 'J':  case 'K':  case 'L':
 		case 'M':  case 'N':  case 'O':  case 'P':
-		case 'p': case 'X':
+		case 'p':  case 'X':  case TARGET_MEM_CONSTRAINT:
 		  /* These don't say anything we care about.  */
 		  break;
 
diff --git a/gcc/recog.c b/gcc/recog.c
index 34ce6b74..ee935e96 100644
--- a/gcc/recog.c
+++ b/gcc/recog.c
@@ -60,6 +60,14 @@ along with GCC; see the file COPYING3.  If not see
 #endif
 #endif
 
+#ifndef HAVE_ATTR_enabled
+static inline bool
+get_attr_enabled (rtx insn ATTRIBUTE_UNUSED)
+{
+  return true;
+}
+#endif
+
 static void validate_replace_rtx_1 (rtx *, rtx, rtx, rtx);
 static void validate_replace_src_1 (rtx *, void *);
 static rtx split_insn (rtx);
@@ -1561,7 +1569,7 @@ asm_operand_ok (rtx op, const char *constraint, const char **constraints)
 	    result = 1;
 	  break;
 
-	case 'm':
+	case TARGET_MEM_CONSTRAINT:
 	case 'V': /* non-offsettable */
 	  if (memory_operand (op, VOIDmode))
 	    result = 1;
@@ -1695,16 +1703,14 @@ asm_operand_ok (rtx op, const char *constraint, const char **constraints)
 		result = 1;
 	    }
 #ifdef EXTRA_CONSTRAINT_STR
+	  else if (EXTRA_MEMORY_CONSTRAINT (c, constraint))
+	    /* Every memory operand can be reloaded to fit.  */
+	    result = result || memory_operand (op, VOIDmode);
+	  else if (EXTRA_ADDRESS_CONSTRAINT (c, constraint))
+	    /* Every address operand can be reloaded to fit.  */
+	    result = result || address_operand (op, VOIDmode);
 	  else if (EXTRA_CONSTRAINT_STR (op, c, constraint))
 	    result = 1;
-	  else if (EXTRA_MEMORY_CONSTRAINT (c, constraint)
-		   /* Every memory operand can be reloaded to fit.  */
-		   && memory_operand (op, VOIDmode))
-	    result = 1;
-	  else if (EXTRA_ADDRESS_CONSTRAINT (c, constraint)
-		   /* Every address operand can be reloaded to fit.  */
-		   && address_operand (op, VOIDmode))
-	    result = 1;
 #endif
 	  break;
 	}
@@ -1938,11 +1944,9 @@ extract_insn (rtx insn)
   int noperands;
   rtx body = PATTERN (insn);
 
-  recog_data.insn = NULL;
   recog_data.n_operands = 0;
   recog_data.n_alternatives = 0;
   recog_data.n_dups = 0;
-  which_alternative = -1;
 
   switch (GET_CODE (body))
     {
@@ -2022,6 +2026,22 @@ extract_insn (rtx insn)
 	 : OP_IN);
 
   gcc_assert (recog_data.n_alternatives <= MAX_RECOG_ALTERNATIVES);
+
+  if (INSN_CODE (insn) < 0)
+    for (i = 0; i < recog_data.n_alternatives; i++)
+      recog_data.alternative_enabled_p[i] = true;
+  else
+    {
+      recog_data.insn = insn;
+      for (i = 0; i < recog_data.n_alternatives; i++)
+	{
+	  which_alternative = i;
+	  recog_data.alternative_enabled_p[i] = get_attr_enabled (insn);
+	}
+    }
+
+  recog_data.insn = NULL;
+  which_alternative = -1;
 }
 
 /* After calling extract_insn, you can use this function to extract some
@@ -2051,6 +2071,12 @@ preprocess_constraints (void)
 	  op_alt[j].matches = -1;
 	  op_alt[j].matched = -1;
 
+	  if (!recog_data.alternative_enabled_p[j])
+	    {
+	      p = skip_alternative (p);
+	      continue;
+	    }
+
 	  if (*p == '\0' || *p == ',')
 	    {
 	      op_alt[j].anything_ok = 1;
@@ -2100,7 +2126,7 @@ preprocess_constraints (void)
 		  }
 		  continue;
 
-		case 'm':
+		case TARGET_MEM_CONSTRAINT:
 		  op_alt[j].memory_ok = 1;
 		  break;
 		case '<':
@@ -2220,6 +2246,17 @@ constrain_operands (int strict)
       int lose = 0;
       funny_match_index = 0;
 
+      if (!recog_data.alternative_enabled_p[which_alternative])
+	{
+	  int i;
+
+	  for (i = 0; i < recog_data.n_operands; i++)
+	    constraints[i] = skip_alternative (constraints[i]);
+
+	  which_alternative++;
+	  continue;
+	}
+
       for (opno = 0; opno < recog_data.n_operands; opno++)
 	{
 	  rtx op = recog_data.operand[opno];
@@ -2373,7 +2410,7 @@ constrain_operands (int strict)
 		win = 1;
 		break;
 
-	      case 'm':
+	      case TARGET_MEM_CONSTRAINT:
 		/* Memory operands must be valid, to the extent
 		   required by STRICT.  */
 		if (MEM_P (op))
diff --git a/gcc/recog.h b/gcc/recog.h
index cdd6875a..01d31850 100644
--- a/gcc/recog.h
+++ b/gcc/recog.h
@@ -50,7 +50,8 @@ struct operand_alternative
 
   /* Nonzero if '&' was found in the constraint string.  */
   unsigned int earlyclobber:1;
-  /* Nonzero if 'm' was found in the constraint string.  */
+  /* Nonzero if TARGET_MEM_CONSTRAINT was found in the constraint
+     string.  */
   unsigned int memory_ok:1;
   /* Nonzero if 'o' was found in the constraint string.  */
   unsigned int offmem_ok:1;
@@ -142,6 +143,19 @@ recog_memoized (rtx insn)
 }
 #endif
 
+/* Skip chars until the next ',' or the end of the string.  This is
+   useful to skip alternatives in a constraint string.  */
+static inline const char *
+skip_alternative (const char *p)
+{
+  const char *r = p;
+  while (*r != '\0' && *r != ',')
+    r++;
+  if (*r == ',')
+    r++;
+  return r;
+}
+
 /* Nonzero means volatile operands are recognized.  */
 extern int volatile_ok;
 
@@ -201,6 +215,12 @@ struct recog_data
   /* The number of alternatives in the constraints for the insn.  */
   char n_alternatives;
 
+  /* Specifies whether an insn alternative is enabled using the
+     `enabled' attribute in the insn pattern definition.  For back
+     ends not using the `enabled' attribute the array fields are
+     always set to `true' in expand_insn.  */
+  bool alternative_enabled_p [MAX_RECOG_ALTERNATIVES];
+
   /* In case we are caching, hold insn data was generated for.  */
   rtx insn;
 };
diff --git a/gcc/regclass.c b/gcc/regclass.c
index a4734f2c..5dec3a35 100644
--- a/gcc/regclass.c
+++ b/gcc/regclass.c
@@ -1141,8 +1141,9 @@ record_operand_costs (rtx insn, struct costs *op_costs,
 	record_address_regs (GET_MODE (recog_data.operand[i]),
 			     XEXP (recog_data.operand[i], 0),
 			     0, MEM, SCRATCH, frequency * 2);
-      else if (constraints[i][0] == 'p'
-	       || EXTRA_ADDRESS_CONSTRAINT (constraints[i][0], constraints[i]))
+      else if (recog_data.alternative_enabled_p[0]
+	       && (constraints[i][0] == 'p'
+		   || EXTRA_ADDRESS_CONSTRAINT (constraints[i][0], constraints[i])))
 	record_address_regs (VOIDmode, recog_data.operand[i], 0, ADDRESS,
 			     SCRATCH, frequency * 2);
     }
@@ -1699,7 +1700,7 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,
 		    [(int) base_reg_class (VOIDmode, ADDRESS, SCRATCH)];
 		  break;
 
-		case 'm':  case 'o':  case 'V':
+		case TARGET_MEM_CONSTRAINT:  case 'o':  case 'V':
 		  /* It doesn't seem worth distinguishing between offsettable
 		     and non-offsettable addresses here.  */
 		  allows_mem[i] = 1;
@@ -1930,6 +1931,9 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,
       if (alt_fail)
 	continue;
 
+      if (!recog_data.alternative_enabled_p[alt])
+	continue;
+
       /* Finally, update the costs with the information we've calculated
 	 about this alternative.  */
 
diff --git a/gcc/reload.c b/gcc/reload.c
index cfe6be8c..2e7d7123 100644
--- a/gcc/reload.c
+++ b/gcc/reload.c
@@ -2544,7 +2544,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,
   int noperands;
   /* These start out as the constraints for the insn
      and they are chewed up as we consider alternatives.  */
-  char *constraints[MAX_RECOG_OPERANDS];
+  const char *constraints[MAX_RECOG_OPERANDS];
   /* These are the preferred classes for an operand, or NO_REGS if it isn't
      a register.  */
   enum reg_class preferred_class[MAX_RECOG_OPERANDS];
@@ -2651,7 +2651,8 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,
 
   memcpy (operand_mode, recog_data.operand_mode,
 	  noperands * sizeof (enum machine_mode));
-  memcpy (constraints, recog_data.constraints, noperands * sizeof (char *));
+  memcpy (constraints, recog_data.constraints,
+	  noperands * sizeof (const char *));
 
   commutative = -1;
 
@@ -2662,8 +2663,9 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,
 
   for (i = 0; i < noperands; i++)
     {
-      char *p;
+      const char *p;
       int c;
+      char *end;
 
       substed_operand[i] = recog_data.operand[i];
       p = constraints[i];
@@ -2707,7 +2709,8 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,
 	    case '0': case '1': case '2': case '3': case '4':
 	    case '5': case '6': case '7': case '8': case '9':
 	      {
-		c = strtoul (p - 1, &p, 10);
+		c = strtoul (p - 1, &end, 10);
+		p = end;
 
 		operands_match[c][i]
 		  = operands_match_p (recog_data.operand[c],
@@ -2935,11 +2938,21 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,
 	 a bad register class to only count 1/3 as much.  */
       int reject = 0;
 
+      if (!recog_data.alternative_enabled_p[this_alternative_number])
+	{
+	  int i;
+
+	  for (i = 0; i < recog_data.n_operands; i++)
+	    constraints[i] = skip_alternative (constraints[i]);
+
+	  continue;
+	}
+
       this_earlyclobber = 0;
 
       for (i = 0; i < noperands; i++)
 	{
-	  char *p = constraints[i];
+	  const char *p = constraints[i];
 	  char *end;
 	  int len;
 	  int win = 0;
@@ -3203,7 +3216,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,
 		badop = 0;
 		break;
 
-	      case 'm':
+	      case TARGET_MEM_CONSTRAINT:
 		if (force_reload)
 		  break;
 		if (MEM_P (operand)
@@ -3738,7 +3751,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,
 	  address_reloaded[commutative + 1] = t;
 
 	  memcpy (constraints, recog_data.constraints,
-		  noperands * sizeof (char *));
+		  noperands * sizeof (const char *));
 	  goto try_swapped;
 	}
       else
@@ -4555,7 +4568,7 @@ alternative_allows_const_pool_ref (rtx mem, const char *constraint, int altnum)
       while (*constraint++ != ',');
       altnum--;
     }
-  /* Scan the requested alternative for 'm' or 'o'.
+  /* Scan the requested alternative for TARGET_MEM_CONSTRAINT or 'o'.
      If one of them is present, this alternative accepts the result of
      passing a constant-pool reference through find_reloads_toplev.
 
@@ -4566,7 +4579,7 @@ alternative_allows_const_pool_ref (rtx mem, const char *constraint, int altnum)
   for (; (c = *constraint) && c != ',' && c != '#';
        constraint += CONSTRAINT_LEN (c, constraint))
     {
-      if (c == 'm' || c == 'o')
+      if (c == TARGET_MEM_CONSTRAINT || c == 'o')
 	return true;
 #ifdef EXTRA_CONSTRAINT_STR
       if (EXTRA_MEMORY_CONSTRAINT (c, constraint)
diff --git a/gcc/reload1.c b/gcc/reload1.c
index 8e6dbbc6..6ff3d113 100644
--- a/gcc/reload1.c
+++ b/gcc/reload1.c
@@ -1455,11 +1455,11 @@ maybe_fix_stack_asms (void)
 	      switch (c)
 		{
 		case '=': case '+': case '*': case '%': case '?': case '!':
-		case '0': case '1': case '2': case '3': case '4': case 'm':
-		case '<': case '>': case 'V': case 'o': case '&': case 'E':
-		case 'F': case 's': case 'i': case 'n': case 'X': case 'I':
-		case 'J': case 'K': case 'L': case 'M': case 'N': case 'O':
-		case 'P':
+		case '0': case '1': case '2': case '3': case '4': case '<':
+		case '>': case 'V': case 'o': case '&': case 'E': case 'F':
+		case 's': case 'i': case 'n': case 'X': case 'I': case 'J':
+		case 'K': case 'L': case 'M': case 'N': case 'O': case 'P':
+		case TARGET_MEM_CONSTRAINT:
 		  break;
 
 		case 'p':
diff --git a/gcc/stmt.c b/gcc/stmt.c
index 2b7c0170..d511cb58 100644
--- a/gcc/stmt.c
+++ b/gcc/stmt.c
@@ -364,7 +364,7 @@ parse_output_constraint (const char **constraint_p, int operand_num,
 	  }
 	break;
 
-      case 'V':  case 'm':  case 'o':
+      case 'V':  case TARGET_MEM_CONSTRAINT:  case 'o':
 	*allows_mem = true;
 	break;
 
@@ -463,7 +463,7 @@ parse_input_constraint (const char **constraint_p, int input_num,
 	  }
 	break;
 
-      case 'V':  case 'm':  case 'o':
+      case 'V':  case TARGET_MEM_CONSTRAINT:  case 'o':
 	*allows_mem = true;
 	break;
 
@@ -2509,7 +2509,11 @@ expand_case (tree exp)
 	  use_cost_table
 	    = (TREE_CODE (orig_type) != ENUMERAL_TYPE
 	       && estimate_case_costs (case_list));
-	  balance_case_nodes (&case_list, NULL);
+	  /* When optimizing for size, we want a straight list to avoid
+	     jumps as much as possible. This basically creates an if-else
+	     chain.  */
+	  if (!optimize_size)
+	    balance_case_nodes (&case_list, NULL);
 	  emit_case_nodes (index, case_list, default_label, index_type);
 	  emit_jump (default_label);
 	}
@@ -3067,6 +3071,7 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,
 	    {
 	      if (!node_has_low_bound (node, index_type))
 		{
+		  if (!optimize_size) /* don't jl to the .default_label. */
 		  emit_cmp_and_jump_insns (index,
 					   convert_modes
 					   (mode, imode,
diff --git a/gcc/testsuite/gcc.target/mips/cache-1.c b/gcc/testsuite/gcc.target/mips/cache-1.c
new file mode 100644
index 00000000..40c22e08
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/cache-1.c
@@ -0,0 +1,30 @@
+/* { dg-mips-options "-O2" } */
+
+void
+f1 (int *area)
+{
+  __builtin_mips_cache (20, area);
+}
+
+void
+f2 (const short *area)
+{
+  __builtin_mips_cache (24, area + 10);
+}
+
+void
+f3 (volatile unsigned int *area, int offset)
+{
+  __builtin_mips_cache (0, area + offset);
+}
+
+void
+f4 (const volatile unsigned char *area)
+{
+  __builtin_mips_cache (4, area - 80);
+}
+
+/* { dg-final { scan-assembler "\tcache\t0x14,0\\(\\\$4\\)" } } */
+/* { dg-final { scan-assembler "\tcache\t0x18,20\\(\\\$4\\)" } } */
+/* { dg-final { scan-assembler "\tcache\t0x0,0\\(\\\$.\\)" } } */
+/* { dg-final { scan-assembler "\tcache\t0x4,-80\\(\\\$4\\)" } } */
diff --git a/gcc/testsuite/gcc.target/mips/fix-r10000-1.c b/gcc/testsuite/gcc.target/mips/fix-r10000-1.c
new file mode 100644
index 00000000..e72974be
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/fix-r10000-1.c
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-mips-options "-O2 -march=mips4 -mfix-r10000" } */
+/* { dg-final { scan-assembler-times "\tbeql\t" 3 } } */
+
+NOMIPS16 int
+f1 (int *z)
+{
+  return __sync_fetch_and_add (z, 42);
+}
+
+NOMIPS16 short
+f2 (short *z)
+{
+  return __sync_fetch_and_add (z, 42);
+}
+
+NOMIPS16 char
+f3 (char *z)
+{
+  return __sync_fetch_and_add (z, 42);
+}
diff --git a/gcc/testsuite/gcc.target/mips/fix-r10000-10.c b/gcc/testsuite/gcc.target/mips/fix-r10000-10.c
new file mode 100644
index 00000000..a6dbfa3d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/fix-r10000-10.c
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-mips-options "-O2 -march=mips4 -mfix-r10000" } */
+/* { dg-final { scan-assembler-times "\tbeql\t" 3 } } */
+
+NOMIPS16 int
+f1 (int *z)
+{
+  return __sync_and_and_fetch (z, 42);
+}
+
+NOMIPS16 short
+f2 (short *z)
+{
+  return __sync_and_and_fetch (z, 42);
+}
+
+NOMIPS16 char
+f3 (char *z)
+{
+  return __sync_and_and_fetch (z, 42);
+}
diff --git a/gcc/testsuite/gcc.target/mips/fix-r10000-11.c b/gcc/testsuite/gcc.target/mips/fix-r10000-11.c
new file mode 100644
index 00000000..4bf16e17
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/fix-r10000-11.c
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-mips-options "-O2 -march=mips4 -mfix-r10000" } */
+/* { dg-final { scan-assembler-times "\tbeql\t" 3 } } */
+
+NOMIPS16 int
+f1 (int *z)
+{
+  return __sync_xor_and_fetch (z, 42);
+}
+
+NOMIPS16 short
+f2 (short *z)
+{
+  return __sync_xor_and_fetch (z, 42);
+}
+
+NOMIPS16 char
+f3 (char *z)
+{
+  return __sync_xor_and_fetch (z, 42);
+}
diff --git a/gcc/testsuite/gcc.target/mips/fix-r10000-12.c b/gcc/testsuite/gcc.target/mips/fix-r10000-12.c
new file mode 100644
index 00000000..0381c249
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/fix-r10000-12.c
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-mips-options "-O2 -march=mips4 -mfix-r10000" } */
+/* { dg-final { scan-assembler-times "\tbeql\t" 3 } } */
+
+NOMIPS16 int
+f1 (int *z)
+{
+  return __sync_nand_and_fetch (z, 42);
+}
+
+NOMIPS16 short
+f2 (short *z)
+{
+  return __sync_nand_and_fetch (z, 42);
+}
+
+NOMIPS16 char
+f3 (char *z)
+{
+  return __sync_nand_and_fetch (z, 42);
+}
diff --git a/gcc/testsuite/gcc.target/mips/fix-r10000-13.c b/gcc/testsuite/gcc.target/mips/fix-r10000-13.c
new file mode 100644
index 00000000..7e1efc85
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/fix-r10000-13.c
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-mips-options "-O2 -march=mips4 -mfix-r10000" } */
+/* { dg-final { scan-assembler-times "\tbeql\t" 3 } } */
+
+NOMIPS16 int
+f1 (int *z)
+{
+  return __sync_bool_compare_and_swap (z, 0, 42);
+}
+
+NOMIPS16 short
+f2 (short *z)
+{
+  return __sync_bool_compare_and_swap (z, 0, 42);
+}
+
+NOMIPS16 char
+f3 (char *z)
+{
+  return __sync_bool_compare_and_swap (z, 0, 42);
+}
diff --git a/gcc/testsuite/gcc.target/mips/fix-r10000-14.c b/gcc/testsuite/gcc.target/mips/fix-r10000-14.c
new file mode 100644
index 00000000..8d8fe095
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/fix-r10000-14.c
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-mips-options "-O2 -march=mips4 -mfix-r10000" } */
+/* { dg-final { scan-assembler-times "\tbeql\t" 3 } } */
+
+NOMIPS16 int
+f1 (int *z)
+{
+  return __sync_val_compare_and_swap (z, 0, 42);
+}
+
+NOMIPS16 short
+f2 (short *z)
+{
+  return __sync_val_compare_and_swap (z, 0, 42);
+}
+
+NOMIPS16 char
+f3 (char *z)
+{
+  return __sync_val_compare_and_swap (z, 0, 42);
+}
diff --git a/gcc/testsuite/gcc.target/mips/fix-r10000-15.c b/gcc/testsuite/gcc.target/mips/fix-r10000-15.c
new file mode 100644
index 00000000..fd7d0364
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/fix-r10000-15.c
@@ -0,0 +1,33 @@
+/* { dg-do compile } */
+/* { dg-mips-options "-O2 -march=mips4 -mfix-r10000" } */
+/* { dg-final { scan-assembler-times "\tbeql\t" 3 } } */
+
+NOMIPS16 int
+f1 (int *z)
+{
+  int result;
+
+  result = __sync_lock_test_and_set (z, 42);
+  __sync_lock_release (z);
+  return result;
+}
+
+NOMIPS16 short
+f2 (short *z)
+{
+  short result;
+
+  result = __sync_lock_test_and_set (z, 42);
+  __sync_lock_release (z);
+  return result;
+}
+
+NOMIPS16 char
+f3 (char *z)
+{
+  char result;
+
+  result = __sync_lock_test_and_set (z, 42);
+  __sync_lock_release (z);
+  return result;
+}
diff --git a/gcc/testsuite/gcc.target/mips/fix-r10000-2.c b/gcc/testsuite/gcc.target/mips/fix-r10000-2.c
new file mode 100644
index 00000000..900a697c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/fix-r10000-2.c
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-mips-options "-O2 -march=mips4 -mfix-r10000" } */
+/* { dg-final { scan-assembler-times "\tbeql\t" 3 } } */
+
+NOMIPS16 int
+f1 (int *z, int amt)
+{
+  return __sync_fetch_and_sub (z, amt);
+}
+
+NOMIPS16 short
+f2 (short *z, short amt)
+{
+  return __sync_fetch_and_sub (z, amt);
+}
+
+NOMIPS16 char
+f3 (char *z, char amt)
+{
+  return __sync_fetch_and_sub (z, amt);
+}
diff --git a/gcc/testsuite/gcc.target/mips/fix-r10000-3.c b/gcc/testsuite/gcc.target/mips/fix-r10000-3.c
new file mode 100644
index 00000000..de74e972
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/fix-r10000-3.c
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-mips-options "-O2 -march=mips4 -mfix-r10000" } */
+/* { dg-final { scan-assembler-times "\tbeql\t" 3 } } */
+
+NOMIPS16 int
+f1 (int *z)
+{
+  return __sync_fetch_and_or (z, 42);
+}
+
+NOMIPS16 short
+f2 (short *z)
+{
+  return __sync_fetch_and_or (z, 42);
+}
+
+NOMIPS16 char
+f3 (char *z)
+{
+  return __sync_fetch_and_or (z, 42);
+}
diff --git a/gcc/testsuite/gcc.target/mips/fix-r10000-4.c b/gcc/testsuite/gcc.target/mips/fix-r10000-4.c
new file mode 100644
index 00000000..0c962ee2
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/fix-r10000-4.c
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-mips-options "-O2 -march=mips4 -mfix-r10000" } */
+/* { dg-final { scan-assembler-times "\tbeql\t" 3 } } */
+
+NOMIPS16 int
+f1 (int *z)
+{
+  return __sync_fetch_and_and (z, 42);
+}
+
+NOMIPS16 short
+f2 (short *z)
+{
+  return __sync_fetch_and_and (z, 42);
+}
+
+NOMIPS16 char
+f3 (char *z)
+{
+  return __sync_fetch_and_and (z, 42);
+}
diff --git a/gcc/testsuite/gcc.target/mips/fix-r10000-5.c b/gcc/testsuite/gcc.target/mips/fix-r10000-5.c
new file mode 100644
index 00000000..15a0704f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/fix-r10000-5.c
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-mips-options "-O2 -march=mips4 -mfix-r10000" } */
+/* { dg-final { scan-assembler-times "\tbeql\t" 3 } } */
+
+NOMIPS16 int
+f1 (int *z)
+{
+  return __sync_fetch_and_xor (z, 42);
+}
+
+NOMIPS16 short
+f2 (short *z)
+{
+  return __sync_fetch_and_xor (z, 42);
+}
+
+NOMIPS16 char
+f3 (char *z)
+{
+  return __sync_fetch_and_xor (z, 42);
+}
diff --git a/gcc/testsuite/gcc.target/mips/fix-r10000-6.c b/gcc/testsuite/gcc.target/mips/fix-r10000-6.c
new file mode 100644
index 00000000..27513695
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/fix-r10000-6.c
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-mips-options "-O2 -march=mips4 -mfix-r10000" } */
+/* { dg-final { scan-assembler-times "\tbeql\t" 3 } } */
+
+NOMIPS16 int
+f1 (int *z)
+{
+  return __sync_fetch_and_nand (z, 42);
+}
+
+NOMIPS16 short
+f2 (short *z)
+{
+  return __sync_fetch_and_nand (z, 42);
+}
+
+NOMIPS16 char
+f3 (char *z)
+{
+  return __sync_fetch_and_nand (z, 42);
+}
diff --git a/gcc/testsuite/gcc.target/mips/fix-r10000-7.c b/gcc/testsuite/gcc.target/mips/fix-r10000-7.c
new file mode 100644
index 00000000..bbe98569
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/fix-r10000-7.c
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-mips-options "-O2 -march=mips4 -mfix-r10000" } */
+/* { dg-final { scan-assembler-times "\tbeql\t" 3 } } */
+
+NOMIPS16 int
+f1 (int *z)
+{
+  return __sync_add_and_fetch (z, 42);
+}
+
+NOMIPS16 short
+f2 (short *z)
+{
+  return __sync_add_and_fetch (z, 42);
+}
+
+NOMIPS16 char
+f3 (char *z)
+{
+  return __sync_add_and_fetch (z, 42);
+}
diff --git a/gcc/testsuite/gcc.target/mips/fix-r10000-8.c b/gcc/testsuite/gcc.target/mips/fix-r10000-8.c
new file mode 100644
index 00000000..6e990a63
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/fix-r10000-8.c
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-mips-options "-O2 -march=mips4 -mfix-r10000" } */
+/* { dg-final { scan-assembler-times "\tbeql\t" 3 } } */
+
+NOMIPS16 int
+f1 (int *z, int amt)
+{
+  return __sync_sub_and_fetch (z, amt);
+}
+
+NOMIPS16 short
+f2 (short *z, short amt)
+{
+  return __sync_sub_and_fetch (z, amt);
+}
+
+NOMIPS16 char
+f3 (char *z, char amt)
+{
+  return __sync_sub_and_fetch (z, amt);
+}
diff --git a/gcc/testsuite/gcc.target/mips/fix-r10000-9.c b/gcc/testsuite/gcc.target/mips/fix-r10000-9.c
new file mode 100644
index 00000000..8373c42d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/fix-r10000-9.c
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-mips-options "-O2 -march=mips4 -mfix-r10000" } */
+/* { dg-final { scan-assembler-times "\tbeql\t" 3 } } */
+
+NOMIPS16 int
+f1 (int *z)
+{
+  return __sync_or_and_fetch (z, 42);
+}
+
+NOMIPS16 short
+f2 (short *z)
+{
+  return __sync_or_and_fetch (z, 42);
+}
+
+NOMIPS16 char
+f3 (char *z)
+{
+  return __sync_or_and_fetch (z, 42);
+}
diff --git a/gcc/testsuite/gcc.target/mips/mips.exp b/gcc/testsuite/gcc.target/mips/mips.exp
index bd8b5fa7..097f4013 100644
--- a/gcc/testsuite/gcc.target/mips/mips.exp
+++ b/gcc/testsuite/gcc.target/mips/mips.exp
@@ -238,6 +238,10 @@ proc dg-mips-options {args} {
 	    } else {
 		append flags " -msoft-float"
 	    }
+	} elseif {[regexp -- {^-mr10k-cache-barrier=(load|store)} $flag]
+		  && $mips_isa < 3
+		  && [lsearch -regexp $flags {^(-mips|-march)}] < 0} {
+	    append flags " -mips3"
 	}
     }
     foreach flag $flags {
diff --git a/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-1.c b/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-1.c
new file mode 100644
index 00000000..fd13d8ac
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-1.c
@@ -0,0 +1,45 @@
+/* { dg-mips-options "-O2 -mabi=64 -mr10k-cache-barrier=store" } */
+
+/* Test that stores to uncached addresses do not get unnecessary
+   cache barriers.  */
+
+#define TEST(ADDR)					\
+  NOMIPS16 void						\
+  test_##ADDR (int n)					\
+  {							\
+    while (n--)						\
+      {							\
+	*(volatile char *) (0x##ADDR##UL) = 1;		\
+	*(volatile short *) (0x##ADDR##UL + 2) = 2;	\
+	*(volatile int *) (0x##ADDR##UL + 4) = 0;	\
+      }							\
+  }
+
+TEST (9000000000000000)
+TEST (900000fffffffff8)
+
+TEST (9200000000000000)
+TEST (920000fffffffff8)
+
+TEST (9400000000000000)
+TEST (940000fffffffff8)
+
+TEST (9600000000000000)
+TEST (960000fffffffff8)
+
+TEST (b800000000000000)
+TEST (b80000fffffffff8)
+
+TEST (ba00000000000000)
+TEST (ba0000fffffffff8)
+
+TEST (bc00000000000000)
+TEST (bc0000fffffffff8)
+
+TEST (be00000000000000)
+TEST (be0000fffffffff8)
+
+TEST (ffffffffa0000000)
+TEST (ffffffffbffffff8)
+
+/* { dg-final { scan-assembler-not "\tcache\t" } } */
diff --git a/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-10.c b/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-10.c
new file mode 100644
index 00000000..405d7fcf
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-10.c
@@ -0,0 +1,18 @@
+/* { dg-mips-options "-O2 -mr10k-cache-barrier=store -mips4 -mbranch-likely -mno-abicalls" } */
+int bar (int);
+
+/* Test that code after a branch-likely does not get an unnecessary
+   cache barrier.  */
+
+NOMIPS16 void
+foo (int n, int *x)
+{
+  do
+    n = bar (n * 4 + 1);
+  while (n);
+  /* The preceding branch should be a branch likely, with the shift as
+     its delay slot.  We therefore don't need a cache barrier here.  */
+  x[0] = 0;
+}
+
+/* { dg-final { scan-assembler-not "\tcache\t" } } */
diff --git a/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-11.c b/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-11.c
new file mode 100644
index 00000000..be6816fd
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-11.c
@@ -0,0 +1,13 @@
+/* { dg-mips-options "-O2 -mr10k-cache-barrier=store -mno-abicalls" } */
+
+/* Test that loads are not unnecessarily protected.  */
+
+int bar (int);
+
+NOMIPS16 void
+foo (int *ptr)
+{
+  *ptr = bar (*ptr);
+}
+
+/* { dg-final { scan-assembler-times "\tcache\t" 1 } } */
diff --git a/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-12.c b/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-12.c
new file mode 100644
index 00000000..7e8026f1
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-12.c
@@ -0,0 +1,13 @@
+/* { dg-mips-options "-O2 -mr10k-cache-barrier=load-store -mno-abicalls" } */
+
+/* Test that loads are correctly protected.  */
+
+int bar (int);
+
+NOMIPS16 void
+foo (int *ptr)
+{
+  *ptr = bar (*ptr);
+}
+
+/* { dg-final { scan-assembler-times "\tcache\t" 2 } } */
diff --git a/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-13.c b/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-13.c
new file mode 100644
index 00000000..fa5a416c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-13.c
@@ -0,0 +1,14 @@
+/* { dg-mips-options "-O2 -mr10k-cache-barrier=store" } */
+
+/* Test that indirect calls are protected.  */
+
+int bar (int);
+
+NOMIPS16 void
+foo (void (*fn) (void), int x)
+{
+  if (x)
+    (*fn) ();
+}
+
+/* { dg-final { scan-assembler-times "\tcache\t" 1 } } */
diff --git a/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-14.c b/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-14.c
new file mode 100644
index 00000000..4d807833
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-14.c
@@ -0,0 +1,7 @@
+/* { dg-do compile { target mips16_attribute } } */
+/* { dg-mips-options "-O2 -mr10k-cache-barrier=store" } */
+/* { dg-add-options mips16_attribute } */
+
+/* Test that indirect calls are protected.  */
+
+MIPS16 void foo (void) { } /* { dg-message "sorry, unimplemented" } */
diff --git a/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-15.c b/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-15.c
new file mode 100644
index 00000000..5b03838c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-15.c
@@ -0,0 +1,2 @@
+/* { dg-mips-options "-O2 -mr10k-cache-barrier=store -mips2" } */
+/* { dg-error "requires.*cache.*instruction" "" { target *-*-* } 0 } */
diff --git a/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-2.c b/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-2.c
new file mode 100644
index 00000000..ed439b14
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-2.c
@@ -0,0 +1,40 @@
+/* { dg-mips-options "-O2 -mabi=64 -mr10k-cache-barrier=store" } */
+
+/* Test that stores to constant cached addresses are protected
+   by cache barriers.  */
+
+#define TEST(ADDR)					\
+  NOMIPS16 void						\
+  test_##ADDR (int n)					\
+  {							\
+    *(volatile int *) (0x##ADDR##UL) = 1;		\
+  }
+
+TEST (8ffffffffffffffc)
+TEST (9000010000000000)
+
+TEST (91fffffffffffffc)
+TEST (9200010000000000)
+
+TEST (93fffffffffffffc)
+TEST (9500010000000000)
+
+TEST (95fffffffffffffc)
+TEST (9600010000000000)
+
+TEST (b7fffffffffffffc)
+TEST (b800010000000000)
+
+TEST (b9fffffffffffffc)
+TEST (ba00010000000000)
+
+TEST (bbfffffffffffffc)
+TEST (bc00010000000000)
+
+TEST (bdfffffffffffffc)
+TEST (be00010000000000)
+
+TEST (ffffffff9ffffffc)
+TEST (ffffffffc0000000)
+
+/* { dg-final { scan-assembler-times "\tcache\t" 18 } } */
diff --git a/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-3.c b/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-3.c
new file mode 100644
index 00000000..8238f39b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-3.c
@@ -0,0 +1,17 @@
+/* { dg-mips-options "-O2 -mr10k-cache-barrier=store -mno-abicalls" } */
+
+/* Test that in-range stores to the frame are not protected by
+   cache barriers.  */
+
+void bar (int *x);
+
+NOMIPS16 void
+foo (int v)
+{
+  int x[0x100000];
+  bar (x);
+  x[0x20] = v;
+  bar (x);
+}
+
+/* { dg-final { scan-assembler-not "\tcache\t" } } */
diff --git a/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-4.c b/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-4.c
new file mode 100644
index 00000000..e8280e8a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-4.c
@@ -0,0 +1,20 @@
+/* { dg-mips-options "-O2 -mr10k-cache-barrier=store -mno-abicalls" } */
+
+void bar (int *x);
+
+/* Test that out-of-range stores to the frame are protected by cache
+   barriers.  */
+
+NOMIPS16 void
+foo (int v)
+{
+  int x[8];
+  bar (x);
+  if (v & 1)
+    x[0x100] = 0;
+  if (v & 2)
+    x[-0x100] = 0;
+  bar (x);
+}
+
+/* { dg-final { scan-assembler-times "\tcache\t" 2 } } */
diff --git a/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-5.c b/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-5.c
new file mode 100644
index 00000000..6e21ec3e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-5.c
@@ -0,0 +1,19 @@
+/* { dg-mips-options "-O2 -mr10k-cache-barrier=store -mno-abicalls -mabi=64" } */
+
+/* Test that in-range stores to static objects do not get an unnecessary
+   cache barrier.  */
+
+int x[4];
+void bar (void);
+
+NOMIPS16 void
+foo (int n)
+{
+  while (n--)
+    {
+      x[3] = 1;
+      bar ();
+    }
+}
+
+/* { dg-final { scan-assembler-not "\tcache\t" } } */
diff --git a/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-6.c b/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-6.c
new file mode 100644
index 00000000..f014aa0d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-6.c
@@ -0,0 +1,19 @@
+/* { dg-mips-options "-O2 -mr10k-cache-barrier=store -mabi=64" } */
+
+int x[4];
+void bar (void);
+
+/* Test that out-of-range stores to static objects are protected by a
+   cache barrier.  */
+
+NOMIPS16 void
+foo (int n)
+{
+  while (n--)
+    {
+      x[4] = 1;
+      bar ();
+    }
+}
+
+/* { dg-final { scan-assembler "\tcache\t" } } */
diff --git a/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-7.c b/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-7.c
new file mode 100644
index 00000000..c98b4a8a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-7.c
@@ -0,0 +1,27 @@
+/* { dg-mips-options "-O2 -mr10k-cache-barrier=store -mno-abicalls" } */
+
+void bar1 (void);
+void bar2 (void);
+void bar3 (void);
+
+NOMIPS16 void
+foo (int *x, int sel, int n)
+{
+  if (sel)
+    {
+      bar1 ();
+      x[0] = 1;
+    }
+  else
+    {
+      bar2 ();
+      x[1] = 0;
+    }
+  /* If there is one copy of this code, reached by two unconditional edges,
+     then it shouldn't need a third cache barrier.  */
+  x[2] = 2;
+  while (n--)
+    bar3 ();
+}
+
+/* { dg-final { scan-assembler-times "\tcache\t" 2 } } */
diff --git a/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-8.c b/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-8.c
new file mode 100644
index 00000000..5394ae80
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-8.c
@@ -0,0 +1,15 @@
+/* { dg-mips-options "-O2 -mr10k-cache-barrier=store -G8" } */
+
+/* Test that in-range stores to components of static objects
+   do not get an unnecessary cache barrier.  */
+
+struct { struct { char i[4]; } a; struct { char j[4]; } b; } s;
+
+NOMIPS16 void
+foo (int sel)
+{
+  s.a.i[0] = 1;
+  s.b.j[3] = 100;
+}
+
+/* { dg-final { scan-assembler-not "\tcache\t" } } */
diff --git a/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-9.c b/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-9.c
new file mode 100644
index 00000000..cf795b6e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/r10k-cache-barrier-9.c
@@ -0,0 +1,19 @@
+/* { dg-mips-options "-O2 -mr10k-cache-barrier=store -G8" } */
+
+/* Test that out-of-range stores to components of static objects
+   are protected by a cache barrier.  */
+
+struct { struct { char i[4]; } a; struct { char j[4]; } b; } s;
+
+NOMIPS16 void
+foo (int sel1, int sel2, int sel3)
+{
+  if (sel1)
+    s.a.i[8] = 1;
+  if (sel2)
+    s.b.j[4] = 100;
+  if (sel3)
+    s.a.i[-1] = 0;
+}
+
+/* { dg-final { scan-assembler-times "\tcache\t" 3 } } */
diff --git a/gcc/testsuite/gfortran.dg/enum_10.f90 b/gcc/testsuite/gfortran.dg/enum_10.f90
index 6bfd8190..99a16901 100644
--- a/gcc/testsuite/gfortran.dg/enum_10.f90
+++ b/gcc/testsuite/gfortran.dg/enum_10.f90
@@ -1,6 +1,7 @@
 ! { dg-do run }
 ! { dg-additional-sources enum_10.c }
 ! { dg-options "-fshort-enums -w" }
+! { dg-options "-fshort-enums -w -Wl,--no-enum-size-warning" { target arm*-*-linux*eabi } }
 ! Make sure short enums are indeed interoperable with the
 ! corresponding C type.
 
diff --git a/gcc/toplev.c b/gcc/toplev.c
index 14d87822..23699c61 100644
--- a/gcc/toplev.c
+++ b/gcc/toplev.c
@@ -532,11 +532,11 @@ read_integral_parameter (const char *p, const char *pname, const int  defval)
   return atoi (p);
 }
 
-/* When compiling with a recent enough GCC, we use the GNU C "extern inline"
-   for floor_log2 and exact_log2; see toplev.h.  That construct, however,
-   conflicts with the ISO C++ One Definition Rule.   */
+#if GCC_VERSION < 3004
 
-#if GCC_VERSION < 3004 || !defined (__cplusplus)
+/* The functions floor_log2 and exact_log2 are defined as inline
+   functions in toplev.h if GCC_VERSION >= 3004.  The definitions here
+   are used for older versions of gcc.  */
 
 /* Given X, an unsigned number, return the largest int Y such that 2**Y <= X.
    If X is 0, return -1.  */
@@ -549,9 +549,6 @@ floor_log2 (unsigned HOST_WIDE_INT x)
   if (x == 0)
     return -1;
 
-#ifdef CLZ_HWI
-  t = HOST_BITS_PER_WIDE_INT - 1 - (int) CLZ_HWI (x);
-#else
   if (HOST_BITS_PER_WIDE_INT > 64)
     if (x >= (unsigned HOST_WIDE_INT) 1 << (t + 64))
       t += 64;
@@ -568,7 +565,6 @@ floor_log2 (unsigned HOST_WIDE_INT x)
     t += 2;
   if (x >= ((unsigned HOST_WIDE_INT) 1) << (t + 1))
     t += 1;
-#endif
 
   return t;
 }
@@ -581,14 +577,10 @@ exact_log2 (unsigned HOST_WIDE_INT x)
 {
   if (x != (x & -x))
     return -1;
-#ifdef CTZ_HWI
-  return x ? CTZ_HWI (x) : -1;
-#else
   return floor_log2 (x);
-#endif
 }
 
-#endif /*  GCC_VERSION < 3004 || !defined (__cplusplus)  */
+#endif /* GCC_VERSION < 3004 */
 
 /* Handler for fatal signals, such as SIGSEGV.  These are transformed
    into ICE messages, which is much more user friendly.  In case the
diff --git a/gcc/toplev.h b/gcc/toplev.h
index 26a085d0..8146f1da 100644
--- a/gcc/toplev.h
+++ b/gcc/toplev.h
@@ -154,14 +154,17 @@ extern void decode_d_option		(const char *);
 /* Return true iff flags are set as if -ffast-math.  */
 extern bool fast_math_flags_set_p	(void);
 
+/* Inline versions of the above for speed.  */
+#if GCC_VERSION < 3004
+
 /* Return log2, or -1 if not exact.  */
 extern int exact_log2                  (unsigned HOST_WIDE_INT);
 
 /* Return floor of log2, with -1 for zero.  */
 extern int floor_log2                  (unsigned HOST_WIDE_INT);
 
-/* Inline versions of the above for speed.  */
-#if GCC_VERSION >= 3004
+#else /* GCC_VERSION >= 3004 */
+
 # if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_LONG
 #  define CLZ_HWI __builtin_clzl
 #  define CTZ_HWI __builtin_ctzl
@@ -173,17 +176,18 @@ extern int floor_log2                  (unsigned HOST_WIDE_INT);
 #  define CTZ_HWI __builtin_ctz
 # endif
 
-extern inline int
+static inline int
 floor_log2 (unsigned HOST_WIDE_INT x)
 {
   return x ? HOST_BITS_PER_WIDE_INT - 1 - (int) CLZ_HWI (x) : -1;
 }
 
-extern inline int
+static inline int
 exact_log2 (unsigned HOST_WIDE_INT x)
 {
   return x == (x & -x) && x ? (int) CTZ_HWI (x) : -1;
 }
+
 #endif /* GCC_VERSION >= 3004 */
 
 /* Functions used to get and set GCC's notion of in what directory
diff --git a/gcc/unwind-dw2-fde-glibc.c b/gcc/unwind-dw2-fde-glibc.c
index 25bf2bb1..014e9073 100644
--- a/gcc/unwind-dw2-fde-glibc.c
+++ b/gcc/unwind-dw2-fde-glibc.c
@@ -49,8 +49,9 @@
 #include "gthr.h"
 
 #if !defined(inhibit_libc) && defined(HAVE_LD_EH_FRAME_HDR) \
-    && (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2) \
-	|| (__GLIBC__ == 2 && __GLIBC_MINOR__ == 2 && defined(DT_CONFIG)))
+    && ((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2) \
+	|| (__GLIBC__ == 2 && __GLIBC_MINOR__ == 2 && defined(DT_CONFIG))) \
+    || (__FreeBSD_version >= 700022 ))
 
 #ifndef __RELOC_POINTER
 # define __RELOC_POINTER(ptr, base) ((ptr) + (base))
@@ -66,6 +67,13 @@ static const fde * _Unwind_Find_registered_FDE (void *pc, struct dwarf_eh_bases
 #define PT_GNU_EH_FRAME (PT_LOOS + 0x474e550)
 #endif
 
+/* Support FreeBSD */
+#ifndef ElfW
+# ifdef __ElfN
+#  define ElfW __ElfN
+# endif
+#endif
+
 struct unw_eh_callback_data
 {
   _Unwind_Ptr pc;
diff --git a/gcc/unwind-dw2.c b/gcc/unwind-dw2.c
index f55f5770..6a3bbb18 100644
--- a/gcc/unwind-dw2.c
+++ b/gcc/unwind-dw2.c
@@ -334,9 +334,11 @@ _Unwind_GetTextRelBase (struct _Unwind_Context *context)
 }
 #endif
 
+#ifndef inhibit_libc
 #ifdef MD_UNWIND_SUPPORT
 #include MD_UNWIND_SUPPORT
 #endif
+#endif
 
 /* Extract any interesting information from the CIE for the translation
    unit F belongs to.  Return a pointer to the byte after the augmentation,
diff --git a/include/libiberty.h b/include/libiberty.h
index 6ea8761f..19d1d46d 100644
--- a/include/libiberty.h
+++ b/include/libiberty.h
@@ -587,8 +587,11 @@ extern int pwait (int, int *, int);
 /* Like sprintf but provides a pointer to malloc'd storage, which must
    be freed by the caller.  */
 
+/* asprintf may be declared as a macro by glibc with __USE_FORTIFY_LEVEL.  */
+#ifndef asprintf
 extern int asprintf (char **, const char *, ...) ATTRIBUTE_PRINTF_2;
 #endif
+#endif
 
 #if !HAVE_DECL_VASPRINTF
 /* Like vsprintf but provides a pointer to malloc'd storage, which
diff --git a/libcpp/configure b/libcpp/configure
index 5d70aed0..d31e3055 100755
--- a/libcpp/configure
+++ b/libcpp/configure
@@ -8308,9 +8308,7 @@ case $target in
 	powerpc*-*-* | \
 	rs6000*-*-* | \
 	s390*-*-* | \
-	sparc64*-*-* | ultrasparc-*-freebsd* | \
-	sparcv9-*-solaris2* | \
-	sparc-*-solaris2.[789] | sparc-*-solaris2.1[0-9]* | \
+	sparc*-*-* | \
 	spu-*-* | \
 	sh[123456789l]*-*-*)
 		need_64bit_hwint=yes ;;
diff --git a/libffi/src/alpha/osf.S b/libffi/src/alpha/osf.S
index aba6782e..a6a7b1fc 100644
--- a/libffi/src/alpha/osf.S
+++ b/libffi/src/alpha/osf.S
@@ -358,4 +358,8 @@ $LASFDE3:
 	.byte	16		# uleb128 offset 16*-8
 	.align 3
 $LEFDE3:
+
+#ifdef __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
 #endif
diff --git a/libffi/src/arm/sysv.S b/libffi/src/arm/sysv.S
index 8c43d62d..b6802783 100644
--- a/libffi/src/arm/sysv.S
+++ b/libffi/src/arm/sysv.S
@@ -300,3 +300,6 @@ ARM_FUNC_START ffi_closure_SYSV
 	UNWIND .fnend
         .size    CNAME(ffi_closure_SYSV),.ffi_closure_SYSV_end-CNAME(ffi_closure_SYSV)
 
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",%progbits
+#endif
diff --git a/libffi/src/ia64/unix.S b/libffi/src/ia64/unix.S
index 45dabb74..45d0c5d5 100644
--- a/libffi/src/ia64/unix.S
+++ b/libffi/src/ia64/unix.S
@@ -553,3 +553,7 @@ ffi_closure_unix:
 	data8	@pcrel(.Lld_hfa_float)		// FFI_IA64_TYPE_HFA_FLOAT
 	data8	@pcrel(.Lld_hfa_double)		// FFI_IA64_TYPE_HFA_DOUBLE
 	data8	@pcrel(.Lld_hfa_ldouble)	// FFI_IA64_TYPE_HFA_LDOUBLE
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/m68k/sysv.S b/libffi/src/m68k/sysv.S
index d2a4ff1c..3face838 100644
--- a/libffi/src/m68k/sysv.S
+++ b/libffi/src/m68k/sysv.S
@@ -207,3 +207,7 @@ ffi_closure_struct_SYSV:
 	rts
 	CFI_ENDPROC()
 	.size	ffi_closure_struct_SYSV,.-ffi_closure_struct_SYSV
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/powerpc/linux64.S b/libffi/src/powerpc/linux64.S
index 2cfebbf1..204e3c40 100644
--- a/libffi/src/powerpc/linux64.S
+++ b/libffi/src/powerpc/linux64.S
@@ -179,3 +179,7 @@ ffi_call_LINUX64:
 	.align 3
 .LEFDE1:
 #endif
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/powerpc/linux64_closure.S b/libffi/src/powerpc/linux64_closure.S
index b19bc718..c45c8ef3 100644
--- a/libffi/src/powerpc/linux64_closure.S
+++ b/libffi/src/powerpc/linux64_closure.S
@@ -204,3 +204,7 @@ ffi_closure_LINUX64:
 	.align 3
 .LEFDE1:
 #endif
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/powerpc/ppc_closure.S b/libffi/src/powerpc/ppc_closure.S
index c9f5742f..f65784ba 100644
--- a/libffi/src/powerpc/ppc_closure.S
+++ b/libffi/src/powerpc/ppc_closure.S
@@ -295,3 +295,7 @@ END(ffi_closure_SYSV)
 .LEFDE1:
 
 #endif
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/powerpc/sysv.S b/libffi/src/powerpc/sysv.S
index 21367145..d402067a 100644
--- a/libffi/src/powerpc/sysv.S
+++ b/libffi/src/powerpc/sysv.S
@@ -223,3 +223,7 @@ END(ffi_call_SYSV)
       .align 2
 .LEFDE1:
 #endif
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/s390/sysv.S b/libffi/src/s390/sysv.S
index e9cbed97..09cdec14 100644
--- a/libffi/src/s390/sysv.S
+++ b/libffi/src/s390/sysv.S
@@ -427,3 +427,6 @@ ffi_closure_SYSV:
 
 #endif
 
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/sparc/v8.S b/libffi/src/sparc/v8.S
index ffcef68c..38307599 100644
--- a/libffi/src/sparc/v8.S
+++ b/libffi/src/sparc/v8.S
@@ -306,3 +306,7 @@ done2:
 	.byte	0x1f	! uleb128 0x1f
 	.align	WS
 .LLEFDE2:
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/sparc/v9.S b/libffi/src/sparc/v9.S
index d640e023..a8e8bf98 100644
--- a/libffi/src/sparc/v9.S
+++ b/libffi/src/sparc/v9.S
@@ -300,3 +300,7 @@ longdouble1:
 	.align 8
 .LLEFDE2:
 #endif
+
+#ifdef __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/x86/sysv.S b/libffi/src/x86/sysv.S
index a0daf1dc..4e652207 100644
--- a/libffi/src/x86/sysv.S
+++ b/libffi/src/x86/sysv.S
@@ -430,3 +430,7 @@ ffi_closure_raw_SYSV:
 #endif
 
 #endif /* ifndef __x86_64__ */
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/x86/unix64.S b/libffi/src/x86/unix64.S
index 831e1d71..a3388818 100644
--- a/libffi/src/x86/unix64.S
+++ b/libffi/src/x86/unix64.S
@@ -410,3 +410,7 @@ ffi_closure_unix64:
 .LEFDE3:
 
 #endif /* __x86_64__ */
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libgcc/Makefile.in b/libgcc/Makefile.in
index 94b6440f..b90f031b 100644
--- a/libgcc/Makefile.in
+++ b/libgcc/Makefile.in
@@ -184,7 +184,7 @@ export RANLIB_FOR_TARGET
 export libsubdir
 export slibdir
 
-version := $(shell $(CC) -dumpversion)
+version := $(shell cat $(srcdir)/../gcc/BASE-VER)
 
 ifeq ($(decimal_float),yes)
 ifeq ($(enable_decimal_float),bid)
diff --git a/libgomp/configure b/libgomp/configure
index 8d63ae93..e154eba4 100755
--- a/libgomp/configure
+++ b/libgomp/configure
@@ -3298,7 +3298,7 @@ save_CFLAGS="$CFLAGS"
 
 # Add -Wall -Werror if we are using GCC.
 if test "x$GCC" = "xyes"; then
-  XCFLAGS="$XCFLAGS -Wall -Werror"
+  XCFLAGS="$XCFLAGS -Wall"
 fi
 
 # Find other programs we need.
diff --git a/libiberty/Makefile.in b/libiberty/Makefile.in
index 3b99f404..d2f322fe 100644
--- a/libiberty/Makefile.in
+++ b/libiberty/Makefile.in
@@ -225,6 +225,7 @@ $(TARGETLIB): $(REQUIRED_OFILES) $(EXTRA_OFILES) $(LIBOBJS)
 	  $(AR) $(AR_FLAGS) $(TARGETLIB) \
 	    $(REQUIRED_OFILES) $(EXTRA_OFILES) $(LIBOBJS); \
 	  $(RANLIB) $(TARGETLIB); \
+	  cp $(TARGETLIB) ../ ; \
 	  cd ..; \
 	else true; fi
 
diff --git a/libjava/classpath/native/fdlibm/dtoa.c b/libjava/classpath/native/fdlibm/dtoa.c
index 5fb6aae2..e710d96d 100644
--- a/libjava/classpath/native/fdlibm/dtoa.c
+++ b/libjava/classpath/native/fdlibm/dtoa.c
@@ -28,6 +28,7 @@
 
 #include "mprec.h"
 #include <string.h>
+#include <stdlib.h>
 
 static int
 _DEFUN (quorem,
diff --git a/libjava/configure.ac b/libjava/configure.ac
index 2990ed51..d64fec6d 100644
--- a/libjava/configure.ac
+++ b/libjava/configure.ac
@@ -1026,7 +1026,7 @@ if test "x${with_newlib}" = "xyes"; then
    PLATFORMNET=NoNet
 else
    AC_CHECK_FUNCS([strerror_r select fstat open fsync sleep opendir \
-                   localtime_r readdir_r getpwuid_r getcwd \
+                   localtime_r getpwuid_r getcwd \
 		   access stat lstat mkdir rename rmdir unlink utime chmod readlink \
 		   nl_langinfo setlocale \
 		   inet_pton uname inet_ntoa \
diff --git a/libjava/include/config.h.in b/libjava/include/config.h.in
index 99da7024..3fdde394 100644
--- a/libjava/include/config.h.in
+++ b/libjava/include/config.h.in
@@ -214,9 +214,6 @@
 /* Define to 1 if you have the <pwd.h> header file. */
 #undef HAVE_PWD_H
 
-/* Define to 1 if you have the `readdir_r' function. */
-#undef HAVE_READDIR_R
-
 /* Define to 1 if you have the `readlink' function. */
 #undef HAVE_READLINK
 
diff --git a/libjava/include/i386-signal.h b/libjava/include/i386-signal.h
index a3d3a1b7..85f286e7 100644
--- a/libjava/include/i386-signal.h
+++ b/libjava/include/i386-signal.h
@@ -26,7 +26,7 @@ static void _Jv_##_name (int, siginfo_t *,			\
 #define HANDLE_DIVIDE_OVERFLOW						\
 do									\
 {									\
-  struct ucontext *_uc = (struct ucontext *)_p;				\
+  ucontext_t *_uc = (ucontext_t *)_p;					\
   gregset_t &_gregs = _uc->uc_mcontext.gregs;				\
   unsigned char *_eip = (unsigned char *)_gregs[REG_EIP];		\
 									\
diff --git a/libjava/include/x86_64-signal.h b/libjava/include/x86_64-signal.h
index 4bd8a360..d04e8689 100644
--- a/libjava/include/x86_64-signal.h
+++ b/libjava/include/x86_64-signal.h
@@ -28,7 +28,7 @@ static void _Jv_##_name (int, siginfo_t *,			\
 #define HANDLE_DIVIDE_OVERFLOW						\
 do									\
 {									\
-  struct ucontext *_uc = (struct ucontext *)_p;				\
+  ucontext_t *_uc = (ucontext_t *)_p;					\
   gregset_t &_gregs = _uc->uc_mcontext.gregs;				\
   unsigned char *_rip = (unsigned char *)_gregs[REG_RIP];		\
 									\
diff --git a/libjava/java/io/natFilePosix.cc b/libjava/java/io/natFilePosix.cc
index ead28557..3cb6f8bb 100644
--- a/libjava/java/io/natFilePosix.cc
+++ b/libjava/java/io/natFilePosix.cc
@@ -292,13 +292,7 @@ java::io::File::performList (java::io::FilenameFilter *filter,
 
   java::util::ArrayList *list = new java::util::ArrayList ();
   struct dirent *d;
-#if defined(HAVE_READDIR_R) && defined(_POSIX_PTHREAD_SEMANTICS)
-  int name_max = pathconf (buf, _PC_NAME_MAX);
-  char dbuf[sizeof (struct dirent) + name_max + 1];
-  while (readdir_r (dir, (struct dirent *) dbuf, &d) == 0 && d != NULL)
-#else /* HAVE_READDIR_R */
   while ((d = readdir (dir)) != NULL)
-#endif /* HAVE_READDIR_R */
     {
       // Omit "." and "..".
       if (d->d_name[0] == '.'
diff --git a/libjava/prims.cc b/libjava/prims.cc
index d94cd92c..c766370f 100644
--- a/libjava/prims.cc
+++ b/libjava/prims.cc
@@ -38,7 +38,6 @@ details.  */
 #endif
 
 #ifndef DISABLE_GETENV_PROPERTIES
-#include <ctype.h>
 #include <java-props.h>
 #define PROCESS_GCJ_PROPERTIES process_gcj_properties()
 #else
@@ -985,6 +984,8 @@ static java::lang::Thread *main_thread;
 
 #ifndef DISABLE_GETENV_PROPERTIES
 
+#define c_isspace(c) (memchr (" \t\n\r\v\f", c, 6) != NULL)
+
 static char *
 next_property_key (char *s, size_t *length)
 {
@@ -993,7 +994,7 @@ next_property_key (char *s, size_t *length)
   JvAssert (s);
 
   // Skip over whitespace
-  while (isspace (*s))
+  while (c_isspace (*s))
     s++;
 
   // If we've reached the end, return NULL.  Also return NULL if for
@@ -1005,7 +1006,7 @@ next_property_key (char *s, size_t *length)
 
   // Determine the length of the property key.
   while (s[l] != 0
-	 && ! isspace (s[l])
+	 && ! c_isspace (s[l])
 	 && s[l] != ':'
 	 && s[l] != '=')
     {
@@ -1027,19 +1028,19 @@ next_property_value (char *s, size_t *length)
 
   JvAssert (s);
 
-  while (isspace (*s))
+  while (c_isspace (*s))
     s++;
 
   if (*s == ':'
       || *s == '=')
     s++;
 
-  while (isspace (*s))
+  while (c_isspace (*s))
     s++;
 
   // Determine the length of the property value.
   while (s[l] != 0
-	 && ! isspace (s[l])
+	 && ! c_isspace (s[l])
 	 && s[l] != ':'
 	 && s[l] != '=')
     {
diff --git a/libmudflap/mf-runtime.c b/libmudflap/mf-runtime.c
index 79fdb323..8781e311 100644
--- a/libmudflap/mf-runtime.c
+++ b/libmudflap/mf-runtime.c
@@ -308,6 +308,14 @@ __mf_set_default_options ()
 #ifdef LIBMUDFLAPTH
   __mf_opts.thread_stack = 0;
 #endif
+
+  /* PR41443: Beware that the above flags will be applied to
+     setuid/setgid binaries, and cannot be overriden with
+     $MUDFLAP_OPTIONS.  So the defaults must be non-exploitable. 
+
+     Should we consider making the default violation_mode something
+     harsher than viol_nop?  OTOH, glibc's MALLOC_CHECK_ is disabled
+     by default for these same programs. */
 }
 
 static struct mudoption
@@ -447,7 +455,7 @@ __mf_usage ()
            "This is a %s%sGCC \"mudflap\" memory-checked binary.\n"
            "Mudflap is Copyright (C) 2002-2008 Free Software Foundation, Inc.\n"
            "\n"
-           "The mudflap code can be controlled by an environment variable:\n"
+           "Unless setuid, a program's mudflap options be set by an environment variable:\n"
            "\n"
            "$ export MUDFLAP_OPTIONS='<options>'\n"
            "$ <mudflapped_program>\n"
@@ -710,7 +718,8 @@ __mf_init ()
 
   __mf_set_default_options ();
 
-  ov = getenv ("MUDFLAP_OPTIONS");
+  if (getuid () == geteuid () && getgid () == getegid ()) /* PR41433, not setuid */
+    ov = getenv ("MUDFLAP_OPTIONS");
   if (ov)
     {
       int rc = __mfu_set_options (ov);
