diff --git a/gcc/fortran/simplify.c b/gcc/fortran/simplify.c
index 40b3aec1..b3f7f2a9 100644
--- a/gcc/fortran/simplify.c
+++ b/gcc/fortran/simplify.c
@@ -2034,6 +2034,9 @@ simplify_bound_dim (gfc_expr *array, gfc_expr *kind, int d, int upper,
   gfc_expr *l, *u, *result;
   int k;
 
+  if (gfc_resolve_array_spec (as, 0) == FAILURE)
+    return NULL;
+
   /* The last dimension of an assumed-size array is special.  */
   if (d == as->rank && as->type == AS_ASSUMED_SIZE && !upper)
     {
diff --git a/gcc/testsuite/gfortran.dg/bound_simplification_3.f90 b/gcc/testsuite/gfortran.dg/bound_simplification_3.f90
new file mode 100644
index 00000000..de3a3dc8
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/bound_simplification_3.f90
@@ -0,0 +1,23 @@
+! { dg-do compile }
+! { dg-options "-fdump-tree-original" }
+!
+! PR fortran/54208
+! The I and J definitions used to raise an error because ARR's array spec
+! was resolved to late for the LBOUND and UBOUND calls to be simplified to
+! a constant.
+!
+! Contributed by Carlos A. Cruz <carlos.a.cruz@nasa.gov>
+
+program testit
+  integer, parameter :: n=2
+  integer, dimension(1-min(n,2)/2:n) :: arr
+  integer, parameter :: i=lbound(arr,1)
+  integer, parameter :: j=ubound(arr,1)
+  ! write(6,*) i, j
+  if (i /= 0) call abort
+  if (j /= 2) call abort
+end program testit
+
+! { dg-final { scan-tree-dump-times "bound" 0 "original" } }
+! { dg-final { scan-tree-dump-times "abort" 0 "original" } }
+! { dg-final { cleanup-tree-dump "original" } }
